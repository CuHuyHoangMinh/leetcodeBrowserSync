{
  "code": "\nclass Solution {\n    public int[] sortByBits(int[] arr) {\n        List<Integer> a = new ArrayList<Integer>();\n        for (int i :arr) a.add(i);\n        Collections.sort(a,new Comparator<Integer>() {\n            @Override\n            public int compare(Integer a, Integer b){\n                if (Integer.compare(Integer.bitCount(a),Integer.bitCount(b)) == 0) \n                    return Integer.compare(a,b);\n                return Integer.compare(Integer.bitCount(a),Integer.bitCount(b));\n            }\n        } );\n        int []re = new int[a.size()];\n        for (int i = 0; i< re.length;i++) re[i] = a.get(i);\n        return re;\n    }\n}",
  "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1095491223,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "43.3 MB",
  "runtime": "9 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "2 weeks",
  "timestamp": 1699562417,
  "title": "Sort Integers by The Number of 1 Bits",
  "title_slug": "sort-integers-by-the-number-of-1-bits",
  "url": "/submissions/detail/1095491223/"
}{
  "code": "class Solution {\n    public int equalPairs(int[][] grid) {\n        HashMap<String,Integer> map1 = new HashMap<>();\n        HashMap<String,Integer> map2 = new HashMap<>();\n\n        int n = grid.length;\n        int m = grid[0].length;\n        for (int i = 0 ; i<n;i++){\n            String k = \"\";\n            for (int j = 0; j<m;j++){\n                k = k+grid[i][j]+\",\";\n            }\n            map1.put(k,map1.getOrDefault(k,0)+1);\n        }\n        for (int i=0;i<m;i++){\n            String k = \"\";\n            for (int j = 0; j<n;j++){\n                k = k+grid[j][i]+\",\";\n            }\n            map2.put(k,map2.getOrDefault(k,0)+1);\n        }\n        int re = 0;\n        for (String s: map1.keySet()){\n            if (map2.containsKey(s)){\n                re = re + map1.get(s)*map2.get(s);\n            }\n        }\n        return re;\n    }\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1095480296,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "53.7 MB",
  "runtime": "87 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "2 weeks",
  "timestamp": 1699561122,
  "title": "Equal Row and Column Pairs",
  "title_slug": "equal-row-and-column-pairs",
  "url": "/submissions/detail/1095480296/"
}{
  "code": "class Solution {\n    public int countHomogenous(String s) {\n        long count = 0;\n        int pointer = 0;\n        char [] a = s.toCharArray();\n        int beg = 0;\n        while (pointer<a.length){\n            while (pointer < a.length-1 && a[pointer] == a[pointer +1]) pointer ++;\n            long len = pointer - beg +1;\n            count = (count + len*(len+1)/2) % 1000000007;\n            pointer++;\n            beg= pointer;\n        }\n        return Math.toIntExact(count);\n        \n    }\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1095475180,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "44.4 MB",
  "runtime": "6 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "2 weeks",
  "timestamp": 1699560549,
  "title": "Count Number of Homogenous Substrings",
  "title_slug": "count-number-of-homogenous-substrings",
  "url": "/submissions/detail/1095475180/"
}{
  "code": "class Solution {\n    public int countHomogenous(String s) {\n        int count = 0;\n        int pointer = 0;\n        char [] a = s.toCharArray();\n        int beg = 0;\n        while (pointer<a.length){\n            while (pointer < a.length-1 && a[pointer] == a[pointer +1]) pointer ++;\n            int len = pointer - beg +1;\n            count = (count + len*(len+1)/2) % 100000007;\n            pointer++;\n            beg= pointer;\n        }\n        return count;\n        \n    }\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111110111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1095471980,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "2 weeks",
  "timestamp": 1699560192,
  "title": "Count Number of Homogenous Substrings",
  "title_slug": "count-number-of-homogenous-substrings",
  "url": "/submissions/detail/1095471980/"
}{
  "code": "class Solution {\n    public int countHomogenous(String s) {\n        int count = 0;\n        int pointer = 0;\n        char [] a = s.toCharArray();\n        int beg = 0;\n        while (pointer<a.length){\n            while (pointer < a.length-1 && a[pointer] == a[pointer +1]) pointer ++;\n            int len = pointer - beg +1;\n            count = (count + len*(len+1)/2) % 1000000007;\n            pointer++;\n            beg= pointer;\n        }\n        return count;\n        \n    }\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111110111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1095471629,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "2 weeks",
  "timestamp": 1699560151,
  "title": "Count Number of Homogenous Substrings",
  "title_slug": "count-number-of-homogenous-substrings",
  "url": "/submissions/detail/1095471629/"
}{
  "code": "class Solution {\n    public int longestConsecutive(int[] nums) {\n        HashMap<Integer,Integer> map = new HashMap<>();\n        int max = 0;\n        for (int i:nums){\n            if (map.containsKey(i)) continue;\n            if ( (map.containsKey(i-1) && map.containsKey(i+1)) ){\n                map.put(i,1+map.get(i-1)+map.get(i+1));\n                map.put(i-map.get(i-1),map.get(i));\n                map.put(i+map.get(i+1),map.get(i));\n            } else if (map.containsKey(i-1)){\n                map.put(i,map.get(i-1)+1);\n                map.put(i-map.get(i-1),map.get(i));\n            } else if (map.containsKey(i+1)){\n                map.put(i,map.get(i+1)+1);\n                map.put(i+map.get(i+1),map.get(i));\n            } else{\n                map.put(i,1);\n            }\n            if (max< map.get(i)) max = map.get(i);\n        }\n        return max; \n        \n    }\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1090933513,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "57.9 MB",
  "runtime": "74 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "2 weeks, 5 days",
  "timestamp": 1699053737,
  "title": "Longest Consecutive Sequence",
  "title_slug": "longest-consecutive-sequence",
  "url": "/submissions/detail/1090933513/"
}{
  "code": "class Solution {\n    public int longestConsecutive(int[] nums) {\n        HashMap<Integer,Integer> map = new HashMap<>();\n        int max = 0;\n        for (int i:nums){\n            if ( (map.containsKey(i-1) && map.containsKey(i+1)) ){\n                map.put(i,1+map.get(i-1)+map.get(i+1));\n                map.put(i-map.get(i-1),map.get(i));\n                map.put(i+map.get(i+1),map.get(i));\n            } else if (map.containsKey(i-1)){\n                map.put(i,map.get(i-1)+1);\n                map.put(i-map.get(i-1),map.get(i));\n            } else if (map.containsKey(i+1)){\n                map.put(i,map.get(i+1)+1);\n                map.put(i+map.get(i+1),map.get(i));\n            } else{\n                map.put(i,1);\n            }\n            if (max< map.get(i)) max = map.get(i);\n        }\n        return max; \n        \n    }\n}",
  "compare_result": "111111111011111011110001010000110101000000001100001010000000001011011111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1090932821,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "2 weeks, 5 days",
  "timestamp": 1699053623,
  "title": "Longest Consecutive Sequence",
  "title_slug": "longest-consecutive-sequence",
  "url": "/submissions/detail/1090932821/"
}{
  "code": "class Solution {\n    public int uniquePathsWithObstacles(int[][] grid) {\n        int n = grid.length;\n        int m = grid[0].length;\n        int [][] dp = new int[n][m];\n        if (grid[0][0] == 1) return 0;\n        int val = 1;\n        for (int i = 0; i<n;i++){\n            if (grid[i][0] == 1) val = Integer.MAX_VALUE;\n            dp[i][0] = val;\n        }\n        val = 1;\n        for (int i = 0; i<m;i++){\n            if (grid[0][i] == 1) val = Integer.MAX_VALUE;\n            dp[0][i] = val;\n        }\n        for (int i=0;i<n;i++){\n            for (int j = 0;j<m;j++){\n                if (grid[i][j] == 1) dp[i][j] = Integer.MAX_VALUE;\n            }\n        }\n\n        // for (int i = 0;i<n;i++){\n        //     for (int j = 0; j<m ; j++){\n        //         System.out.print(dp[i][j] + \" \");\n        //     }\n        //     System.out.println();\n        // }\n        \n        for (int i = 1; i<n;i++){\n            for (int j = 1;j<m;j++){\n                if (grid[i][j] == 0) {\n                    if (valid(i-1,j,n,m,dp) == Integer.MAX_VALUE && valid(i,j-1,n,m,dp) == Integer.MAX_VALUE ) dp[i][j] = Integer.MAX_VALUE;\n                    else if (valid(i-1,j,n,m,dp)== Integer.MAX_VALUE ) dp[i][j] = valid(i,j-1,n,m,dp);\n                    else if ( valid(i,j-1,n,m,dp) == Integer.MAX_VALUE) dp[i][j] = valid(i-1,j,n,m,dp);\n                    else dp[i][j] = valid(i-1,j,n,m,dp) + valid(i,j-1,n,m,dp);\n                }\n            }\n        }\n        // for (int i = 0;i<n;i++){\n        //     for (int j = 0; j<m ; j++){\n        //         System.out.print(dp[i][j] + \" \");\n        //     }\n        //     System.out.println();\n        // }\n\n        // for (int )\n        return dp[n-1][m-1]==Integer.MAX_VALUE?0:dp[n-1][m-1];\n    }\n\n    public int valid(int x,int y,int n,int m, int [][]dp){\n        if (x>=n) return Integer.MAX_VALUE;\n        if (y>=m) return Integer.MAX_VALUE;\n        if (x<0) return Integer.MAX_VALUE;\n        if (y<0) return Integer.MAX_VALUE;\n        if (dp[x][y] == Integer.MAX_VALUE) return Integer.MAX_VALUE;\n        return dp[x][y];\n    }\n}",
  "compare_result": "11111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1089308951,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "40 MB",
  "runtime": "1 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "3 weeks, 1 day",
  "timestamp": 1698861103,
  "title": "Unique Paths II",
  "title_slug": "unique-paths-ii",
  "url": "/submissions/detail/1089308951/"
}{
  "code": "class Solution {\n    public int uniquePathsWithObstacles(int[][] grid) {\n        int n = grid.length;\n        int m = grid[0].length;\n        int [][] dp = new int[n][m];\n        if (grid[0][0] == 1) return 0;\n        \n        for (int i = 0; i<n;i++){\n            dp[i][0] = 1;\n        }\n        for (int i = 0; i<m;i++){\n            dp[0][i] = 1;\n        }\n        for (int i=0;i<n;i++){\n            for (int j = 0;j<m;j++){\n                if (grid[i][j] == 1) dp[i][j] = Integer.MAX_VALUE;\n            }\n        }\n        for (int i = 1; i<n;i++){\n            for (int j = 1;j<m;j++){\n                if (grid[i][j] == 0) {\n                    if (valid(i-1,j,n,m,dp) == Integer.MAX_VALUE && valid(i,j-1,n,m,dp) == Integer.MAX_VALUE ) dp[i][j] = Integer.MAX_VALUE;\n                    else if (valid(i-1,j,n,m,dp)== Integer.MAX_VALUE ) dp[i][j] = valid(i,j-1,n,m,dp);\n                    else if ( valid(i,j-1,n,m,dp) == Integer.MAX_VALUE) dp[i][j] = valid(i-1,j,n,m,dp);\n                    else dp[i][j] = valid(i-1,j,n,m,dp) + valid(i,j-1,n,m,dp);\n                }\n            }\n        }\n\n        // for (int )\n        return dp[n-1][m-1]==Integer.MAX_VALUE?0:dp[n-1][m-1];\n    }\n\n    public int valid(int x,int y,int n,int m, int [][]dp){\n        if (x>=n) return Integer.MAX_VALUE;\n        if (y>=m) return Integer.MAX_VALUE;\n        if (x<0) return Integer.MAX_VALUE;\n        if (y<0) return Integer.MAX_VALUE;\n        if (dp[x][y] == Integer.MAX_VALUE) return Integer.MAX_VALUE;\n        return dp[x][y];\n    }\n}",
  "compare_result": "11111111111111111101011110100000000111011",
  "flag_type": 1,
  "has_notes": false,
  "id": 1089300284,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "3 weeks, 1 day",
  "timestamp": 1698860454,
  "title": "Unique Paths II",
  "title_slug": "unique-paths-ii",
  "url": "/submissions/detail/1089300284/"
}{
  "code": "class Solution {\n    public int uniquePathsWithObstacles(int[][] grid) {\n        int n = grid.length;\n        int m = grid[0].length;\n        int [][] dp = new int[n][m];\n        if (grid[0][0] == 1) return 0;\n        \n        for (int i = 0; i<n;i++){\n            dp[i][0] = 1;\n        }\n        for (int i = 0; i<m;i++){\n            dp[0][i] = 1;\n        }\n        for (int i=0;i<n;i++){\n            for (int j = 0;j<m;j++){\n                if (grid[i][j] == 1) dp[i][j] = Integer.MAX_VALUE;\n            }\n        }\n        for (int i = 1; i<n;i++){\n            for (int j = 1;j<m;j++){\n                if (grid[i][j] == 0) {\n                    dp[i][j] = valid(i-1,j,n,m,dp) + valid(i,j-1,n,m,dp);\n                }\n            }\n        }\n\n        // for (int )\n        return dp[n-1][m-1]==Integer.MAX_VALUE?0:dp[n-1][m-1];\n    }\n\n    public int valid(int x,int y,int n,int m, int [][]dp){\n        if (x>=n) return 0;\n        if (y>=m) return 0;\n        if (x<0) return 0;\n        if (y<0) return 0;\n        if (dp[x][y] == Integer.MAX_VALUE) return 0;\n        return dp[x][y];\n    }\n}",
  "compare_result": "11111111111111111101011110100000000111011",
  "flag_type": 1,
  "has_notes": false,
  "id": 1088642751,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "3 weeks, 2 days",
  "timestamp": 1698784147,
  "title": "Unique Paths II",
  "title_slug": "unique-paths-ii",
  "url": "/submissions/detail/1088642751/"
}{
  "code": "class Solution {\n    public int uniquePathsWithObstacles(int[][] grid) {\n        int n = grid.length;\n        int m = grid[0].length;\n        int [][] dp = new int[n][m];\n\n        \n        for (int i = 0; i<n;i++){\n            dp[i][0] = 1;\n        }\n        for (int i = 0; i<m;i++){\n            dp[0][i] = 1;\n        }\n        for (int i=0;i<n;i++){\n            for (int j = 0;j<m;j++){\n                if (grid[i][j] == 1) dp[i][j] = Integer.MAX_VALUE;\n            }\n        }\n        for (int i = 1; i<n;i++){\n            for (int j = 1;j<m;j++){\n                if (grid[i][j] == 0) {\n                    dp[i][j] = valid(i-1,j,n,m,dp) + valid(i,j-1,n,m,dp);\n                }\n            }\n        }\n\n        // for (int )\n        return dp[n-1][m-1]==Integer.MAX_VALUE?0:dp[n-1][m-1];\n    }\n\n    public int valid(int x,int y,int n,int m, int [][]dp){\n        if (x>=n) return 0;\n        if (y>=m) return 0;\n        if (x<0) return 0;\n        if (y<0) return 0;\n        if (dp[x][y] == Integer.MAX_VALUE) return 0;\n        return dp[x][y];\n    }\n}",
  "compare_result": "11111110111011110101011110000000000111011",
  "flag_type": 1,
  "has_notes": false,
  "id": 1088642393,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "3 weeks, 2 days",
  "timestamp": 1698784106,
  "title": "Unique Paths II",
  "title_slug": "unique-paths-ii",
  "url": "/submissions/detail/1088642393/"
}{
  "code": "class Solution {\n    public int uniquePathsWithObstacles(int[][] grid) {\n        int n = grid.length;\n        int m = grid[0].length;\n        int [][] dp = new int[n][m];\n\n        \n        for (int i = 0; i<n;i++){\n            dp[i][0] = 1;\n        }\n        for (int i = 0; i<m;i++){\n            dp[0][i] = 1;\n        }\n        for (int i=0;i<n;i++){\n            for (int j = 0;j<m;j++){\n                if (grid[i][j] == 1) dp[i][j] = Integer.MAX_VALUE;\n            }\n        }\n        for (int i = 1; i<n;i++){\n            for (int j = 1;j<m;j++){\n                if (grid[i][j] == 0) {\n                    dp[i][j] = valid(i-1,j,n,m,dp) + valid(i,j-1,n,m,dp);\n                }\n            }\n        }\n\n        // for (int )\n        return dp[n-1][m-1];\n    }\n\n    public int valid(int x,int y,int n,int m, int [][]dp){\n        if (x>=n) return 0;\n        if (y>=m) return 0;\n        if (x<0) return 0;\n        if (y<0) return 0;\n        if (dp[x][y] == Integer.MAX_VALUE) return 0;\n        return dp[x][y];\n    }\n}",
  "compare_result": "11010100010001110101011100000000000111011",
  "flag_type": 1,
  "has_notes": false,
  "id": 1088642006,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "3 weeks, 2 days",
  "timestamp": 1698784062,
  "title": "Unique Paths II",
  "title_slug": "unique-paths-ii",
  "url": "/submissions/detail/1088642006/"
}{
  "code": "class Solution {\n    public int minPathSum(int[][] grid) {\n        int n = grid.length;\n        int m = grid[0].length;\n        int [][] dp = new int[n][m];\n        for (int i = 0;i<n;i++ )\n            Arrays.fill(dp[i],Integer.MAX_VALUE);\n        dp[0][0] = grid[0][0];\n        for (int i = 0; i<n;i++){\n            for (int j = 0;j<m;j++){\n                if (valid(i+1,j,n,m)){\n                    dp[i+1][j] = Integer.min(grid[i+1][j] + dp[i][j],dp[i+1][j]);\n                }\n                if (valid(i-1,j,n,m)){\n                    dp[i-1][j] = Integer.min(grid[i-1][j] + dp[i][j],dp[i-1][j]);\n                }\n                if (valid(i,j+1,n,m)){\n                    dp[i][j+1] = Integer.min(grid[i][j+1] + dp[i][j],dp[i][j+1]);\n                }\n                if (valid(i,j-1,n,m)){\n                    dp[i][j-1] = Integer.min(grid[i][j-1] + dp[i][j],dp[i][j-1]);\n                }\n            }\n        }\n\n        // for (int )\n        return dp[n-1][m-1];\n        \n    }\n    public boolean valid(int x,int y,int n,int m){\n        if (x>=n) return false;\n        if (y>=m) return false;\n        if (x<0) return false;\n        if (y<0) return false;\n        return true;\n    }\n}",
  "compare_result": "1111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1088621425,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "43.8 MB",
  "runtime": "16 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "3 weeks, 2 days",
  "timestamp": 1698781781,
  "title": "Minimum Path Sum",
  "title_slug": "minimum-path-sum",
  "url": "/submissions/detail/1088621425/"
}{
  "code": "class Solution {\n    public int minimumTotal(List<List<Integer>> triangle) {\n\n        for (int i = 1;i<triangle.size();i++){\n            int m = triangle.get(i).size();\n            for (int j = 0; j< m;j++){\n                int l = j-1;\n                int r = j;\n                if (l<0) triangle.get(i).set(j,triangle.get(i).get(j) + triangle.get(i-1).get(r));\n                else if (r>=triangle.get(i-1).size() ) triangle.get(i).set(j,triangle.get(i).get(j) + triangle.get(i-1).get(l));\n                else triangle.get(i).set(j,Integer.min(triangle.get(i).get(j) + triangle.get(i-1).get(r), triangle.get(i).get(j) + triangle.get(i-1).get(l)));\n            }\n        }\n        int min = Integer.MAX_VALUE;\n        for (int i = 0;i<triangle.get(triangle.size()-1).size();i++){\n            if (min>triangle.get(triangle.size()-1).get(i)) min = triangle.get(triangle.size()-1).get(i);\n        }\n        return min;\n    }\n}",
  "compare_result": "11111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1088575661,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "43.6 MB",
  "runtime": "10 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "3 weeks, 2 days",
  "timestamp": 1698777427,
  "title": "Triangle",
  "title_slug": "triangle",
  "url": "/submissions/detail/1088575661/"
}{
  "code": "class Solution {\n    public int minimumTotal(List<List<Integer>> triangle) {\n\n        for (int i = 1;i<triangle.size();i++){\n            int m = triangle.get(i).size();\n            for (int j = 0; j< m;j++){\n                int l = j-1;\n                int r = j;\n                if (l<0) triangle.get(i).set(j,triangle.get(i).get(j) + triangle.get(i-1).get(r));\n                else if (r>=triangle.get(i-1).size() ) triangle.get(i).set(j,triangle.get(i).get(j) + triangle.get(i-1).get(l));\n                else triangle.get(i).set(j,Integer.min(triangle.get(i).get(j) + triangle.get(i-1).get(r), triangle.get(i).get(j) + triangle.get(i-1).get(l)));\n            }\n        }\n        int min = Integer.MAX_VALUE;\n        for (int i = 0;i<triangle.get(triangle.size()-1).size();i++){\n            if (min>triangle.get(triangle.size()-1).get(i)) min = triangle.get(triangle.size()-1).get(i);\n        }\n        return min;\n    }\n}",
  "compare_result": "11111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1088575551,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "43.9 MB",
  "runtime": "10 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "3 weeks, 2 days",
  "timestamp": 1698777419,
  "title": "Triangle",
  "title_slug": "triangle",
  "url": "/submissions/detail/1088575551/"
}{
  "code": "class Solution {\n    public int minimumTotal(List<List<Integer>> triangle) {\n        List<List<Integer>> dp = new ArrayList<>();\n        ArrayList<Integer> first = new ArrayList<>();\n        first.add(triangle.get(0).get(0));\n        dp.add(first);\n        for (int i = 1;i<triangle.size();i++){\n            int m = triangle.get(i).size();\n            ArrayList<Integer> temp = new ArrayList<>();\n            for (int j = 0; j< m;j++){\n                int l = j-1;\n                int r = j;\n                if (l<0) temp.add(triangle.get(i).get(j) + dp.get(i-1).get(r));\n                else if (r>=triangle.get(i-1).size() ) temp.add(triangle.get(i).get(j) + dp.get(i-1).get(l));\n                else temp.add(Integer.min(triangle.get(i).get(j) + dp.get(i-1).get(r), triangle.get(i).get(j) + dp.get(i-1).get(l)));\n            }\n            dp.add(temp);\n        }\n        int min = Integer.MAX_VALUE;\n        for (int i = 0;i<dp.get(dp.size()-1).size();i++){\n            if (min>dp.get(dp.size()-1).get(i)) min = dp.get(dp.size()-1).get(i);\n        }\n        return min;\n    }\n}",
  "compare_result": "11111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1088573114,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "43.7 MB",
  "runtime": "9 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "3 weeks, 2 days",
  "timestamp": 1698777213,
  "title": "Triangle",
  "title_slug": "triangle",
  "url": "/submissions/detail/1088573114/"
}{
  "code": "class Solution {\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\n        HashMap<Integer,Integer> m = new HashMap<>();\n        for (int i = 0; i< nums.length;i++){\n            if (!m.containsKey(nums[i])){\n                m.put(nums[i],i);\n            } else{\n                if (i-m.get(nums[i])<= k) return true;\n                m.put(nums[i],i);\n            }\n        }\n        return false;\n    }\n}",
  "compare_result": "1111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1087892084,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "56.8 MB",
  "runtime": "20 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "3 weeks, 2 days",
  "timestamp": 1698702911,
  "title": "Contains Duplicate II",
  "title_slug": "contains-duplicate-ii",
  "url": "/submissions/detail/1087892084/"
}{
  "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public boolean hasCycle(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        if (head == null) return false;\n        if (head.next == null ) return false;\n        if (head.next.next == null) return false;\n        while (slow!=null && fast!=null){\n            // if (slow.next == null) return false;\n            if (fast.next == null) return false;\n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast) return true;\n        }\n        return false;\n        \n    }\n}",
  "compare_result": "11111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1087887961,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "43.4 MB",
  "runtime": "0 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "3 weeks, 2 days",
  "timestamp": 1698702360,
  "title": "Linked List Cycle",
  "title_slug": "linked-list-cycle",
  "url": "/submissions/detail/1087887961/"
}{
  "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public boolean hasCycle(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        if (head == null) return false;\n        if (head.next == null ) return false;\n        if (head.next.next == null) return false;\n        while (slow!=null && fast!=null){\n            \n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast) return true;\n        }\n        return false;\n        \n    }\n}",
  "compare_result": "11111111111111000000000",
  "flag_type": 1,
  "has_notes": false,
  "id": 1087887197,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 15,
  "status_display": "Runtime Error",
  "time": "3 weeks, 2 days",
  "timestamp": 1698702252,
  "title": "Linked List Cycle",
  "title_slug": "linked-list-cycle",
  "url": "/submissions/detail/1087887197/"
}{
  "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public boolean hasCycle(ListNode head) {\n        HashSet<ListNode> set = new HashSet<>();\n        while (head!=null){\n            if (set.contains(head)) return true;\n            set.add(head);\n            head = head.next;\n        }\n        return false;\n        \n    }\n}",
  "compare_result": "11111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1087885291,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "42.9 MB",
  "runtime": "4 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "3 weeks, 2 days",
  "timestamp": 1698701992,
  "title": "Linked List Cycle",
  "title_slug": "linked-list-cycle",
  "url": "/submissions/detail/1087885291/"
}{
  "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {\n        ListNode re = null;\n        if (list2 == null) return list1;\n        if (list1 == null) return list2;\n        if (list1.val >= list2.val){\n            re = list2;\n            list2 = list2.next;\n        }  else{\n            re = list1;\n            list1 = list1.next;\n        }\n        ListNode cur = re;\n        while (list1!=null && list2!=null){\n            if (list1.val>=list2.val){\n                cur.next = list2;\n                list2 = list2.next;\n            } else{\n                cur.next = list1;\n                list1 = list1.next;\n            }\n            cur = cur.next;\n        }\n        if (list1 == null) cur.next = list2;\n        if (list2 == null) cur.next = list1;\n        return re;\n        \n    }\n}",
  "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1087883993,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "40.8 MB",
  "runtime": "0 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "3 weeks, 2 days",
  "timestamp": 1698701815,
  "title": "Merge Two Sorted Lists",
  "title_slug": "merge-two-sorted-lists",
  "url": "/submissions/detail/1087883993/"
}{
  "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null ) return 0;\n        return Integer.max(maxDepth(root.left)+1,maxDepth(root.right)+1);\n    }\n}",
  "compare_result": "111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1087879511,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "41.5 MB",
  "runtime": "0 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "3 weeks, 2 days",
  "timestamp": 1698701217,
  "title": "Maximum Depth of Binary Tree",
  "title_slug": "maximum-depth-of-binary-tree",
  "url": "/submissions/detail/1087879511/"
}{
  "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null) return false;\n        if ( p.val!=q.val ) return false;\n        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n        \n    }\n}",
  "compare_result": "1111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1087878932,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "39.9 MB",
  "runtime": "0 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "3 weeks, 2 days",
  "timestamp": 1698701138,
  "title": "Same Tree",
  "title_slug": "same-tree",
  "url": "/submissions/detail/1087878932/"
}{
  "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode invertTree(TreeNode root) {\n        iTree(root);\n        return root;\n    }\n    public void iTree(TreeNode root){\n        if (root == null) return;\n        TreeNode temp = root.left;\n        root.left = root.right;\n        root.right = temp;\n        iTree(root.left);\n        iTree(root.right);\n    }\n}",
  "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1087877829,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "39.6 MB",
  "runtime": "0 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "3 weeks, 2 days",
  "timestamp": 1698701002,
  "title": "Invert Binary Tree",
  "title_slug": "invert-binary-tree",
  "url": "/submissions/detail/1087877829/"
}{
  "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean isSymmetric(TreeNode root) {\n        return isS(root.left,root.right);\n    }\n\n    public boolean isS(TreeNode l, TreeNode r){\n        if (l == null && r == null) return true;\n        if (l==null) return false;\n        if (r == null) return false;\n        if (l.val != r.val) return false;\n        return isS(l.left,r.right) && isS(l.right,r.left);\n    }\n}",
  "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1087874307,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "40.1 MB",
  "runtime": "0 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "3 weeks, 2 days",
  "timestamp": 1698700548,
  "title": "Symmetric Tree",
  "title_slug": "symmetric-tree",
  "url": "/submissions/detail/1087874307/"
}{
  "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int countNodes(TreeNode root) {\n        return root==null?0:1 + countNodes(root.left) + countNodes(root.right);\n    }\n}",
  "compare_result": "111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1087869562,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "45.8 MB",
  "runtime": "0 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "3 weeks, 3 days",
  "timestamp": 1698699925,
  "title": "Count Complete Tree Nodes",
  "title_slug": "count-complete-tree-nodes",
  "url": "/submissions/detail/1087869562/"
}{
  "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int countNodes(TreeNode root) {\n        if (root == null) return 0;\n        return 1 + countNodes(root.left) + countNodes(root.right);\n        \n    }\n}",
  "compare_result": "111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1087869174,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "45.4 MB",
  "runtime": "0 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "3 weeks, 3 days",
  "timestamp": 1698699877,
  "title": "Count Complete Tree Nodes",
  "title_slug": "count-complete-tree-nodes",
  "url": "/submissions/detail/1087869174/"
}{
  "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<Double> averageOfLevels(TreeNode root) {\n        List<TreeNode> layer = new ArrayList<>();\n        layer.add(root);\n        List<Double> re = new ArrayList<>();\n        while (layer.size()!=0){\n            re.add(avgList(layer));\n            layer = getChildList(layer);\n        }\n        return re;\n    }\n\n    public double avgList(List<TreeNode> layer){\n        double re = 0;\n        int count = 0;\n        for (TreeNode i: layer){\n            if (i!=null){\n                re = re + i.val;\n                count++;\n            }\n        }\n        re = (double) re / (double) count;\n        return re;\n    }\n    public List<TreeNode> getChildList(List<TreeNode> layer){\n        List<TreeNode> re= new ArrayList<>();\n        for (TreeNode i: layer){\n            if (i.left != null) re.add(i.left);\n            if (i.right != null) re.add(i.right);\n        }\n        return re;\n    }\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1087867840,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "44.5 MB",
  "runtime": "1 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "3 weeks, 3 days",
  "timestamp": 1698699700,
  "title": "Average of Levels in Binary Tree",
  "title_slug": "average-of-levels-in-binary-tree",
  "url": "/submissions/detail/1087867840/"
}{
  "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<Double> averageOfLevels(TreeNode root) {\n        List<TreeNode> layer = new ArrayList<>();\n        layer.add(root);\n        List<Double> re = new ArrayList<>();\n        while (layer.size()!=0){\n            re.add(avgList(layer));\n            layer = getChildList(layer);\n        }\n        return re;\n    }\n\n    public double avgList(List<TreeNode> layer){\n        double re = 0;\n        int count = 0;\n        for (TreeNode i: layer){\n            if (i!=null){\n                re = re + i.val;\n                count++;\n            }\n        }\n        re = (double) re / (double) count;\n        return re;\n    }\n    public List<TreeNode> getChildList(List<TreeNode> layer){\n        List<TreeNode> re= new ArrayList<>();\n        for (TreeNode i: layer){\n            if (i.left != null) re.add(i.left);\n            if (i.right != null) re.add(i.right);\n        }\n        return re;\n    }\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1087867142,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "44.5 MB",
  "runtime": "1 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "3 weeks, 3 days",
  "timestamp": 1698699611,
  "title": "Average of Levels in Binary Tree",
  "title_slug": "average-of-levels-in-binary-tree",
  "url": "/submissions/detail/1087867142/"
}{
  "code": "class Solution {\n    public boolean isValid(String s) {\n        Stack<Character> open = new Stack<>();\n        \n        for (char i:s.toCharArray()){\n            if (i=='(' || i == '[' || i == '{') open.add(i);\n            if ((i==')' || i == ']' || i == '}') && (open.size() == 0)) return false;\n            if (i == ')' && open.peek()!='(') return false;\n            if (i == ']' && open.peek()!='[') return false;\n            if (i == '}' && open.peek()!='{') return false;\n            if (i==')' || i == ']' || i == '}') open.pop();\n        }\n        if (open.size() == 0) return true;\n        return false;\n    }\n}",
  "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1087766779,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "40.6 MB",
  "runtime": "2 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "3 weeks, 3 days",
  "timestamp": 1698689692,
  "title": "Valid Parentheses",
  "title_slug": "valid-parentheses",
  "url": "/submissions/detail/1087766779/"
}{
  "code": "class Solution {\n    public boolean isValid(String s) {\n        Stack<Character> open = new Stack<>();\n        Stack<Character> close = new Stack<>();\n        \n        for (char i:s.toCharArray()){\n            if (i=='(' || i == '[' || i == '{') open.add(i);\n            if ((i==')' || i == ']' || i == '}') && (open.size() == 0)) return false;\n            if (i == ')' && open.peek()!='(') return false;\n            if (i == ']' && open.peek()!='[') return false;\n            if (i == '}' && open.peek()!='{') return false;\n            if (i==')' || i == ']' || i == '}') open.pop();\n        }\n        if (open.size() == 0) return true;\n        return false;\n    }\n}",
  "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1087766603,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "40.5 MB",
  "runtime": "2 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "3 weeks, 3 days",
  "timestamp": 1698689680,
  "title": "Valid Parentheses",
  "title_slug": "valid-parentheses",
  "url": "/submissions/detail/1087766603/"
}{
  "code": "class Solution {\n    public boolean isValid(String s) {\n        Stack<Character> open = new Stack<>();\n        Stack<Character> close = new Stack<>();\n        \n        for (char i:s.toCharArray()){\n            if (i=='(' || i == '[' || i == '{') open.add(i);\n            if (i == ')' && open.peek()!='(') return false;\n            if (i == ']' && open.peek()!='[') return false;\n            if (i == '}' && open.peek()!='{') return false;\n            if (i==')' || i == ']' || i == '}') open.pop();\n        }\n        if (open.size() == 0) return true;\n        return false;\n    }\n}",
  "compare_result": "11111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
  "flag_type": 1,
  "has_notes": false,
  "id": 1087765175,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 15,
  "status_display": "Runtime Error",
  "time": "3 weeks, 3 days",
  "timestamp": 1698689579,
  "title": "Valid Parentheses",
  "title_slug": "valid-parentheses",
  "url": "/submissions/detail/1087765175/"
}{
  "code": "class Solution {\n    public long minIncrementOperations(int[] nums, int k) {\n        int ind = 0;\n        int n = nums.length;\n        long re = 0;\n        while (ind+2<n){\n            long max = nums[ind];\n            int pos = ind;\n            for (int i = 1; i<=2;i++){\n                if (max<=nums[ind+i]){\n                    max= nums[ind+i];\n                    pos = ind + i ;\n                }\n            }\n            System.out.println(max);\n            if (max<k){\n                re = re + k - nums[pos];\n                nums[pos] = k;\n            }\n            ind++;\n        }\n        return re;\n    }\n}",
  "compare_result": "111111111111111111111111110111111100000101111111111111111111110101011001111111111101110111111101111010111101111111001101010001000011111101000100101000001100001000010100100100100011101100001001110000101101100010100110010010000110100001000000000010001000010000000101000000000000001101110100000000000000001000000100001000000000010010000001001010011011100010101010001000010011000000000000111000000010000101001000010001000011001011010011000000001001000100001000001000100000000000100000000000000000000010000000000000000000000000000000000000000000001000010000111001111111100000",
  "flag_type": 1,
  "has_notes": false,
  "id": 1086524199,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "3 weeks, 4 days",
  "timestamp": 1698550697,
  "title": "Minimum Increment Operations to Make Array Beautiful",
  "title_slug": "minimum-increment-operations-to-make-array-beautiful",
  "url": "/submissions/detail/1086524199/"
}{
  "code": "class Solution {\n    public int findKOr(int[] nums, int k) {\n        int pow2 = 1;\n        if (k == nums.length) {\n            int re = nums[0];\n            for (int i :nums) re = re & i;\n            return re;\n        }\n        if (k == 1){\n            int re = nums[0];\n            for (int i :nums) re = re | i;\n            return re;\n        }\n        \n        int re = 0;\n        int exit = 0;\n        int n = nums.length;\n        while (exit<n){\n            int count = 0;\n            exit = 0;\n            for (int i = 0; i<nums.length; i++){\n                // System.out.print(nums[i] +\" \");\n                if (nums[i] == 0 ) exit++;\n\n                if (nums[i] != 0 && nums[i] %2 == 1 ){\n                    count++;\n                }\n                nums[i] = nums[i] / 2;\n                // if (count >= k) break;\n            }\n            // System.out.println();\n            // System.out.println(count);\n            if (count >= k) re = re+ pow2;\n            pow2 = pow2 * 2;\n        }\n        \n        return re;\n        \n    }\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1086516435,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "43.4 MB",
  "runtime": "3 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "3 weeks, 4 days",
  "timestamp": 1698550187,
  "title": "Find the K-or of an Array",
  "title_slug": "find-the-k-or-of-an-array",
  "url": "/submissions/detail/1086516435/"
}{
  "code": "class Solution {\n    public int findKOr(int[] nums, int k) {\n        int pow2 = 1;\n        if (k == nums.length) {\n            int re = nums[0];\n            for (int i :nums) re = re & i;\n            return re;\n        }\n        if (k == 1){\n            int re = nums[0];\n            for (int i :nums) re = re | i;\n            return re;\n        }\n        \n        int re = 0;\n        int exit = 0;\n        int n = nums.length;\n        while (exit<n){\n            int count = 0;\n            for (int i = 0; i<nums.length; i++){\n                // System.out.print(nums[i] +\" \");\n                if (nums[i] == 0 ) exit++;\n\n                if (nums[i] != 0 && nums[i] %2 == 1 ){\n                    count++;\n                }\n                nums[i] = nums[i] / 2;\n                // if (count >= k) break;\n            }\n            // System.out.println();\n            // System.out.println(count);\n            if (count >= k) re = re+ pow2;\n            pow2 = pow2 * 2;\n        }\n        \n        return re;\n        \n    }\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111101111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110111111110111101111111111111111111111111111111111111111101111111111111111111111111111111110111111111110111111111111111111111111111111111111111111111111111111111111111111111111110111111111111111111111111111111111111111111111111111111111111111011110111111111111111111011111111111111111111111111111110111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110111111111111111111111111111111111111111111111111111111111111111010111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1086515061,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "3 weeks, 4 days",
  "timestamp": 1698550098,
  "title": "Find the K-or of an Array",
  "title_slug": "find-the-k-or-of-an-array",
  "url": "/submissions/detail/1086515061/"
}{
  "code": "class Solution {\n    public int findKOr(int[] nums, int k) {\n        int pow2 = 1;\n        if (k == nums.length) {\n            int re = nums[0];\n            for (int i :nums) re = re & i;\n            return re;\n        }\n        if (k == 1){\n            int re = nums[0];\n            for (int i :nums) re = re | i;\n            return re;\n        }\n        \n        int re = 0;\n        int exit = 0;\n        int n = nums.length;\n        while (exit<n){\n            int count = 0;\n            for (int i = 0; i<nums.length; i++){\n                if (nums[i] == 0 ) exit++;\n\n                if (nums[i] != 0 && nums[i] %2 == 1 ){\n                    count++;\n                }\n                nums[i] = nums[i] / 2;\n                if (count >= k) break;\n            }\n            // System.out.println(count);\n            if (count >= k) re = re+ pow2;\n            pow2 = pow2 * 2;\n        }\n        \n        return re;\n        \n    }\n}",
  "compare_result": "111111111111111111111111111111111111111101111010010101111010111111111111111111011111010111111101100011110111111101110010111111111111101111111010011111011110100010111111111110011101011101000101110111111111111111110110111011111011111001111110001000111111010111111111111111110001111110101110111111100111001111111001111111010111110110101100100000101111111001111000111111011110110110111011110110101101111110110111110101111101101111001111111011111011111000001110011101110111111011110101111010101001111011111101111010101101110111111111010110111101011000010111011010000010010000000000110100100111000100110100001000010001110111000100001101010011001111010101001000011110100001000010000001001010000101000010010010011100101010001110000010101010010100011101000000001011001000011001101100111011010000001111010100101001110101101010101000000000010011000001110010101101101100100100010010111000001101000101101011001101110010010000100010100010100000010101100111101100110",
  "flag_type": 1,
  "has_notes": false,
  "id": 1086512878,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "3 weeks, 4 days",
  "timestamp": 1698549962,
  "title": "Find the K-or of an Array",
  "title_slug": "find-the-k-or-of-an-array",
  "url": "/submissions/detail/1086512878/"
}{
  "code": "class Solution {\n    public int findKOr(int[] nums, int k) {\n        int pow2 = 1;\n        if (k == nums.length) {\n            int re = nums[0];\n            for (int i :nums) re = re & i;\n            return re;\n        }\n        if (k == 1){\n            int re = nums[0];\n            for (int i :nums) re = re | i;\n            return re;\n        }\n        \n        int re = 0;\n        int exit = 0;\n        int n = nums.length;\n        while (exit<n){\n            int count = 0;\n            for (int i = 0; i<nums.length; i++){\n                if (nums[i] == 0 ) exit++;\n\n                if (nums[i] %2 == 1){\n                    count++;\n                }\n                nums[i] = nums[i] / 2;\n                if (count >= k) break;\n            }\n            System.out.println(count);\n            if (count >= k) re = re+ pow2;\n            pow2 = pow2 * 2;\n        }\n        \n        return re;\n        \n    }\n}",
  "compare_result": "111111111111111111111111111111111111111101111010010101111010111111111111111111011111010111111101100011110111111101110010111111111111101111111010011111011110100010111111111110011101011101000101110111111111111111110110111011111011111001111110001000111111010111111111111111110001111110101110111111100111001111111001111111010111110110101100100000101111111001111000111111011110110110111011110110101101111110110111110101111101101111001111111011111011111000001110011101110111111011110101111010101001111011111101111010101101110111111111010110111101011000010111011010000010010000000000110100100111000100110100001000010001110111000100001101010011001111010101001000011110100001000010000001001010000101000010010010011100101010001110000010101010010100011101000000001011001000011001101100111011010000001111010100101001110101101010101000000000010011000001110010101101101100100100010010111000001101000101101011001101110010010000100010100010100000010101100111101100110",
  "flag_type": 1,
  "has_notes": false,
  "id": 1086509421,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "3 weeks, 4 days",
  "timestamp": 1698549750,
  "title": "Find the K-or of an Array",
  "title_slug": "find-the-k-or-of-an-array",
  "url": "/submissions/detail/1086509421/"
}{
  "code": "class Solution {\n    public int findKOr(int[] nums, int k) {\n        int pow2 = 1;\n        if (k == nums.length) {\n            int re = nums[0];\n            for (int i :nums) re = re & i;\n            return re;\n        }\n        if (k == 1){\n            int re = nums[0];\n            for (int i :nums) re = re | i;\n            return re;\n        }\n        \n        int re = 0;\n        int exit = 0;\n        int n = nums.length;\n        while (exit<n){\n            int count = 0;\n            for (int i = 0; i<nums.length; i++){\n                if (nums[i] %2 == 1){\n                    count++;\n                }\n                nums[i] = nums[i] /2;\n                if (nums[i] == 0 ) exit++;\n                if (count >= k) break;\n            } \n            if (count >= k) re = re+ pow2;\n            pow2 = pow2 * 2;\n        }\n        \n        return re;\n        \n    }\n}",
  "compare_result": "111111111111111111111111111111111111111111111010010111111010111111111111111111011111010111111101100011110111111101110010111111111111101111111010001111011110100010111111111110011101011101001101100111111111111111111110111011111011111001111110101000111111110111111111111111110001111110101110111111100101001111111011111111010111110110101100100000101011111101111010111111011111110110111011110110101101111110110111110101111101101111001111111011111111111010001110011101110111111011110101111010101011111011111101111010111101110111011111010110111101011000010111011010000010010000000000110100100111000100110100001000010001110111000100001111010011001111010101001000011110100001000010000001001010000101000010010010011100101010001110000011101010010100011101000000001011001000011001101100111011010000001111010100101001110101101010101000000000010011000001110010101101101100100100010010111000001101000101101011001101110010010000100010100010100000010101100111101100110",
  "flag_type": 1,
  "has_notes": false,
  "id": 1086505200,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "3 weeks, 4 days",
  "timestamp": 1698549503,
  "title": "Find the K-or of an Array",
  "title_slug": "find-the-k-or-of-an-array",
  "url": "/submissions/detail/1086505200/"
}{
  "code": "class Solution {\n    public long minIncrementOperations(int[] nums, int k) {\n        int ind = 0;\n        int n = nums.length;\n        long re = 0;\n        while (ind+2<n){\n            long max = nums[ind];\n            int pos = ind;\n            for (int i = 1; i<=2;i++){\n                if (max<=nums[ind+i]){\n                    max= nums[ind+i];\n                    pos = ind + i ;\n                }\n            }\n            // System.out.println(max);\n            if (max<k){\n                re = re + k - nums[pos];\n                nums[pos] = k;\n            }\n            ind++;\n        }\n        return re;\n    }\n}",
  "compare_result": "111111111111111111111111110111111100000101111111111111111111110101011001111111111101110111111101111010111101111111001101010001000011111101000100101000001100001000010100100100100011101100001001110000101101100010100110010010000110100001000000000010001000010000000101000000000000001101110100000000000000001000000100001000000000010010000001001010011011100010101010001000010011000000000000111000000010000101001000010001000011001011010011000000001001000100001000001000100000000000100000000000000000000010000000000000000000000000000000000000000000001000010000111001111111100000",
  "flag_type": 1,
  "has_notes": false,
  "id": 1086492941,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "3 weeks, 4 days",
  "timestamp": 1698548803,
  "title": "Minimum Increment Operations to Make Array Beautiful",
  "title_slug": "minimum-increment-operations-to-make-array-beautiful",
  "url": "/submissions/detail/1086492941/"
}{
  "code": "class Solution {\n    public long minSum(int[] nums1, int[] nums2) {\n        long count1 = 0;\n        long count2 = 0;\n        long sum1 = 0;\n        long sum2 = 0;\n        for (int i: nums1){\n            sum1 = sum1+i;\n            if (i == 0 ) count1++;\n        }\n        for (int i: nums2){\n            sum2 = sum2+i;\n            if (i == 0 ) count2++;\n        }\n        if (count1 == 0 && count2 == 0 ){\n            if (sum1 == sum2) return sum1;\n            else return -1;\n        }\n        // System.out.println(sum1 + \" \"+ sum2 + \" \"+ count1+ \" \"+ count2);\n        if (sum1 > sum2 && count2 == 0 ) return -1;\n        if (sum1 < sum2 && count1 == 0 ) return -1;\n        if (sum1 + count1 > sum2 && count2 == 0 ) return -1;\n        if (sum1 < sum2 + count2 && count1 == 0 ) return -1;\n        return Long.max(sum1+count1,sum2+count2);\n        \n    }\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1086478614,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "59.1 MB",
  "runtime": "3 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "3 weeks, 4 days",
  "timestamp": 1698548034,
  "title": "Minimum Equal Sum of Two Arrays After Replacing Zeros",
  "title_slug": "minimum-equal-sum-of-two-arrays-after-replacing-zeros",
  "url": "/submissions/detail/1086478614/"
}{
  "code": "class Solution {\n    public long minSum(int[] nums1, int[] nums2) {\n        int count1 = 0;\n        int count2 = 0;\n        int sum1 = 0;\n        int sum2 = 0;\n        for (int i: nums1){\n            sum1 = sum1+i;\n            if (i == 0 ) count1++;\n        }\n        for (int i: nums2){\n            sum2 = sum2+i;\n            if (i == 0 ) count2++;\n        }\n        if (count1 == 0 && count2 == 0 ){\n            if (sum1 == sum2) return sum1;\n            else return -1;\n        }\n        if (sum1 > sum2 && count2 == 0 ) return -1;\n        if (sum1 < sum2 && count1 == 0 ) return -1;\n        if (sum1 + count1 >= sum2 && count2 == 0 ) return -1;\n        if (sum1 <= sum2 + count2 && count1 == 0 ) return -1;\n        return Integer.max(sum1+count1,sum2+count2);\n        \n    }\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000",
  "flag_type": 1,
  "has_notes": false,
  "id": 1086476316,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "3 weeks, 4 days",
  "timestamp": 1698547909,
  "title": "Minimum Equal Sum of Two Arrays After Replacing Zeros",
  "title_slug": "minimum-equal-sum-of-two-arrays-after-replacing-zeros",
  "url": "/submissions/detail/1086476316/"
}{
  "code": "class Solution {\n    public long minSum(int[] nums1, int[] nums2) {\n        int count1 = 0;\n        int count2 = 0;\n        int sum1 = 0;\n        int sum2 = 0;\n        for (int i: nums1){\n            sum1 = sum1+i;\n            if (i == 0 ) count1++;\n        }\n        for (int i: nums2){\n            sum2 = sum2+i;\n            if (i == 0 ) count2++;\n        }\n        if (count1 == 0 && count2 == 0 ){\n            if (sum1 == sum2) return sum1;\n            else return -1;\n        }\n        if (sum1 > sum2 && count2 == 0 ) return -1;\n        if (sum1 < sum2 && count1 == 0 ) return -1;\n        if (sum1 + count1 > sum2 && count2 == 0 ) return -1;\n        if (sum1 < sum2 + count2 && count1 == 0 ) return -1;\n        return Integer.max(sum1+count1,sum2+count2);\n        \n    }\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000",
  "flag_type": 1,
  "has_notes": false,
  "id": 1086475884,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "3 weeks, 4 days",
  "timestamp": 1698547884,
  "title": "Minimum Equal Sum of Two Arrays After Replacing Zeros",
  "title_slug": "minimum-equal-sum-of-two-arrays-after-replacing-zeros",
  "url": "/submissions/detail/1086475884/"
}{
  "code": "class Solution {\n    public long minSum(int[] nums1, int[] nums2) {\n        int count1 = 0;\n        int count2 = 0;\n        int sum1 = 0;\n        int sum2 = 0;\n        for (int i: nums1){\n            sum1 = sum1+i;\n            if (i == 0 ) count1++;\n        }\n        for (int i: nums2){\n            sum2 = sum2+i;\n            if (i == 0 ) count2++;\n        }\n        if (count1 == 0 && count2 == 0 ){\n            if (sum1 == sum2) return sum1;\n            else return -1;\n        }\n        if (sum1 + count1 > sum2 && count2 == 0 ) return -1;\n        if (sum1 < sum2 + count2 && count1 == 0 ) return -1;\n        return Integer.max(sum1+count1,sum2+count2);\n        \n    }\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000",
  "flag_type": 1,
  "has_notes": false,
  "id": 1086475421,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "3 weeks, 4 days",
  "timestamp": 1698547860,
  "title": "Minimum Equal Sum of Two Arrays After Replacing Zeros",
  "title_slug": "minimum-equal-sum-of-two-arrays-after-replacing-zeros",
  "url": "/submissions/detail/1086475421/"
}{
  "code": "class Solution {\n    public int findKOr(int[] nums, int k) {\n        int pow2 = 1;\n        if (k == nums.length) {\n            int re = nums[0];\n            for (int i :nums) re = re & i;\n            return re;\n        }\n        if (k == 1){\n            int re = nums[0];\n            for (int i :nums) re = re | i;\n            return re;\n        }\n        \n        int max = 0;\n        int re = 0;\n        for (int i : nums){\n            if (i>max) max = i;\n        }\n        while (pow2 < max){\n            int count = 0;\n            for (int i = 0; i<nums.length; i++){\n                if ( (pow2 & nums[i]) == pow2 ) count++;\n            } \n            if (count >= k) re = re+ pow2;\n            pow2 = pow2 * 2;\n        }\n        \n        return re;\n        \n    }\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
  "flag_type": 1,
  "has_notes": false,
  "id": 1086466386,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 14,
  "status_display": "Time Limit Exceeded",
  "time": "3 weeks, 4 days",
  "timestamp": 1698547338,
  "title": "Find the K-or of an Array",
  "title_slug": "find-the-k-or-of-an-array",
  "url": "/submissions/detail/1086466386/"
}{
  "code": "class Solution {\n    public int minChanges(String s) {\n        char [] ac = s.toCharArray();\n        int n = s.length();\n        int st = 0;\n        int count = 0;\n        while (st<n){\n            if (ac[st]!=ac[st+1]) count ++;\n            st+=2;\n        }\n        return count;\n        \n    }\n}",
  "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1086107640,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "44.5 MB",
  "runtime": "3 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "3 weeks, 5 days",
  "timestamp": 1698505320,
  "title": "Minimum Number of Changes to Make Binary String Beautiful",
  "title_slug": "minimum-number-of-changes-to-make-binary-string-beautiful",
  "url": "/submissions/detail/1086107640/"
}{
  "code": "class Solution {\n    public int sumCounts(List<Integer> nums) {\n        int n = nums.size();\n        List<Integer> dist = new ArrayList<>();\n        int sum = 0;\n        for (int i = 0 ; i<n;i++){\n\n            for (int j = 0;j<n;j++) {\n                HashSet<Integer> set = new HashSet<>();\n                if (i+j<n){\n                    for (int k =0;k<=i && j+k<n;k++){\n                    set.add(nums.get(j+k));\n                    }    \n                }\n                \n                // System.out.println(j +\" \"+i + \" \" + set.size());\n                sum = sum + set.size()*set.size();\n\n            }\n        }\n        return sum;\n        \n    }\n}",
  "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1086098064,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "44.1 MB",
  "runtime": "105 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "3 weeks, 5 days",
  "timestamp": 1698504898,
  "title": "Subarrays Distinct Element Sum of Squares I",
  "title_slug": "subarrays-distinct-element-sum-of-squares-i",
  "url": "/submissions/detail/1086098064/"
}{
  "code": "class Solution {\n    public boolean isHappy(int n) {\n        HashSet<Integer> set = new HashSet<>();\n        int temp = n;\n        set.add(temp);\n        if (n == 1) return true;\n        while (temp != 1){\n            // System.out.println(temp);\n            int h = happy(temp);\n            if (h == 1) return true;\n            if (set.contains(h)) return false;\n            set.add(h);\n            temp = h;\n        }\n        return true;\n\n        \n    }\n\n    public int happy(int n){\n        int temp = n;\n        int sum = 0;\n        while (temp>0){\n            int d = temp % 10;\n            sum = sum + d*d;\n            temp =temp / 10;\n        }\n        return sum;\n    }\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1085731173,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "40.3 MB",
  "runtime": "1 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "3 weeks, 5 days",
  "timestamp": 1698456367,
  "title": "Happy Number",
  "title_slug": "happy-number",
  "url": "/submissions/detail/1085731173/"
}{
  "code": "class Solution {\n    public String fractionToDecimal(long numerator, long denominator) {\n        String re = \"\";\n\n        if (numerator * denominator < 0) {\n            re = \"-\";\n            \n        }\n        numerator = Math.abs(numerator);\n        denominator = Math.abs(denominator);\n        long dec = numerator / denominator;\n        re = re+dec;\n\n        long remainder = numerator % denominator;\n        if (remainder < 0) remainder = -remainder;\n        List<Long> remains = new ArrayList<>();\n        List<Long> left = new ArrayList<>();\n        HashSet<Long> set = new HashSet<>();\n        set.add(remainder);\n        while (remainder != 0 || !set.contains(remainder)){\n            remains.add(remainder);\n            remainder = remainder * 10;\n            left.add(remainder/denominator);\n            remainder = remainder % denominator;\n            if (set.contains(remainder)) break;\n            set.add(remainder);\n        }\n        // System.out.println(remainder);\n        // for (int i  = 0;i<left.size();i++){\n        //     System.out.println(remains.get(i) + \" \" + left.get(i));\n        // }\n        if (remainder != 0){\n            if (remains.size()>0){\n                re = re+ \".\";\n                for (int i=0;i<remains.size();i++){\n                    if (remains.get(i).equals( remainder ) ){\n                        re = re+ \"(\" + left.get(i); \n                    }else{\n                        re = re+ left.get(i);\n                    }\n                }\n                re= re+\")\";\n            }\n        } else{\n            if (remains.size()>0) {\n                re = re+ \".\";\n                for (int i = 0;i<left.size();i++){\n                    re = re + left.get(i);\n                }\n            }\n        }\n        \n        return re;\n    }\n}",
  "compare_result": "111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1085557251,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "41.7 MB",
  "runtime": "13 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "3 weeks, 6 days",
  "timestamp": 1698430554,
  "title": "Fraction to Recurring Decimal",
  "title_slug": "fraction-to-recurring-decimal",
  "url": "/submissions/detail/1085557251/"
}{
  "code": "class Solution {\n    public String fractionToDecimal(int numerator, int denominator) {\n        String re = \"\";\n\n        if (numerator * denominator < 0) {\n            re = \"-\";\n            numerator = Math.abs(numerator);\n            denominator = Math.abs(denominator);\n        }\n        int dec = numerator / denominator;\n        re = re+dec;\n\n        int remainder = numerator % denominator;\n        if (remainder < 0) remainder = -remainder;\n        List<Integer> remains = new ArrayList<>();\n        List<Integer> left = new ArrayList<>();\n        HashSet<Integer> set = new HashSet<>();\n        set.add(remainder);\n        while (remainder != 0 || !set.contains(remainder)){\n            remains.add(remainder);\n            remainder = remainder * 10;\n            left.add(remainder/denominator);\n            remainder = remainder % denominator;\n            if (set.contains(remainder)) break;\n            set.add(remainder);\n        }\n        // System.out.println(remainder);\n        // for (int i  = 0;i<left.size();i++){\n        //     System.out.println(remains.get(i) + \" \" + left.get(i));\n        // }\n        if (remainder != 0){\n            if (remains.size()>0){\n                re = re+ \".\";\n                for (int i=0;i<remains.size();i++){\n                    if (remains.get(i).equals( remainder ) ){\n                        re = re+ \"(\" + left.get(i); \n                    }else{\n                        re = re+ left.get(i);\n                    }\n                }\n                re= re+\")\";\n            }\n        } else{\n            if (remains.size()>0) {\n                re = re+ \".\";\n                for (int i = 0;i<left.size();i++){\n                    re = re + left.get(i);\n                }\n            }\n        }\n        \n        return re;\n    }\n}",
  "compare_result": "111111111111111111111111111110101000001",
  "flag_type": 1,
  "has_notes": false,
  "id": 1085555881,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "3 weeks, 6 days",
  "timestamp": 1698430434,
  "title": "Fraction to Recurring Decimal",
  "title_slug": "fraction-to-recurring-decimal",
  "url": "/submissions/detail/1085555881/"
}{
  "code": "class Solution {\n    public String fractionToDecimal(int numerator, int denominator) {\n        \n        int dec = numerator / denominator;\n        String re = \"\";\n        re = \"\"+dec;\n\n        int remainder = numerator % denominator;\n        if (remainder < 0) remainder = -remainder;\n        List<Integer> remains = new ArrayList<>();\n        List<Integer> left = new ArrayList<>();\n        HashSet<Integer> set = new HashSet<>();\n        set.add(remainder);\n        while (remainder != 0 || !set.contains(remainder)){\n            remains.add(remainder);\n            remainder = remainder * 10;\n            left.add(remainder/denominator);\n            remainder = remainder % denominator;\n            if (set.contains(remainder)) break;\n            set.add(remainder);\n        }\n        // System.out.println(remainder);\n        // for (int i  = 0;i<left.size();i++){\n        //     System.out.println(remains.get(i) + \" \" + left.get(i));\n        // }\n        if (remainder != 0){\n            if (remains.size()>0){\n                re = re+ \".\";\n                for (int i=0;i<remains.size();i++){\n                    if (remains.get(i).equals( remainder ) ){\n                        re = re+ \"(\" + left.get(i); \n                    }else{\n                        re = re+ left.get(i);\n                    }\n                }\n                re= re+\")\";\n            }\n        } else{\n            if (remains.size()>0) {\n                re = re+ \".\";\n                for (int i = 0;i<left.size();i++){\n                    re = re + left.get(i);\n                }\n            }\n        }\n        \n        return re;\n    }\n}",
  "compare_result": "111111111111111111111111110110111100001",
  "flag_type": 1,
  "has_notes": false,
  "id": 1085553836,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "3 weeks, 6 days",
  "timestamp": 1698430260,
  "title": "Fraction to Recurring Decimal",
  "title_slug": "fraction-to-recurring-decimal",
  "url": "/submissions/detail/1085553836/"
}{
  "code": "class Solution {\n    public String fractionToDecimal(int numerator, int denominator) {\n        int dec = numerator / denominator;\n        int remainder = numerator % denominator;\n        List<Integer> remains = new ArrayList<>();\n        List<Integer> left = new ArrayList<>();\n        HashSet<Integer> set = new HashSet<>();\n        set.add(remainder);\n        while (remainder != 0 || !set.contains(remainder)){\n            remains.add(remainder);\n            remainder = remainder * 10;\n            left.add(remainder/denominator);\n            remainder = remainder % denominator;\n            if (set.contains(remainder)) break;\n            set.add(remainder);\n        }\n        System.out.println(remainder);\n        for (int i  = 0;i<left.size();i++){\n            System.out.println(remains.get(i) + \" \" + left.get(i));\n        }\n        String re = \"\"+dec;\n        if (remainder != 0){\n            if (remains.size()>0){\n                re = re+ \".\";\n                for (int i=0;i<remains.size();i++){\n                    if (remains.get(i).equals( remainder ) ){\n                        re = re+ \"(\" + left.get(i); \n                    }else{\n                        re = re+ left.get(i);\n                    }\n                }\n                re= re+\")\";\n            }\n        } else{\n            if (remains.size()>0) {\n                re = re+ \".\";\n                for (int i = 0;i<left.size();i++){\n                    re = re + left.get(i);\n                }\n            }\n        }\n        \n        return re;\n    }\n}",
  "compare_result": "111111111111111111111111010110111101101",
  "flag_type": 1,
  "has_notes": false,
  "id": 1085552188,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "3 weeks, 6 days",
  "timestamp": 1698430116,
  "title": "Fraction to Recurring Decimal",
  "title_slug": "fraction-to-recurring-decimal",
  "url": "/submissions/detail/1085552188/"
}{
  "code": "class Solution {\n    public int[][] intervalIntersection(int[][] firstList, int[][] secondList) {\n        int n = firstList.length;\n        int m = secondList.length;\n        List<Integer> a = new ArrayList<>();\n        List<Integer> b = new ArrayList<>();\n        int c1 = 0;\n        int c2 = 0;\n        while (c1<n && c2<m){\n            if ( firstList[c1][0] <= secondList[c2][0] && secondList[c2][1] <= firstList[c1][1]) {\n                a.add(secondList[c2][0]);\n                b.add(secondList[c2][1]);\n                // c2++;\n            } else if ( secondList[c2][0] <= firstList[c1][0] && firstList[c1][1] <= secondList[c2][1] ){\n                a.add(firstList[c1][0]);\n                b.add(firstList[c1][1]);\n                // c1++;\n            } else if ( firstList[c1][0] <= secondList[c2][0] && secondList[c2][0] <= firstList[c1][1]) {\n                a.add(secondList[c2][0]);\n                b.add(firstList[c1][1]);\n                // c2++;\n            } else if ( secondList[c2][0] <= firstList[c1][0] && firstList[c1][0] <= secondList[c2][1] ){\n                a.add(firstList[c1][0]);\n                b.add(secondList[c2][1]);\n                // c1++;\n            }\n            \n            if (firstList[c1][1]<secondList[c2][1]){\n                c1++;\n            }\n            else{\n                c2++;\n            }\n                \n        }\n        int [][] re = new int[a.size()][2];\n        for (int i = 0;i<a.size();i++){\n            re[i][0] = a.get(i);\n            re[i][1] = b.get(i);\n        }\n        return re;\n        \n    }\n}",
  "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1085524237,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "44.5 MB",
  "runtime": "6 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "3 weeks, 6 days",
  "timestamp": 1698427769,
  "title": "Interval List Intersections",
  "title_slug": "interval-list-intersections",
  "url": "/submissions/detail/1085524237/"
}{
  "code": "class Solution {\n    public void setZeroes(int[][] matrix) {\n        int n = matrix.length;\n        int m = matrix[0].length;\n        boolean top = false;\n        boolean left = false;\n        for (int i = 0;i<n;i++){\n            for (int j = 0 ;j<m;j++){\n                if (matrix[i][j] == 0){\n                    if (i == 0) top = true;\n                    if (j == 0) left = true;\n                    matrix[i][0] = 0;\n                    matrix[0][j] = 0;\n                }\n            }\n        }\n        for (int i = 1;i<n;i++){\n            if (matrix[i][0] == 0)\n                for (int j = 0;j<m;j++) {\n                    matrix[i][j] = 0;\n                }\n        }\n        for (int i = 1;i<m;i++){\n            if (matrix[0][i] == 0)\n                for (int j = 0;j<n;j++) {\n                    matrix[j][i] = 0;\n                }\n        }\n        if (top){\n            // System.out.println(\"t\" + \" \"+m);\n            for (int i = 0;i<m;i++) matrix[0][i] = 0;\n        }\n        if (left){\n            // System.out.println(\"l\" );\n            for (int i = 0; i<n;i++) matrix[i][0] = 0;\n        }\n    }\n}",
  "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1085000221,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "44.9 MB",
  "runtime": "1 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "3 weeks, 6 days",
  "timestamp": 1698368279,
  "title": "Set Matrix Zeroes",
  "title_slug": "set-matrix-zeroes",
  "url": "/submissions/detail/1085000221/"
}{
  "code": "class Solution {\n    public void setZeroes(int[][] matrix) {\n        int n = matrix.length;\n        int m = matrix[0].length;\n        boolean top = false;\n        boolean left = false;\n        for (int i = 0;i<n;i++){\n            for (int j = 0 ;j<m;j++){\n                if (matrix[i][j] == 0){\n                    if (i == 0) left = true;\n                    if (j == 0) top = true;\n                    matrix[i][0] = 0;\n                    matrix[0][j] = 0;\n                }\n            }\n        }\n        for (int i = 1;i<n;i++){\n            if (matrix[i][0] == 0)\n                for (int j = 0;j<m;j++) {\n                    matrix[i][j] = 0;\n                }\n        }\n        for (int i = 1;i<m;i++){\n            if (matrix[0][i] == 0)\n                for (int j = 0;j<n;j++) {\n                    matrix[j][i] = 0;\n                }\n        }\n        if (top){\n            for (int i = 0;i<m;i++) matrix[0][i] = 0;\n        }\n        if (left){\n            for (int i = 0; i<n;i++) matrix[i][0] = 0;\n        }\n    }\n}",
  "compare_result": "1111111100001111111010100111110000001000010011100000100011010010100111001000110101011111001010010110101101001010011000111001011101111111111111011111111010100100100111111101111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1084998746,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "3 weeks, 6 days",
  "timestamp": 1698368039,
  "title": "Set Matrix Zeroes",
  "title_slug": "set-matrix-zeroes",
  "url": "/submissions/detail/1084998746/"
}{
  "code": "class Solution {\n    public int fib(int n) {\n        if (n ==0 ) return 0;\n        if (n == 1) return 1;\n        if (n == 2) return 1;\n        int count = 2;\n        int a = 1;\n        int b = 1;\n        int c = 0;\n        while (count <n){\n            c = a+ b;\n            a= b;\n            b =c; \n            count ++;\n        }\n        return c;\n    }\n}",
  "compare_result": "1111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1084979166,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "38.9 MB",
  "runtime": "0 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "3 weeks, 6 days",
  "timestamp": 1698364829,
  "title": "Fibonacci Number",
  "title_slug": "fibonacci-number",
  "url": "/submissions/detail/1084979166/"
}{
  "code": "class Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n\t\tDeque<Integer> dNum = new ArrayDeque<Integer>();\n\t\tDeque<Integer> dInd = new ArrayDeque<Integer>();\n\t\tint n = nums.length;\n\t\tdNum.addLast(nums[0]);\n\t\tdInd.addLast(0);\n\t\tList<Integer> reL = new ArrayList<>();\n\n\t\tint count = 1;\n\t\tif (count >= k)\n\t\t\t\treL.add(dNum.getFirst());\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tint lowBound = i - (k - 1);\n\t\t\twhile (!dInd.isEmpty() && dInd.peekFirst() < lowBound) {\n\t\t\t\tdInd.removeFirst();\n\t\t\t\tdNum.removeFirst();\n\t\t\t}\n\t\t\tif (dNum.isEmpty()){\n\t\t\t\tdNum.addLast(nums[i]);\n\t\t\t\tdInd.addLast(i);\n\t\t\t}\n\t\t\telse {\n\t\t\t\twhile (!dNum.isEmpty() && dNum.getLast()<=nums[i]) {\n\t\t\t\t\tdNum.removeLast();\n\t\t\t\t\tdInd.removeLast();\n\t\t\t}\n\t\t\tdNum.addLast(nums[i]);\n\t\t\tdInd.addLast(i);\n\t\t\t}\n\t\t\t\n\t\t\tcount++;\n\t\t\tif (count >= k)\n\t\t\t\treL.add(dNum.getFirst());\n\t\t}\n\t\tint[] re = new int[reL.size()];\n\t\tfor (int i = 0; i < reL.size(); i++) {\n\t\t\tre[i] = reL.get(i);\n\t\t}\n\t\treturn re;\n\t}\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1084946940,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "58.4 MB",
  "runtime": "48 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "3 weeks, 6 days",
  "timestamp": 1698359502,
  "title": "Sliding Window Maximum",
  "title_slug": "sliding-window-maximum",
  "url": "/submissions/detail/1084946940/"
}{
  "code": "class Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n\t\tDeque<Integer> dNum = new ArrayDeque<Integer>();\n\t\tDeque<Integer> dInd = new ArrayDeque<Integer>();\n\t\tint n = nums.length;\n\t\tdNum.addLast(nums[0]);\n\t\tdInd.addLast(0);\n\t\tList<Integer> reL = new ArrayList<>();\n\n\t\tint count = 1;\n\t\tif (count >= k)\n\t\t\t\treL.add(dNum.getFirst());\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tint lowBound = i - (k - 1);\n\t\t\twhile (!dInd.isEmpty() && dInd.peekFirst() < lowBound) {\n\t\t\t\tdInd.removeFirst();\n\t\t\t\tdNum.removeFirst();\n\t\t\t}\n\t\t\tif (dNum.isEmpty()){\n\t\t\t\tdNum.addFirst(nums[i]);\n\t\t\t\tdInd.addFirst(i);\n\t\t\t} else if (nums[i] >= dNum.getFirst()) {\n\t\t\t\tdNum.addFirst(nums[i]);\n\t\t\t\tdInd.addFirst(i);\n\t\t\t} else {\n\t\t\t\tdNum.addLast(nums[i]);\n\t\t\t\tdInd.addLast(i);\n\t\t\t}\n\t\t\tcount++;\n\t\t\tif (count >= k)\n\t\t\t\treL.add(dNum.getFirst());\n\t\t}\n\t\tint[] re = new int[reL.size()];\n\t\tfor (int i = 0; i < reL.size(); i++) {\n\t\t\tre[i] = reL.get(i);\n\t\t}\n\t\treturn re;\n\t}\n}",
  "compare_result": "111111111101000010011000001101100010010101000111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1084922241,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "3 weeks, 6 days",
  "timestamp": 1698355946,
  "title": "Sliding Window Maximum",
  "title_slug": "sliding-window-maximum",
  "url": "/submissions/detail/1084922241/"
}{
  "code": "class Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n\t\tDeque<Integer> dNum = new ArrayDeque<Integer>();\n\t\tDeque<Integer> dInd = new ArrayDeque<Integer>();\n\t\tint n = nums.length;\n\t\tdNum.addLast(nums[0]);\n\t\tdInd.addLast(0);\n\t\tList<Integer> reL = new ArrayList<>();\n\n\t\tint count = 1;\n\t\tif (count >= k)\n\t\t\t\treL.add(dNum.getFirst());\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tint lowBound = i - (k - 1);\n\t\t\twhile (!dInd.isEmpty() && dInd.peekFirst() < lowBound) {\n\t\t\t\tdInd.removeFirst();\n\t\t\t\tdNum.removeFirst();\n\t\t\t}\n\t\t\tif (nums[i] >= dNum.getFirst()) {\n\t\t\t\tdNum.addFirst(nums[i]);\n\t\t\t\tdInd.addFirst(i);\n\t\t\t} else {\n\t\t\t\tdNum.addLast(nums[i]);\n\t\t\t\tdInd.addLast(i);\n\t\t\t}\n\t\t\tcount++;\n\t\t\tif (count >= k)\n\t\t\t\treL.add(dNum.getFirst());\n\t\t}\n\t\tint[] re = new int[reL.size()];\n\t\tfor (int i = 0; i < reL.size(); i++) {\n\t\t\tre[i] = reL.get(i);\n\t\t}\n\t\treturn re;\n\t}\n}",
  "compare_result": "110000000000000000000000000000000000000000000000000",
  "flag_type": 1,
  "has_notes": false,
  "id": 1084921574,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 15,
  "status_display": "Runtime Error",
  "time": "3 weeks, 6 days",
  "timestamp": 1698355852,
  "title": "Sliding Window Maximum",
  "title_slug": "sliding-window-maximum",
  "url": "/submissions/detail/1084921574/"
}{
  "code": "class Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n\t\tDeque<Integer> dNum = new ArrayDeque<Integer>();\n\t\tDeque<Integer> dInd = new ArrayDeque<Integer>();\n\t\tint n = nums.length;\n\t\tdNum.addLast(nums[0]);\n\t\tdInd.addLast(0);\n\t\tList<Integer> reL = new ArrayList<>();\n\n\t\tint count = 1;\n\t\tif (count >= k)\n\t\t\t\treL.add(dNum.getFirst());\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tint lowBound = i - (k - 1);\n\t\t\twhile (dInd.peekFirst() < lowBound) {\n\t\t\t\tdInd.removeFirst();\n\t\t\t\tdNum.removeFirst();\n\t\t\t}\n\t\t\tif (nums[i] >= dNum.getFirst()) {\n\t\t\t\tdNum.addFirst(nums[i]);\n\t\t\t\tdInd.addFirst(i);\n\t\t\t} else {\n\t\t\t\tdNum.addLast(nums[i]);\n\t\t\t\tdInd.addLast(i);\n\t\t\t}\n\t\t\tcount++;\n\t\t\tif (count >= k)\n\t\t\t\treL.add(dNum.getFirst());\n\t\t}\n\t\tint[] re = new int[reL.size()];\n\t\tfor (int i = 0; i < reL.size(); i++) {\n\t\t\tre[i] = reL.get(i);\n\t\t}\n\t\treturn re;\n\t}\n}",
  "compare_result": "110000000000000000000000000000000000000000000000000",
  "flag_type": 1,
  "has_notes": false,
  "id": 1084921213,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 15,
  "status_display": "Runtime Error",
  "time": "3 weeks, 6 days",
  "timestamp": 1698355804,
  "title": "Sliding Window Maximum",
  "title_slug": "sliding-window-maximum",
  "url": "/submissions/detail/1084921213/"
}{
  "code": "class Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        ArrayList<List<String>> re = new ArrayList<>();\n        HashMap<String,List<String>> m = new HashMap<>();\n        for (String s: strs){\n            char [] ca = s.toCharArray();\n            Arrays.sort(ca);\n            String k = new String(ca);\n            if (m.containsKey(k)){\n                m.get(k).add(s);\n            } else{\n                m.put(k,new ArrayList<>());\n                m.get(k).add(s);\n            }\n        }\n        for (String s: m.keySet()){\n            ArrayList<String> temp = new ArrayList<>();\n\n            for (String si:m.get(s)){\n                temp.add(si);\n            }\n            re.add(temp);\n        }\n\n        return re;\n        \n    }\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1084798338,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "48.6 MB",
  "runtime": "7 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "4 weeks",
  "timestamp": 1698343457,
  "title": "Group Anagrams",
  "title_slug": "group-anagrams",
  "url": "/submissions/detail/1084798338/"
}{
  "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        HashMap<Integer,Integer> m = new HashMap<>();\n        int [] re = new int [2];\n        for (int i=0;i<nums.length;i++){\n            if (m.containsKey(target-nums[i])){\n                re[0] = i;\n                re[1] = m.get(target-nums[i]);\n            } else{\n                m.put(nums[i],i);\n            }\n        }\n        return re;\n        \n    }\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1084749903,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "43.9 MB",
  "runtime": "4 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "4 weeks",
  "timestamp": 1698339743,
  "title": "Two Sum",
  "title_slug": "two-sum",
  "url": "/submissions/detail/1084749903/"
}{
  "code": "class Solution {\n    public boolean isAnagram(String s, String t) {\n        HashMap<Character,Integer> as = new HashMap<>();\n        for (Character c:s.toCharArray()){\n            as.put(c,as.getOrDefault(c,0)+1);\n        }\n\n        HashMap<Character,Integer> at = new HashMap<>();\n        for (Character c:t.toCharArray()){\n            at.put(c,at.getOrDefault(c,0)+1);\n        }\n\n        for (Character c:as.keySet()){\n            if (!at.containsKey(c)) return false;\n            if (as.get(c)!=at.get(c)) return false;\n        }\n        for (Character c:at.keySet()){\n            if (!as.containsKey(c)) return false;\n            // if (as.get(c)!=at.get(c)) return false;\n        }\n        return true;\n        \n    }\n}",
  "compare_result": "111111111111111111111111111111110111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1084298057,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "4 weeks",
  "timestamp": 1698291395,
  "title": "Valid Anagram",
  "title_slug": "valid-anagram",
  "url": "/submissions/detail/1084298057/"
}{
  "code": "class Solution {\n    public boolean isAnagram(String s, String t) {\n        HashMap<Character,Integer> as = new HashMap<>();\n        for (Character c:s.toCharArray()){\n            as.put(c,as.getOrDefault(c,0)+1);\n        }\n\n        HashMap<Character,Integer> at = new HashMap<>();\n        for (Character c:t.toCharArray()){\n            at.put(c,at.getOrDefault(c,0)+1);\n        }\n\n        for (Character c:as.keySet()){\n            if (!at.containsKey(c)) return false;\n            // if (as.get(c)!=at.get(c)) return false;\n        }\n        for (Character c:at.keySet()){\n            if (!as.containsKey(c)) return false;\n            // if (as.get(c)!=at.get(c)) return false;\n        }\n        return true;\n        \n    }\n}",
  "compare_result": "111111110111101110111110111111101010011111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1084297942,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "4 weeks",
  "timestamp": 1698291384,
  "title": "Valid Anagram",
  "title_slug": "valid-anagram",
  "url": "/submissions/detail/1084297942/"
}{
  "code": "class Solution {\n    public boolean isAnagram(String s, String t) {\n        HashMap<Character,Integer> as = new HashMap<>();\n        for (Character c:s.toCharArray()){\n            as.put(c,as.getOrDefault(c,0)+1);\n        }\n\n        HashMap<Character,Integer> at = new HashMap<>();\n        for (Character c:t.toCharArray()){\n            at.put(c,at.getOrDefault(c,0)+1);\n        }\n\n        for (Character c:as.keySet()){\n            if (!at.containsKey(c)) return false;\n            if (as.get(c)!=at.get(c)) return false;\n        }\n        for (Character c:at.keySet()){\n            if (!as.containsKey(c)) return false;\n            if (as.get(c)!=at.get(c)) return false;\n        }\n        return true;\n        \n    }\n}",
  "compare_result": "111111111111111111111111111111110111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1084297176,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "4 weeks",
  "timestamp": 1698291295,
  "title": "Valid Anagram",
  "title_slug": "valid-anagram",
  "url": "/submissions/detail/1084297176/"
}{
  "code": "class Solution {\n    public boolean wordPattern(String pattern, String s) {\n        HashMap<Character,String> m = new HashMap<>();\n        HashMap<String,Character> m2 = new HashMap<>();\n\n        String[] a = s.split(\"\\\\s+\");\n        char [] c = pattern.toCharArray();\n        int n = pattern.length();\n        if (n!=a.length) return false;\n        for (int i=0;i<n;i++){\n            if (m.containsKey(c[i])){\n                if (!m.get(c[i]).equals(a[i])) return false;\n            } else{\n                m.put(c[i],a[i]);\n            }\n\n            if (m2.containsKey(a[i])){\n                if (!m2.get(a[i]).equals(c[i])) return false;\n            } else{\n                m2.put(a[i],c[i]);\n            }\n        }        \n        return true;\n    }\n}",
  "compare_result": "111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1084295700,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "40.6 MB",
  "runtime": "2 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "4 weeks",
  "timestamp": 1698291127,
  "title": "Word Pattern",
  "title_slug": "word-pattern",
  "url": "/submissions/detail/1084295700/"
}{
  "code": "class Solution {\n    public boolean wordPattern(String pattern, String s) {\n        HashMap<Character,String> m = new HashMap<>();\n        String[] a = s.split(\"\\\\s+\");\n        char [] c = pattern.toCharArray();\n        int n = pattern.length();\n        if (n!=a.length) return false;\n        for (int i=0;i<n;i++){\n            if (m.containsKey(c[i])){\n                if (!m.get(c[i]).equals(a[i])) return false;\n            } else{\n                m.put(c[i],a[i]);\n            }\n        }        \n        return true;\n    }\n}",
  "compare_result": "111011110111110111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1084294936,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "4 weeks",
  "timestamp": 1698291044,
  "title": "Word Pattern",
  "title_slug": "word-pattern",
  "url": "/submissions/detail/1084294936/"
}{
  "code": "class Solution {\n    public boolean isIsomorphic(String s, String t) {\n        if (s.length()!=t.length()) return false;\n        HashMap<Character,Character> m = new HashMap<>();\n        HashMap<Character,Character> m2 = new HashMap<>();\n\n        char[] cs = s.toCharArray();\n        char[] ct = t.toCharArray();\n        int n = s.length();\n        for (int i=0;i<n;i++){\n            if (m.containsKey(cs[i])){\n                if (!m.get(cs[i]).equals(ct[i])) return false;\n            }else{\n                m.put(cs[i],ct[i]);\n            }\n            if (m2.containsKey(ct[i])){\n                if (!m2.get(ct[i]).equals(cs[i])) return false;\n            }else{\n                m2.put(ct[i],cs[i]);\n            }\n\n        }\n        return true;\n    }\n}",
  "compare_result": "1111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1084292758,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "42 MB",
  "runtime": "16 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "4 weeks",
  "timestamp": 1698290786,
  "title": "Isomorphic Strings",
  "title_slug": "isomorphic-strings",
  "url": "/submissions/detail/1084292758/"
}{
  "code": "class Solution {\n    public boolean isIsomorphic(String s, String t) {\n        if (s.length()!=t.length()) return false;\n        HashMap<Character,Character> m = new HashMap<>();\n        char[] cs = s.toCharArray();\n        char[] ct = t.toCharArray();\n        int n = s.length();\n        for (int i=0;i<n;i++){\n            if (m.containsKey(cs[i])){\n                if (!m.get(cs[i]).equals(ct[i])) return false;\n            }else{\n                m.put(cs[i],ct[i]);\n            }\n\n        }\n        return true;\n    }\n}",
  "compare_result": "1111110111101101110111011111110110111111111100",
  "flag_type": 1,
  "has_notes": false,
  "id": 1084291482,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "4 weeks",
  "timestamp": 1698290631,
  "title": "Isomorphic Strings",
  "title_slug": "isomorphic-strings",
  "url": "/submissions/detail/1084291482/"
}{
  "code": "class Solution {\n    public boolean canConstruct(String ransomNote, String magazine) {\n        HashMap<Character,Integer> ra = new HashMap<>();\n        for (Character c:ransomNote.toCharArray()){\n            ra.put(c,ra.getOrDefault(c,0)+1);\n        }\n\n        HashMap<Character,Integer> ma = new HashMap<>();\n        for (Character c:magazine.toCharArray()){\n            ma.put(c,ma.getOrDefault(c,0)+1);\n        }\n\n        for (Character c:ra.keySet()){\n            if (!ma.containsKey(c)) return false;\n            if (ra.get(c)>ma.get(c)) return false;\n        }\n        return true;\n    }\n}",
  "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1084289052,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "43.9 MB",
  "runtime": "14 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "4 weeks",
  "timestamp": 1698290345,
  "title": "Ransom Note",
  "title_slug": "ransom-note",
  "url": "/submissions/detail/1084289052/"
}{
  "code": "class Solution {\n    public void rotate(int[][] matrix) {\n        transpose(matrix);\n        for (int i = 0;i<matrix.length;i++){\n            inv(matrix[i]);\n        }\n        return ;\n    }\n    void inv(int [] a){\n        int s = 0;\n        int e = a.length-1;\n        while (s<e){\n            int temp = a[s];\n            a[s] = a[e];\n            a[e] = temp;\n            s++;\n            e--;\n        }\n    }\n\n    void transpose(int [][] a){\n        int n = a.length;\n        int m = a[0].length;\n        for (int i = 0; i<n;i++){\n            for (int j =i+1;j<m;j++){\n                int temp = a[i][j];\n                a[i][j] = a[j][i];\n                a[j][i] = temp;\n            }\n        }\n    }\n}",
  "compare_result": "111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1084147147,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "41.4 MB",
  "runtime": "0 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "4 weeks",
  "timestamp": 1698269660,
  "title": "Rotate Image",
  "title_slug": "rotate-image",
  "url": "/submissions/detail/1084147147/"
}{
  "code": "class Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        int n = matrix.length;\n        int m = matrix[0].length;\n\n        boolean [][] check = new boolean[n][m];\n        // Arrays.fill(check,false);\n        ArrayList<Integer> re = new ArrayList<>();\n        move(re,0,matrix,check,0,0,n*m);\n        System.gc();\n        return re;\n        \n    }\n\n    void move(List<Integer> re, int dir, int[][] matrix, boolean[][] check, int x, int y,int total){\n        if (re.size() == total ) return;\n        if (x>= matrix.length) return;\n        if (y>= matrix[0].length) return;\n        if (check[x][y]) return;\n        // System.out.println(x+\" \"+ y + \" \"+ dir);\n        re.add(matrix[x][y]);\n        check[x][y] = true;\n        if (dir == 0){\n            if ( y+1<matrix[0].length && !check[x][y+1]){\n                move(re,dir,matrix,check,x,y+1, total);\n            } else{\n                move(re,1,matrix,check,x+1,y,total);\n            }\n        } else if (dir == 1){\n            if (x+1<matrix.length && !check[x+1][y])\n                move(re,dir,matrix,check,x+1,y,total);\n            else\n                move(re,2,matrix,check,x,y-1,total);\n        } else if (dir == 2) {\n            if ( y-1 >=0 && !check[x][y-1])\n                move(re,dir,matrix,check,x,y-1,total);\n            else \n                move(re,3,matrix,check,x-1,y,total);\n        } else if (dir == 3){\n            if (x-1>=0 && !check[x-1][y])\n                move(re,dir,matrix,check,x-1,y,total);\n            else\n                move(re,0,matrix,check,x,y+1,total);\n        }\n        return;\n    }\n}",
  "compare_result": "1111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1084143015,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "41.8 MB",
  "runtime": "0 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "4 weeks",
  "timestamp": 1698269127,
  "title": "Spiral Matrix",
  "title_slug": "spiral-matrix",
  "url": "/submissions/detail/1084143015/"
}{
  "code": "class Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        int n = matrix.length;\n        int m = matrix[0].length;\n\n        boolean [][] check = new boolean[n][m];\n        // Arrays.fill(check,false);\n        ArrayList<Integer> re = new ArrayList<>();\n        move(re,0,matrix,check,0,0,n*m);\n        System.gc();\n        return re;\n        \n    }\n\n    void move(List<Integer> re, int dir, int[][] matrix, boolean[][] check, int x, int y,int total){\n        if (re.size() == total ) return;\n        if (x>= matrix.length) return;\n        if (y>= matrix[0].length) return;\n        if (check[x][y]) return;\n        // System.out.println(x+\" \"+ y + \" \"+ dir);\n        re.add(matrix[x][y]);\n        check[x][y] = true;\n        if (dir == 0){\n            if ( y+1<matrix[0].length && !check[x][y+1]){\n                move(re,dir,matrix,check,x,y+1, total);\n            } else{\n                move(re,1,matrix,check,x+1,y,total);\n            }\n        } else if (dir == 1){\n            if (x+1<matrix.length && !check[x+1][y])\n                move(re,dir,matrix,check,x+1,y,total);\n            else\n                move(re,2,matrix,check,x,y-1,total);\n        } else if (dir == 2) {\n            if ( y-1 >=0 && !check[x][y-1])\n                move(re,dir,matrix,check,x,y-1,total);\n            else \n                move(re,3,matrix,check,x-1,y,total);\n        } else if (dir == 3){\n            if (x-1>=0 && !check[x-1][y])\n                move(re,dir,matrix,check,x-1,y,total);\n            else\n                move(re,0,matrix,check,x,y+1,total);\n        }\n        return;\n    }\n}",
  "compare_result": "1111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1084142947,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "42 MB",
  "runtime": "0 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "4 weeks",
  "timestamp": 1698269118,
  "title": "Spiral Matrix",
  "title_slug": "spiral-matrix",
  "url": "/submissions/detail/1084142947/"
}{
  "code": "class Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        int n = matrix.length;\n        int m = matrix[0].length;\n\n        boolean [][] check = new boolean[n][m];\n        // Arrays.fill(check,false);\n        ArrayList<Integer> re = new ArrayList<>();\n        move(re,0,matrix,check,0,0,n*m);\n        System.gc();\n        return re;\n        \n    }\n\n    void move(List<Integer> re, int dir, int[][] matrix, boolean[][] check, int x, int y,int total){\n        if (re.size() == total ) return;\n        if (x>= matrix.length) return;\n        if (y>= matrix[0].length) return;\n        if (check[x][y]) return;\n        // System.out.println(x+\" \"+ y + \" \"+ dir);\n        re.add(matrix[x][y]);\n        check[x][y] = true;\n        if (dir == 0){\n            if ( y+1<matrix[0].length && !check[x][y+1]){\n                move(re,dir,matrix,check,x,y+1, total);\n            } else{\n                move(re,1,matrix,check,x+1,y,total);\n            }\n        } else if (dir == 1){\n            if (x+1<matrix.length && !check[x+1][y])\n                move(re,dir,matrix,check,x+1,y,total);\n            else\n                move(re,2,matrix,check,x,y-1,total);\n        } else if (dir == 2) {\n            if ( y-1 >=0 && !check[x][y-1])\n                move(re,dir,matrix,check,x,y-1,total);\n            else \n                move(re,3,matrix,check,x-1,y,total);\n        } else if (dir == 3){\n            if (x-1>=0 && !check[x-1][y])\n                move(re,dir,matrix,check,x-1,y,total);\n            else\n                move(re,0,matrix,check,x,y+1,total);\n        }\n        return;\n    }\n}",
  "compare_result": "1111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1084142883,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "41.8 MB",
  "runtime": "0 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "4 weeks",
  "timestamp": 1698269111,
  "title": "Spiral Matrix",
  "title_slug": "spiral-matrix",
  "url": "/submissions/detail/1084142883/"
}{
  "code": "class Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        int n = matrix.length;\n        int m = matrix[0].length;\n\n        boolean [][] check = new boolean[n][m];\n        // Arrays.fill(check,false);\n        ArrayList<Integer> re = new ArrayList<>();\n        move(re,0,matrix,check,0,0,n*m);\n        return re;\n        \n    }\n\n    void move(List<Integer> re, int dir, int[][] matrix, boolean[][] check, int x, int y,int total){\n        if (re.size() == total ) return;\n        if (x>= matrix.length) return;\n        if (y>= matrix[0].length) return;\n        if (check[x][y]) return;\n        // System.out.println(x+\" \"+ y + \" \"+ dir);\n        re.add(matrix[x][y]);\n        check[x][y] = true;\n        if (dir == 0){\n            if ( y+1<matrix[0].length && !check[x][y+1]){\n                move(re,dir,matrix,check,x,y+1, total);\n            } else{\n                move(re,1,matrix,check,x+1,y,total);\n            }\n        } else if (dir == 1){\n            if (x+1<matrix.length && !check[x+1][y])\n                move(re,dir,matrix,check,x+1,y,total);\n            else\n                move(re,2,matrix,check,x,y-1,total);\n        } else if (dir == 2) {\n            if ( y-1 >=0 && !check[x][y-1])\n                move(re,dir,matrix,check,x,y-1,total);\n            else \n                move(re,3,matrix,check,x-1,y,total);\n        } else if (dir == 3){\n            if (x-1>=0 && !check[x-1][y])\n                move(re,dir,matrix,check,x-1,y,total);\n            else\n                move(re,0,matrix,check,x,y+1,total);\n        }\n        return;\n    }\n}",
  "compare_result": "1111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1084142459,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "40.6 MB",
  "runtime": "0 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "4 weeks",
  "timestamp": 1698269059,
  "title": "Spiral Matrix",
  "title_slug": "spiral-matrix",
  "url": "/submissions/detail/1084142459/"
}{
  "code": "class Solution {\n    public boolean isValidSudoku(char[][] board) {\n        int n = board.length;\n        int m = board[0].length;\n        for (int i  = 0;i<n;i++){\n            HashSet<Character> set = new HashSet<>();\n            for (int j = 0;j<m;j++){\n                if (board[i][j]!='.'){\n                    if (set.contains(board[i][j])) return false;\n                    else set.add(board[i][j]);\n                }\n            }\n        }\n        \n        for (int i  = 0;i<m;i++){\n            HashSet<Character> set = new HashSet<>();\n            for (int j = 0;j<n;j++){\n                if (board[j][i]!='.'){\n                    if (set.contains(board[j][i])) return false;\n                    else set.add(board[j][i]);\n                }\n            }\n        }\n\n        for (int i = 0;i<n;i+=3){\n            for (int j = 0;j<m;j+=3){\n                HashSet<Character> set = new HashSet<>();\n                for (int x = 0;x<3;x++){\n                    for (int y = 0;y<3;y++){\n                        char temp = board[i+x][j+y];\n                        if (temp!='.') {\n                            if (set.contains(temp)) return false;\n                            else set.add(temp);\n                        }\n                        \n                    }\n                }\n            }\n        }\n        return true;\n    }\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1084082607,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "43.3 MB",
  "runtime": "2 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "4 weeks, 1 day",
  "timestamp": 1698262455,
  "title": "Valid Sudoku",
  "title_slug": "valid-sudoku",
  "url": "/submissions/detail/1084082607/"
}{
  "code": "class Solution {\n    public String minWindow(String s, String t) {\n        HashMap<Character, Integer> m = new HashMap<>();\n        HashMap<Character, Integer> tracker = new HashMap<>();\n\n        for (Character c: t.toCharArray()){\n            m.put(c,m.getOrDefault(c,0)+1);\n            tracker.put(c,0);\n        }\n        int l = 0;\n        int r = 0;\n        int count = 0;\n        int n = s.length();\n        char [] ch = s.toCharArray();\n        int min = Integer.MAX_VALUE;\n        int min_l = -1;\n        int min_r = -1;\n        // HashSet<Integer> test = new HashSet<>();\n        while (r<n){\n                                // System.out.println(l +\" \" + r +\" \" + count);\n\n            if ( tracker.containsKey( ch[r] ) ){\n                tracker.put(ch[r], tracker.get(ch[r])+1);\n                if (tracker.get(ch[r]).equals(m.get(ch[r]))){\n                    count ++;\n                }\n            }\n            // if (!test.contains(count)){\n            //     System.out.println(count + \" \"+ m.keySet().size());;\n            //     test.add(count);\n            // }\n                \n\n            if (count == m.keySet().size()){\n                \n                while (count == m.keySet().size()){\n                    if (l>=n) break;\n\n                    int dist = r - l + 1;\n                    if (dist<min) {\n                        min = dist;\n                        min_l = l;\n                        min_r = r;\n                    }\n                      \n                    if (tracker.containsKey(ch[l])){\n                        tracker.put(ch[l],tracker.get(ch[l])-1 );\n                        if (tracker.get(ch[l])<m.get(ch[l] ) ) count --;\n\n                    }\n                    l++;\n                }\n            }\n            r++;\n        }\n\n\n        if (min==Integer.MAX_VALUE) return \"\";\n        StringBuilder re = new StringBuilder();\n        for (int i = min_l; i<=min_r;i++){\n            re.append(ch[i]);\n        }\n        return re.toString();\n\n    }\n}\n// ADOBECODEBANC",
  "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1083313001,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "43.9 MB",
  "runtime": "15 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month",
  "timestamp": 1698180609,
  "title": "Minimum Window Substring",
  "title_slug": "minimum-window-substring",
  "url": "/submissions/detail/1083313001/"
}{
  "code": "class Solution {\n    public String minWindow(String s, String t) {\n        HashMap<Character, Integer> m = new HashMap<>();\n        HashMap<Character, Integer> tracker = new HashMap<>();\n\n        for (Character c: t.toCharArray()){\n            m.put(c,m.getOrDefault(c,0)+1);\n            tracker.put(c,0);\n        }\n        int l = 0;\n        int r = 0;\n        int count = 0;\n        int n = s.length();\n        char [] ch = s.toCharArray();\n        int min = Integer.MAX_VALUE;\n        int min_l = -1;\n        int min_r = -1;\n        \n        while (r<n){\n                                // System.out.println(l +\" \" + r +\" \" + count);\n\n            if ( tracker.containsKey( ch[r] ) ){\n                tracker.put(ch[r], tracker.get(ch[r])+1);\n                if (tracker.get(ch[r])==m.get(ch[r])){\n                    count ++;\n                }\n            }\n            if (count == m.keySet().size()){\n                \n                while (count == m.keySet().size()){\n                    if (l>=n) break;\n\n                    int dist = r - l + 1;\n                    if (dist<min) {\n                        min = dist;\n                        min_l = l;\n                        min_r = r;\n                    }\n                      \n                    if (tracker.containsKey(ch[l])){\n                        tracker.put(ch[l],tracker.get(ch[l])-1 );\n                        if (tracker.get(ch[l])<m.get(ch[l] ) ) count --;\n\n                    }\n                    l++;\n                }\n            }\n            r++;\n        }\n\n\n        if (min==Integer.MAX_VALUE) return \"\";\n        StringBuilder re = new StringBuilder();\n        for (int i = min_l; i<=min_r;i++){\n            re.append(ch[i]);\n        }\n        return re.toString();\n\n    }\n}\n// ADOBECODEBANC",
  "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111101",
  "flag_type": 1,
  "has_notes": false,
  "id": 1083309688,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "1 month",
  "timestamp": 1698180243,
  "title": "Minimum Window Substring",
  "title_slug": "minimum-window-substring",
  "url": "/submissions/detail/1083309688/"
}{
  "code": "class Solution {\n    public String minWindow(String s, String t) {\n        HashMap<Character, Integer> m = new HashMap<>();\n        HashMap<Character, Integer> tracker = new HashMap<>();\n\n        for (Character c: t.toCharArray()){\n            m.put(c,m.getOrDefault(c,0)+1);\n            tracker.put(c,0);\n        }\n        int l = 0;\n        int r = 0;\n        int count = 0;\n        int n = s.length();\n        char [] ch = s.toCharArray();\n        int min = Integer.MAX_VALUE;\n        int min_l = -1;\n        int min_r = -1;\n        \n        while (r<n){\n                                System.out.println(l +\" \" + r +\" \" + count);\n\n            if ( tracker.containsKey( ch[r] ) ){\n                tracker.put(ch[r], tracker.get(ch[r])+1);\n                if (tracker.get(ch[r])==m.get(ch[r])){\n                    count ++;\n                }\n            }\n            if (count == m.keySet().size()){\n                \n                while (count == m.keySet().size()){\n                    if (l>=n) break;\n\n                    int dist = r - l + 1;\n                    if (dist<min) {\n                        min = dist;\n                        min_l = l;\n                        min_r = r;\n                    }\n                      \n                    if (tracker.containsKey(ch[l])){\n                        tracker.put(ch[l],tracker.get(ch[l])-1 );\n                        if (tracker.get(ch[l])<m.get(ch[l] ) ) count --;\n\n                    }\n                    l++;\n                }\n            }\n            r++;\n        }\n\n\n        if (min==Integer.MAX_VALUE) return \"\";\n        StringBuilder re = new StringBuilder();\n        for (int i = min_l; i<=min_r;i++){\n            re.append(ch[i]);\n        }\n        return re.toString();\n\n    }\n}\n// ADOBECODEBANC",
  "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111101",
  "flag_type": 1,
  "has_notes": false,
  "id": 1083309628,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "1 month",
  "timestamp": 1698180235,
  "title": "Minimum Window Substring",
  "title_slug": "minimum-window-substring",
  "url": "/submissions/detail/1083309628/"
}{
  "code": "class Solution {\n    public String minWindow(String s, String t) {\n        HashMap<Character, Integer> m = new HashMap<>();\n        HashMap<Character, Integer> tracker = new HashMap<>();\n\n        for (Character c: t.toCharArray()){\n            m.put(c,m.getOrDefault(c,0)+1);\n            tracker.put(c,0);\n        }\n        int l = 0;\n        int r = 0;\n        int count = 0;\n        int n = s.length();\n        char [] ch = s.toCharArray();\n        int min = Integer.MAX_VALUE;\n        int min_l = -1;\n        int min_r = -1;\n        \n        while (r<n){\n            if ( tracker.containsKey( ch[r] ) ){\n                tracker.put(ch[r], tracker.get(ch[r])+1);\n                if (tracker.get(ch[r])==m.get(ch[r])){\n                    count ++;\n                }\n            }\n            if (count == t.length()){\n                \n                while (count == t.length()){\n                    // System.out.println(l +\" \" + r +\" \" + count);\n\n                    int dist = r - l + 1;\n                    if (dist<min) {\n                        min = dist;\n                        min_l = l;\n                        min_r = r;\n                    }\n                      \n                    if (l>=n) break;\n                    if (tracker.containsKey(ch[l])){\n                        tracker.put(ch[l],tracker.get(ch[l])-1 );\n                        if (tracker.get(ch[l])<m.get(ch[l] ) ) count --;\n\n                    }\n                    l++;\n                }\n            }\n            r++;\n        }\n\n\n        if (min==Integer.MAX_VALUE) return \"\";\n        StringBuilder re = new StringBuilder();\n        for (int i = min_l; i<=min_r;i++){\n            re.append(ch[i]);\n        }\n        return re.toString();\n\n    }\n}\n// ADOBECODEBANC",
  "compare_result": "111111110111111111101100011110011011010011111100110111111011001111111111111111010111110111111111111001000001011010111000111111111101111111010111101111010111110111111111100010010011110000000101000000000000000000000000001001010000000010000001001000100000001100000000001",
  "flag_type": 1,
  "has_notes": false,
  "id": 1083308264,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "1 month",
  "timestamp": 1698180092,
  "title": "Minimum Window Substring",
  "title_slug": "minimum-window-substring",
  "url": "/submissions/detail/1083308264/"
}{
  "code": "class Solution {\n    public int minimumSum(int[] nums) {\n        int sum = 0;\n        int n = nums.length;\n        int[] l = new int[n];\n        int[] r = new int[n];\n        int min= Integer.MAX_VALUE;\n        Arrays.fill(l, Integer.MAX_VALUE);\n        Arrays.fill(r, Integer.MAX_VALUE);\n        for (int i =0;i<n;i++) {\n        \tif (nums[i]<min) min = nums[i];\n        \tl[i] = min;\n        }\n        min= Integer.MAX_VALUE;\n        for (int i =n-1;i>0;i--) {\n        \tif (nums[i]<min) min = nums[i];\n        \tr[i] = min;\n        }\n        min= Integer.MAX_VALUE;\n        for (int i = 0;i<n;i++) {\n        \t// System.out.println(l[i]+\" \"+r[i]);\n        \tsum = l[i] + r[i]+nums[i];\n        \tif (nums[i]>l[i] && nums[i]>r[i]) {\n        \t\tif (sum<min) min = sum;\n        \t}\n        }\n        return min==Integer.MAX_VALUE?-1:min;\n \n    }\n}",
  "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1081005310,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "60.7 MB",
  "runtime": "3 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month",
  "timestamp": 1697943354,
  "title": "Minimum Sum of Mountain Triplets II",
  "title_slug": "minimum-sum-of-mountain-triplets-ii",
  "url": "/submissions/detail/1081005310/"
}{
  "code": "class Solution {\n    public int minimumSum(int[] nums) {\n        int sum = 0;\n        int n = nums.length;\n        int[] l = new int[n];\n        int[] r = new int[n];\n        int min= Integer.MAX_VALUE;\n        Arrays.fill(l, Integer.MAX_VALUE);\n        Arrays.fill(r, Integer.MAX_VALUE);\n\n        for (int i=1;i<n;i++) {\n        \tfor (int j=i-1;j>=0;j--) {\n        \t\tif (nums[i]>nums[j]) {\n        \t\t\tif (nums[j]<l[i]) {\n        \t\t\t\tl[i] = nums[j];\n        \t\t\t}\n        \t\t}\n        \t}\n        }\n        for (int i=n-2;i>=0;i--) {\n        \tfor (int j=i+1;j<n;j++) {\n        \t\tif (nums[i]>nums[j]) {\n        \t\t\tif (nums[j]<r[i]) {\n        \t\t\t\tr[i] = nums[j];\n        \t\t\t}\n        \t\t}\n        \t}\n        }\n        for (int i = 0;i<n;i++) {\n        \t// System.out.println(l[i]+\" \"+r[i]);\n        \tsum = l[i] + r[i]+nums[i];\n        \tif (l[i]!= Integer.MAX_VALUE && r[i]!=Integer.MAX_VALUE) {\n        \t\tif (sum<min) min = sum;\n        \t}\n        }\n        \n        return min==Integer.MAX_VALUE?-1:min;\n \n    }\n}",
  "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000",
  "flag_type": 1,
  "has_notes": false,
  "id": 1081000886,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 14,
  "status_display": "Time Limit Exceeded",
  "time": "1 month",
  "timestamp": 1697943108,
  "title": "Minimum Sum of Mountain Triplets II",
  "title_slug": "minimum-sum-of-mountain-triplets-ii",
  "url": "/submissions/detail/1081000886/"
}{
  "code": "class Solution {\n    public int minimumSum(int[] nums) {\n        int sum = 0;\n        int n = nums.length;\n        int min = Integer.MAX_VALUE;\n        for (int i =0;i<n-2;i++) {\n        \tfor (int j=i+1;j<n-1;j++) {\n        \t\tfor (int k= j+1;k<n;k++) {\n        \t\t\tif (nums[j]>nums[k] && nums[j]>nums[i]) {\n        \t\t\t\tsum = nums[i] + nums[j] + nums[k];\n        \t\t\t\tif (sum<min) min = sum;\n        \t\t\t}\n        \t\t}\n        \t}\n        }\n        return min==Integer.MAX_VALUE?-1:min;\n    }\n}",
  "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000000000000",
  "flag_type": 1,
  "has_notes": false,
  "id": 1080984658,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 14,
  "status_display": "Time Limit Exceeded",
  "time": "1 month",
  "timestamp": 1697942300,
  "title": "Minimum Sum of Mountain Triplets II",
  "title_slug": "minimum-sum-of-mountain-triplets-ii",
  "url": "/submissions/detail/1080984658/"
}{
  "code": "class Solution {\n    public int minimumSum(int[] nums) {\n        int sum = 0;\n        int n = nums.length;\n        int min = Integer.MAX_VALUE;\n        for (int i =0;i<n-2;i++) {\n        \tfor (int j=i+1;j<n-1;j++) {\n        \t\tfor (int k= j+1;k<n;k++) {\n        \t\t\tif (nums[j]>nums[k] && nums[j]>nums[i]) {\n        \t\t\t\tsum = nums[i] + nums[j] + nums[k];\n        \t\t\t\tif (sum<min) min = sum;\n        \t\t\t}\n        \t\t}\n        \t}\n        }\n        return min==Integer.MAX_VALUE?-1:min;\n    }\n}",
  "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1080982338,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "41.4 MB",
  "runtime": "1 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month",
  "timestamp": 1697942206,
  "title": "Minimum Sum of Mountain Triplets I",
  "title_slug": "minimum-sum-of-mountain-triplets-i",
  "url": "/submissions/detail/1080982338/"
}{
  "code": "class Solution {\n    public String minWindow(String s, String t) {\n        HashMap<Character, Integer> m = new HashMap<>();\n        for (Character c: t.toCharArray()){\n            m.put(c,m.getOrDefault(c,0)+1);\n        }\n        int l = 0;\n        int r = 0;\n        char [] ch = s.toCharArray();\n        int n = t.length();\n        HashMap<Character, Integer> temp = new HashMap<>(m);\n        int min = Integer.MAX_VALUE;\n        int min_l = -1;\n        int min_r = -1;\n        int count = 0;\n        int next_l = -1;\n        while (l<s.length()){\n            while (l<s.length() && !temp.containsKey(ch[l])) l++;\n            r= l;\n            count = 0;\n            next_l = -1;\n            while (r<s.length() && count<n){\n                if (temp.containsKey(ch[r])){\n                    if ( r != l && next_l == -1) next_l = r;\n                }\n                if (temp.containsKey(ch[r]) && temp.get(ch[r])>0 ){\n                    count++;\n                    temp.put(ch[r], temp.get(ch[r])-1);\n                }\n                // System.out.println(l+\" \"+r+\" \"+count+ \" \"+ next_l);\n                if (count == n){\n                    int v = r-l + 1;\n                    if (v < min) {\n                        min = v;\n                        min_l = l;\n                        min_r = r;\n                        break;\n                    }\n                }\n                r++;\n            }\n            count = 1;\n\n            l = next_l!=-1?next_l:r ;\n            temp = new HashMap<>(m);\n            \n        }\n        StringBuilder re = new StringBuilder();\n        if (min == Integer.MAX_VALUE) return \"\";\n        for (int i = min_l;i<=min_r;i++){\n            re.append(s.charAt(i));\n        }\n\n        return re.toString();\n\n    }\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100",
  "flag_type": 1,
  "has_notes": false,
  "id": 1080881773,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 14,
  "status_display": "Time Limit Exceeded",
  "time": "1 month",
  "timestamp": 1697925760,
  "title": "Minimum Window Substring",
  "title_slug": "minimum-window-substring",
  "url": "/submissions/detail/1080881773/"
}{
  "code": "class Solution {\n    public String minWindow(String s, String t) {\n        HashMap<Character, Integer> m = new HashMap<>();\n        for (Character c: t.toCharArray()){\n            m.put(c,m.getOrDefault(c,0)+1);\n        }\n        int l = 0;\n        int r = 0;\n        char [] ch = s.toCharArray();\n        int n = t.length();\n        HashMap<Character, Integer> temp = new HashMap<>(m);\n        int min = Integer.MAX_VALUE;\n        int min_l = -1;\n        int min_r = -1;\n        int count = 0;\n        int next_l = -1;\n        while (l<s.length()){\n            while (l<s.length() && !temp.containsKey(ch[l])) l++;\n            r= l;\n            count = 0;\n            next_l = -1;\n            while (r<s.length() && count<n){\n                if (temp.containsKey(ch[r])){\n                    if ( r != l && next_l == -1) next_l = r;\n                }\n                if (temp.containsKey(ch[r]) && temp.get(ch[r])>0 ){\n                    count++;\n                    temp.put(ch[r], temp.get(ch[r])-1);\n                }\n                // System.out.println(l+\" \"+r+\" \"+count+ \" \"+ next_l);\n                if (count == n){\n                    int v = r-l + 1;\n                    if (v < min) {\n                        min = v;\n                        min_l = l;\n                        min_r = r;\n                        break;\n                    }\n                }\n                r++;\n            }\n            count = 1;\n\n            l = next_l!=-1?next_l:r ;\n            temp = new HashMap<>(m);\n            \n        }\n        StringBuilder re = new StringBuilder();\n        if (min == Integer.MAX_VALUE) return \"\";\n        for (int i = min_l;i<=min_r;i++){\n            re.append(s.charAt(i));\n        }\n\n        return re.toString();\n\n    }\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100",
  "flag_type": 1,
  "has_notes": false,
  "id": 1080297362,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 14,
  "status_display": "Time Limit Exceeded",
  "time": "1 month",
  "timestamp": 1697855801,
  "title": "Minimum Window Substring",
  "title_slug": "minimum-window-substring",
  "url": "/submissions/detail/1080297362/"
}{
  "code": "class Solution {\n    public String minWindow(String s, String t) {\n        HashMap<Character, Integer> m = new HashMap<>();\n        for (Character c: t.toCharArray()){\n            m.put(c,m.getOrDefault(c,0)+1);\n        }\n        int l = 0;\n        int r = 0;\n        char [] ch = s.toCharArray();\n        int n = t.length();\n        HashMap<Character, Integer> temp = new HashMap<>(m);\n        int min = Integer.MAX_VALUE;\n        int min_l = -1;\n        int min_r = -1;\n        int count = 0;\n        while (l<s.length()){\n            while (l<s.length() && !temp.containsKey(ch[l])) l++;\n            r= l;\n            count = 0;\n            while (r<s.length() && count<n){\n                if (temp.containsKey(ch[r]) && temp.get(ch[r])>0 ){\n                    count++;\n                    temp.put(ch[r], temp.get(ch[r])-1);\n                }\n                // System.out.println(l+\" \"+r+\" \"+count);\n                if (count == n){\n                    int v = r-l + 1;\n                    if (v < min) {\n                        min = v;\n                        min_l = l;\n                        min_r = r;\n                        break;\n\n                    }\n                }\n                r++;\n            }\n            count = 1;\n            l = l+1 ;\n            temp = new HashMap<>(m);\n            \n        }\n        StringBuilder re = new StringBuilder();\n        if (min == Integer.MAX_VALUE) return \"\";\n        for (int i = min_l;i<=min_r;i++){\n            re.append(s.charAt(i));\n        }\n\n        return re.toString();\n\n    }\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100",
  "flag_type": 1,
  "has_notes": false,
  "id": 1080295015,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 14,
  "status_display": "Time Limit Exceeded",
  "time": "1 month",
  "timestamp": 1697855341,
  "title": "Minimum Window Substring",
  "title_slug": "minimum-window-substring",
  "url": "/submissions/detail/1080295015/"
}{
  "code": "class Solution {\n    public String minWindow(String s, String t) {\n        HashMap<Character, Integer> m = new HashMap<>();\n        for (Character c: t.toCharArray()){\n            m.put(c,m.getOrDefault(c,0)+1);\n        }\n        int l = 0;\n        int r = 0;\n        char [] ch = s.toCharArray();\n        int n = t.length();\n        HashMap<Character, Integer> temp = new HashMap<>(m);\n        int min = Integer.MAX_VALUE;\n        int min_l = -1;\n        int min_r = -1;\n        int count = 0;\n        while (l<s.length()){\n            while (l<s.length() && !temp.containsKey(ch[l])) l++;\n            r= l;\n            count = 0;\n            while (r<s.length() && count<n){\n                if (temp.containsKey(ch[r]) && temp.get(ch[r])>0 ){\n                    count++;\n                    temp.put(ch[r], temp.get(ch[r])-1);\n                }\n                System.out.println(l+\" \"+r+\" \"+count);\n                if (count == n){\n                    int v = r-l + 1;\n                    if (v < min) {\n                        min = v;\n                        min_l = l;\n                        min_r = r;\n                        break;\n\n                    }\n                }\n                r++;\n            }\n            count = 1;\n            l = l+1 ;\n            temp = new HashMap<>(m);\n            \n        }\n        StringBuilder re = new StringBuilder();\n        if (min == Integer.MAX_VALUE) return \"\";\n        for (int i = min_l;i<=min_r;i++){\n            re.append(s.charAt(i));\n        }\n\n        return re.toString();\n\n    }\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000",
  "flag_type": 1,
  "has_notes": false,
  "id": 1080294956,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 14,
  "status_display": "Time Limit Exceeded",
  "time": "1 month",
  "timestamp": 1697855332,
  "title": "Minimum Window Substring",
  "title_slug": "minimum-window-substring",
  "url": "/submissions/detail/1080294956/"
}{
  "code": "class Solution {\n    public String minWindow(String s, String t) {\n        HashMap<Character, Integer> m = new HashMap<>();\n        for (Character c: t.toCharArray()){\n            m.put(c,m.getOrDefault(c,0)+1);\n        }\n        int l = 0;\n        int r = 0;\n        char [] ch = s.toCharArray();\n        int n = t.length();\n        HashMap<Character, Integer> temp = new HashMap<>(m);\n        int min = Integer.MAX_VALUE;\n        int min_l = -1;\n        int min_r = -1;\n        int count = 0;\n        while (l<s.length()){\n            while (l<s.length() && !temp.containsKey(ch[l])) l++;\n            r= l;\n            count = 0;\n            while (r<s.length() && count<n){\n                if (temp.containsKey(ch[r]) && temp.get(ch[r])>0 ){\n                    count++;\n                    temp.put(ch[r], temp.get(ch[r])+1);\n                }\n                System.out.println(l+\" \"+r+\" \"+count);\n                if (count == n){\n                    int v = r-l + 1;\n                    if (v < min) {\n                        min = v;\n                        min_l = l;\n                        min_r = r;\n                        break;\n\n                    }\n                }\n                r++;\n            }\n            count = 1;\n            l = l+1 ;\n            temp = new HashMap<>(m);\n            \n        }\n        StringBuilder re = new StringBuilder();\n        if (min == Integer.MAX_VALUE) return \"\";\n        for (int i = min_l;i<=min_r;i++){\n            re.append(s.charAt(i));\n        }\n\n        return re.toString();\n\n    }\n}",
  "compare_result": "111111111111111111111000011111000000010001001100011110111100100011011101111110011110011110001010001000010001011111001101110111101110111111111111111111111000011111010111101001010110000000001101101000000000000000000010000000000000000000000000001000000000000000000000000",
  "flag_type": 1,
  "has_notes": false,
  "id": 1080294322,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "1 month",
  "timestamp": 1697855201,
  "title": "Minimum Window Substring",
  "title_slug": "minimum-window-substring",
  "url": "/submissions/detail/1080294322/"
}{
  "code": "class Solution {\n    public String minWindow(String s, String t) {\n        HashMap<Character, Integer> m = new HashMap<>();\n        for (Character c: t.toCharArray()){\n            m.put(c,m.getOrDefault(c,0)+1);\n        }\n        int l = 0;\n        int r = 0;\n        char [] ch = s.toCharArray();\n        int n = t.length();\n        HashMap<Character, Integer> temp = new HashMap<>(m);\n        int min = Integer.MAX_VALUE;\n        int min_l = -1;\n        int min_r = -1;\n        int count = 0;\n        while (l<s.length()){\n            while (l<s.length() && !temp.containsKey(ch[l])) l++;\n            r= l;\n            count = 0;\n            while (r<s.length() && count<n){\n                if (temp.containsKey(ch[r]) && temp.get(ch[r])>0 ){\n                    count++;\n                    temp.put(ch[r], temp.get(ch[r])+1);\n                }\n                // System.out.println(l+\" \"+r+\" \"+count);\n                if (count == n){\n                    int v = r-l + 1;\n                    if (v < min) {\n                        min = v;\n                        min_l = l;\n                        min_r = r;\n                    }\n                }\n                r++;\n\n            }\n            l = r + 1;\n            \n        }\n        StringBuilder re = new StringBuilder();\n        if (min == Integer.MAX_VALUE) return \"\";\n        for (int i = min_l;i<=min_r;i++){\n            re.append(s.charAt(i));\n        }\n\n        return re.toString();\n\n    }\n}",
  "compare_result": "111111111111111111110000000001000000010010001100011110111100100011010101101110011110011110001010001100000001011110101101110111101110111111111111111111111000011111010111101001010110010000001101101000000000000000000000000000000000000000000000000000000000000000000000000",
  "flag_type": 1,
  "has_notes": false,
  "id": 1080281724,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "1 month",
  "timestamp": 1697852637,
  "title": "Minimum Window Substring",
  "title_slug": "minimum-window-substring",
  "url": "/submissions/detail/1080281724/"
}{
  "code": "class Solution {\n    public String minWindow(String s, String t) {\n        HashMap<Character, Integer> m = new HashMap<>();\n        for (Character c: t.toCharArray()){\n            m.put(c,m.getOrDefault(c,0)+1);\n        }\n        int l = 0;\n        int r = 0;\n        char [] ch = s.toCharArray();\n        int n = t.length();\n        HashMap<Character, Integer> temp = new HashMap<>(m);\n        int min = Integer.MAX_VALUE;\n        int min_l = -1;\n        int min_r = -1;\n        int count = 0;\n        while (l<s.length()){\n            while (!temp.containsKey(ch[l])) l++;\n            r= l;\n            count = 0;\n            while (r<s.length() && count<n){\n                if (temp.containsKey(ch[r]) && temp.get(ch[r])>0 ){\n                    count++;\n                    temp.put(ch[r], temp.get(ch[r])+1);\n                }\n                // System.out.println(l+\" \"+r+\" \"+count);\n                if (count == n){\n                    int v = r-l + 1;\n                    if (v < min) {\n                        min = v;\n                        min_l = l;\n                        min_r = r;\n                    }\n                }\n                r++;\n\n            }\n            l = r + 1;\n            \n        }\n        StringBuilder re = new StringBuilder();\n        if (min == Integer.MAX_VALUE) return \"\";\n        for (int i = min_l;i<=min_r;i++){\n            re.append(s.charAt(i));\n        }\n\n        return re.toString();\n\n    }\n}",
  "compare_result": "111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
  "flag_type": 1,
  "has_notes": false,
  "id": 1080281548,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 15,
  "status_display": "Runtime Error",
  "time": "1 month",
  "timestamp": 1697852601,
  "title": "Minimum Window Substring",
  "title_slug": "minimum-window-substring",
  "url": "/submissions/detail/1080281548/"
}{
  "code": "class Solution {\n    public String minWindow(String s, String t) {\n        HashMap<Character, Integer> m = new HashMap<>();\n        for (Character c: t.toCharArray()){\n            m.put(c,m.getOrDefault(c,0)+1);\n        }\n        int l = 0;\n        int r = 0;\n        char [] ch = s.toCharArray();\n        int n = t.length();\n        HashMap<Character, Integer> temp = new HashMap<>(m);\n        int min = Integer.MAX_VALUE;\n        int min_l = -1;\n        int min_r = -1;\n        int count = 0;\n        while (l<s.length()){\n            while (!temp.containsKey(ch[l])) l++;\n            r= l;\n            count = 0;\n            while (r<s.length() && count<n){\n                if (temp.containsKey(ch[r]) && temp.get(ch[r])>0 ){\n                    count++;\n                    temp.put(ch[r], temp.get(ch[r])+1);\n                }\n                System.out.println(l+\" \"+r+\" \"+count);\n                if (count == n){\n                    int v = r-l + 1;\n                    if (v < min) {\n                        min = v;\n                        min_l = l;\n                        min_r = r;\n                    }\n                }\n                r++;\n\n            }\n            l = r + 1;\n            \n        }\n        StringBuilder re = new StringBuilder();\n        if (min == Integer.MAX_VALUE) return \"\";\n        for (int i = min_l;i<=min_r;i++){\n            re.append(s.charAt(i));\n        }\n\n        return re.toString();\n\n    }\n}",
  "compare_result": "111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
  "flag_type": 1,
  "has_notes": false,
  "id": 1080281525,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 15,
  "status_display": "Runtime Error",
  "time": "1 month",
  "timestamp": 1697852595,
  "title": "Minimum Window Substring",
  "title_slug": "minimum-window-substring",
  "url": "/submissions/detail/1080281525/"
}{
  "code": "class Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        HashMap<String,Integer> map = new HashMap<>();\n        for (String si: words){\n            if (map.containsKey(si)) map.put(si,map.get(si)+1);\n            else map.put(si,1);\n        }\n        HashMap<String,Integer> temp = new HashMap<>();\n        StringBuilder sb = new StringBuilder();\n        int l = 0;\n        int r = 0;\n        int count = 0;\n        int wordLen = words[0].length();\n        int start = l;\n        List<Integer> re = new ArrayList<>();\n        while (l<s.length()){\n            boolean check = false;\n            for (String si:map.keySet()){\n                if (!temp.containsKey(si)){\n                    if (s.startsWith(si,l)){\n                        // System.out.println(si);\n                        count++;\n                        l= l + si.length();\n                        temp.put(si,1);\n                        check = true;\n                    }\n                }\n                else if (temp.get(si)<map.get(si)){\n                    if (s.startsWith(si,l)){\n                        // System.out.println(si);\n                        count++;\n                        l= l + si.length();\n                        temp.put(si,temp.get(si)+1);\n                        check = true;\n                    }\n                }\n                \n            }\n            if (!check){\n                if (count == words.length) re.add(start);\n                l = start+1;\n                start = l;\n                count = 0;\n                temp = new HashMap<>();\n            }   \n        }\n        // System.out.println(count);\n        if (count == words.length) re.add(start);\n\n        return re;\n    }\n}",
  "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1080272298,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "45 MB",
  "runtime": "2346 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month",
  "timestamp": 1697850613,
  "title": "Substring with Concatenation of All Words",
  "title_slug": "substring-with-concatenation-of-all-words",
  "url": "/submissions/detail/1080272298/"
}{
  "code": "class Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        HashMap<String,Integer> map = new HashMap<>();\n        for (String si: words){\n            if (map.containsKey(si)) map.put(si,map.get(si)+1);\n            else map.put(si,1);\n        }\n        HashMap<String,Integer> temp = new HashMap<>();\n        StringBuilder sb = new StringBuilder();\n        int l = 0;\n        int r = 0;\n        int count = 0;\n        int wordLen = words[0].length();\n        int start = l;\n        List<Integer> re = new ArrayList<>();\n        while (l<s.length()){\n            boolean check = false;\n            for (String si:map.keySet()){\n                if (!temp.containsKey(si)){\n                    if (s.startsWith(si,l)){\n                        // System.out.println(si);\n                        count++;\n                        l= l + si.length();\n                        temp.put(si,1);\n                        check = true;\n                    }\n                }\n                else if (temp.get(si)<map.get(si)){\n                    if (s.startsWith(si,l)){\n                        // System.out.println(si);\n                        count++;\n                        l= l + si.length();\n                        temp.put(si,temp.get(si)+1);\n                        check = true;\n                    }\n                }\n                \n            }\n            if (!check){\n                if (count == words.length) re.add(start);\n                l = start+1;\n                start = l;\n                count = 0;\n                temp.clear();\n            }   \n        }\n        // System.out.println(count);\n        if (count == words.length) re.add(start);\n\n        return re;\n    }\n}",
  "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1080272159,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "45 MB",
  "runtime": "2277 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month",
  "timestamp": 1697850587,
  "title": "Substring with Concatenation of All Words",
  "title_slug": "substring-with-concatenation-of-all-words",
  "url": "/submissions/detail/1080272159/"
}{
  "code": "class Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        HashMap<String,Integer> map = new HashMap<>();\n        for (String si: words){\n            if (map.containsKey(si)) map.put(si,map.get(si)+1);\n            else map.put(si,1);\n        }\n        HashMap<String,Integer> temp = new HashMap<>();\n        StringBuilder sb = new StringBuilder();\n        int l = 0;\n        int r = 0;\n        int count = 0;\n        int wordLen = words[0].length();\n        int start = l;\n        List<Integer> re = new ArrayList<>();\n        while (l<s.length()){\n            boolean check = false;\n            for (String si:map.keySet()){\n                if (!temp.containsKey(si)){\n                    if (s.startsWith(si,l)){\n                        // System.out.println(si);\n                        count++;\n                        l= l + si.length();\n                        temp.put(si,1);\n                        check = true;\n                    }\n                }\n                else if (temp.get(si)<map.get(si)){\n                    if (s.startsWith(si,l)){\n                        // System.out.println(si);\n                        count++;\n                        l= l + si.length();\n                        temp.put(si,temp.get(si)+1);\n                        check = true;\n                    }\n                }\n                \n            }\n            if (!check){\n                if (count == words.length) re.add(start);\n                l = start+1;\n                start = l;\n                count = 0;\n                temp.clear();\n            }   \n        }\n        // System.out.println(count);\n        if (count == words.length) re.add(start);\n\n        return re;\n    }\n}",
  "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1080272096,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "45 MB",
  "runtime": "2275 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month",
  "timestamp": 1697850574,
  "title": "Substring with Concatenation of All Words",
  "title_slug": "substring-with-concatenation-of-all-words",
  "url": "/submissions/detail/1080272096/"
}{
  "code": "class Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        HashMap<String,Integer> map = new HashMap<>();\n        for (String si: words){\n            if (map.containsKey(si)) map.put(si,map.get(si)+1);\n            else map.put(si,1);\n        }\n        HashMap<String,Integer> temp = new HashMap<>(map);\n        StringBuilder sb = new StringBuilder();\n        int l = 0;\n        int r = 0;\n        int count = 0;\n        int wordLen = words[0].length();\n        int start = l;\n        List<Integer> re = new ArrayList<>();\n        while (l<s.length()){\n            boolean check = false;\n            for (String si:map.keySet()){\n                if (map.get(si)>0){\n                    if (s.startsWith(si,l)){\n                        // System.out.println(si);\n                        count++;\n                        l= l + si.length();\n                        map.put(si,map.get(si)-1);\n                        check = true;\n                    }\n                }\n            }\n            if (!check){\n                if (count == words.length) re.add(start);\n                l = start+1;\n                start = l;\n                count = 0;\n                map = new HashMap<>(temp);\n            }   \n        }\n        // System.out.println(count);\n        if (count == words.length) re.add(start);\n\n        return re;\n    }\n}",
  "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1080245817,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "45 MB",
  "runtime": "1959 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month",
  "timestamp": 1697845047,
  "title": "Substring with Concatenation of All Words",
  "title_slug": "substring-with-concatenation-of-all-words",
  "url": "/submissions/detail/1080245817/"
}{
  "code": "class Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        HashMap<String,Integer> map = new HashMap<>();\n        for (String si: words){\n            if (map.containsKey(si)) map.put(si,map.get(si)+1);\n            else map.put(si,1);\n        }\n        HashMap<String,Integer> temp = new HashMap<>(map);\n        StringBuilder sb = new StringBuilder();\n        int l = 0;\n        int r = 0;\n        int count = 0;\n        int wordLen = words[0].length();\n        int start = l;\n        List<Integer> re = new ArrayList<>();\n        while (l<s.length()){\n            boolean check = false;\n            for (String si:map.keySet()){\n                if (map.get(si)>0){\n                    if (s.startsWith(si,l)){\n                        System.out.println(si);\n                        count++;\n                        l= l + si.length();\n                        map.put(si,map.get(si)-1);\n                        check = true;\n                    }\n                }\n            }\n            if (!check){\n                if (count == words.length) re.add(start);\n                l = start+1;\n                start = l;\n                count = 0;\n                map = new HashMap<>(temp);\n            }   \n        }\n        System.out.println(count);\n        if (count == words.length) re.add(start);\n\n        return re;\n    }\n}",
  "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110",
  "flag_type": 1,
  "has_notes": false,
  "id": 1080245566,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 14,
  "status_display": "Time Limit Exceeded",
  "time": "1 month",
  "timestamp": 1697844995,
  "title": "Substring with Concatenation of All Words",
  "title_slug": "substring-with-concatenation-of-all-words",
  "url": "/submissions/detail/1080245566/"
}{
  "code": "class Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        HashMap<String,Integer> map = new HashMap<>();\n        for (String si: words){\n            if (map.containsKey(si)) map.put(si,map.get(si)+1);\n            else map.put(si,1);\n        }\n        HashMap<String,Integer> temp = new HashMap<>(map);\n        StringBuilder sb = new StringBuilder();\n        int l = 0;\n        int r = 0;\n        int count = 0;\n        int wordLen = words[0].length();\n        int start = l;\n        List<Integer> re = new ArrayList<>();\n        while (l<s.length()){\n            boolean check = false;\n            for (String si:map.keySet()){\n                if (map.get(si)>0){\n                    if (s.startsWith(si,l)){\n                        System.out.println(si);\n                        count++;\n                        l= l + si.length();\n                        map.put(si,map.get(si)-1);\n                        check = true;\n                    }\n                }\n            }\n            if (!check){\n                if (count == words.length) re.add(start);\n                l = start+wordLen;\n                start = l;\n                count = 0;\n                map = new HashMap<>(temp);\n            }   \n        }\n        System.out.println(count);\n        if (count == words.length) re.add(start);\n\n        return re;\n    }\n}",
  "compare_result": "11110111110110111100111110010011010001111011100110110001111110111011110100000011111001000111110001101101110010110011010101010000010010000001000000100000000000000000000000000011010",
  "flag_type": 1,
  "has_notes": false,
  "id": 1080245094,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "1 month",
  "timestamp": 1697844893,
  "title": "Substring with Concatenation of All Words",
  "title_slug": "substring-with-concatenation-of-all-words",
  "url": "/submissions/detail/1080245094/"
}{
  "code": "class Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        Set<List<Integer>> a = new HashSet<>();\n        int zeros = 0;\n        ArrayList<Integer> pos = new ArrayList<>();\n        ArrayList<Integer> neg = new ArrayList<>();\n        HashSet<Integer> posSet = new HashSet<>();\n        HashSet<Integer> negSet = new HashSet<>();\n        for (int i : nums){\n            if (i ==0) zeros++;\n            if (i>0) {\n                pos.add(i);\n                posSet.add(i);\n            }\n            if (i<0){\n                neg.add(i);\n                negSet.add(i);\n            }\n        }\n        List<List<Integer>> re = new ArrayList<>();\n        if (zeros >=3) a.add(Arrays.asList(0,0,0));\n        if (zeros >0 ){\n            for (int i: posSet){\n                if (negSet.contains(-i)){\n                    a.add(Arrays.asList(-i,0,i));\n                }\n            }\n        }\n        //2 pos\n        for (int i = 0; i<pos.size()-1;i++){\n            for (int j = i+1;j<pos.size();j++){\n                if ( negSet.contains( -1 *(pos.get(i)+pos.get(j) ) ) )  {\n                    List<Integer> temp = Arrays.asList(-1 * (pos.get(i)+pos.get(j)), pos.get(i),pos.get(j));\n                    Collections.sort(temp);\n                    a.add(temp);\n                }\n            }\n        }\n        \n        // 2 neg\n        for (int i = 0 ;i<neg.size()-1;i++){\n            for (int j = i+1; j<neg.size();j++){\n                if (posSet.contains( -1 * (neg.get(i)+neg.get(j)) )){\n                    List<Integer> temp = Arrays.asList(neg.get(i),neg.get(j),-1 * (neg.get(i)+neg.get(j)));\n                    Collections.sort(temp);\n                    a.add(temp);\n                }\n            }\n        }       \n        re.addAll(a);\n\n        return re;\n        \n    }\n}\n\n",
  "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1080218693,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "52.4 MB",
  "runtime": "119 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month",
  "timestamp": 1697840016,
  "title": "3Sum",
  "title_slug": "3sum",
  "url": "/submissions/detail/1080218693/"
}{
  "code": "class Solution {\n    public int minSubArrayLen(int target, int[] nums) {\n        int l = 0;\n        int r = -1;\n        int n = nums.length;\n        int sum = 0;\n        int min = Integer.MAX_VALUE;\n        while (true ){\n            if (sum<target){\n                r++;\n                if (r>=n) break;\n                sum = sum+nums[r];\n            } else{\n                if (r-l + 1 < min) min = r-l+1;\n                if (l>=n) break;\n                sum = sum - nums[l];\n                l++;\n            }\n            // System.out.println(l +\" \" + r +\" \"+ sum +\" \" + min);\n\n        }\n        return min==Integer.MAX_VALUE?0:min;\n        \n    }\n}",
  "compare_result": "111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1079726575,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "53.4 MB",
  "runtime": "1 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month",
  "timestamp": 1697782357,
  "title": "Minimum Size Subarray Sum",
  "title_slug": "minimum-size-subarray-sum",
  "url": "/submissions/detail/1079726575/"
}{
  "code": "class Solution {\n    public int minSubArrayLen(int target, int[] nums) {\n        int l = 0;\n        int r = -1;\n        int n = nums.length;\n        int sum = 0;\n        int min = Integer.MAX_VALUE;\n        while (true ){\n            if (sum<target){\n                r++;\n                if (r>=n) break;\n                sum = sum+nums[r];\n            } else{\n                if (r-l + 1 < min) min = r-l+1;\n                if (l>=n) break;\n                sum = sum - nums[l];\n                l++;\n            }\n            System.out.println(l +\" \" + r +\" \"+ sum +\" \" + min);\n\n        }\n        return min==Integer.MAX_VALUE?0:min;\n        \n    }\n}",
  "compare_result": "111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1079726461,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "56.2 MB",
  "runtime": "356 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month",
  "timestamp": 1697782345,
  "title": "Minimum Size Subarray Sum",
  "title_slug": "minimum-size-subarray-sum",
  "url": "/submissions/detail/1079726461/"
}{
  "code": "class Solution {\n    public int minSubArrayLen(int target, int[] nums) {\n        Arrays.sort(nums);\n        int n = nums.length;\n        int sum = 0;\n        int count = 0;\n        for (int i = n-1;i>=0;i-- ){\n            count++;\n            sum = sum + nums[i];\n            if (sum >= target) return count;\n        }\n        return 0;\n        \n    }\n}",
  "compare_result": "111111110111111110011",
  "flag_type": 1,
  "has_notes": false,
  "id": 1079712714,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "1 month",
  "timestamp": 1697780900,
  "title": "Minimum Size Subarray Sum",
  "title_slug": "minimum-size-subarray-sum",
  "url": "/submissions/detail/1079712714/"
}{
  "code": "class Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        Set<List<Integer>> a = new HashSet<>();\n        int zeros = 0;\n        ArrayList<Integer> pos = new ArrayList<>();\n        ArrayList<Integer> neg = new ArrayList<>();\n        HashSet<Integer> posSet = new HashSet<>();\n        HashSet<Integer> negSet = new HashSet<>();\n        for (int i : nums){\n            if (i ==0) zeros++;\n            if (i>0) {\n                pos.add(i);\n                posSet.add(i);\n            }\n            if (i<0){\n                neg.add(i);\n                negSet.add(i);\n            }\n        }\n        List<List<Integer>> re = new ArrayList<>();\n        if (zeros >=3) a.add(Arrays.asList(0,0,0));\n        if (zeros >0 ){\n            for (int i: posSet){\n                if (negSet.contains(-i)){\n                    a.add(Arrays.asList(-i,0,i));\n                }\n            }\n        }\n        //2 pos\n        for (int i = 0; i<pos.size()-1;i++){\n            for (int j = i+1;j<pos.size();j++){\n                if ( negSet.contains( -1 *(pos.get(i)+pos.get(j) ) ) )  {\n                    List<Integer> temp = Arrays.asList(-1 * (pos.get(i)+pos.get(j)), pos.get(i),pos.get(j));\n                    Collections.sort(temp);\n                    a.add(temp);\n                }\n            }\n        }\n        \n        // 2 neg\n        for (int i = 0 ;i<neg.size()-1;i++){\n            for (int j = i+1; j<neg.size();j++){\n                if (posSet.contains( -1 * (neg.get(i)+neg.get(j)) )){\n                    List<Integer> temp = Arrays.asList(neg.get(i),neg.get(j),-1 * (neg.get(i)+neg.get(j)));\n                    Collections.sort(temp);\n                    a.add(temp);\n                }\n            }\n        }       \n        re.addAll(a);\n\n        return re;\n        \n    }\n}\n\n",
  "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1079701921,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "52.3 MB",
  "runtime": "119 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month",
  "timestamp": 1697779694,
  "title": "3Sum",
  "title_slug": "3sum",
  "url": "/submissions/detail/1079701921/"
}{
  "code": "class Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        List<List<Integer>> a = new ArrayList<>();\n        int zeros = 0;\n        ArrayList<Integer> pos = new ArrayList<>();\n        ArrayList<Integer> neg = new ArrayList<>();\n        HashSet<Integer> posSet = new HashSet<>();\n        HashSet<Integer> negSet = new HashSet<>();\n        for (int i : nums){\n            if (i ==0) zeros++;\n            if (i>0) {\n                pos.add(i);\n                posSet.add(i);\n            }\n            if (i<0){\n                neg.add(i);\n                negSet.add(i);\n            }\n        }\n        if (zeros >=3) a.add(Arrays.asList(0,0,0));\n        if (zeros >0 ){\n            for (int i: posSet){\n                if (negSet.contains(-i)){\n                    a.add(Arrays.asList(-i,0,i));\n                }\n            }\n        }\n        //2 pos\n        for (int i = 0; i<pos.size()-1;i++){\n            for (int j = i+1;j<pos.size();j++){\n                if ( negSet.contains( -1 *(pos.get(i)+pos.get(j) ) ) )  {\n                    a.add(Arrays.asList(-1 * (pos.get(i)+pos.get(j)), pos.get(i),pos.get(j)));\n                }\n            }\n        }\n        \n        // 2 neg\n        for (int i = 0 ;i<neg.size()-1;i++){\n            for (int j = i+1; j<neg.size();j++){\n                if (posSet.contains( -1 * (neg.get(i)+neg.get(j)) )){\n                    a.add(Arrays.asList(neg.get(i),neg.get(j),-1 * (neg.get(i)+neg.get(j))));\n                }\n            }\n        }       \n\n        return a;\n        \n    }\n}",
  "compare_result": "111111111111111111111010011100011010111101001101010000000000111001000110011100011101100000000110101000100100000001111000011000000000000000000000000000000000000011000000000000000000000000001000000000000000000001011100000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000110",
  "flag_type": 1,
  "has_notes": false,
  "id": 1079696292,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "1 month",
  "timestamp": 1697779062,
  "title": "3Sum",
  "title_slug": "3sum",
  "url": "/submissions/detail/1079696292/"
}{
  "code": "class Solution {\n    public List<String> summaryRanges(int[] nums) {\n        int start = 0;\n        int pointer = 1;\n        // int prev = 0;\n        int n = nums.length;\n        int end = -1;\n        ArrayList<String> re = new ArrayList<>();\n        if (n == 0) return re;\n\n        while (pointer<n){\n            if ( nums[pointer] != nums[pointer -1 ] + 1 ){\n                if (start == pointer-1){\n                    re.add(\"\"+nums[start]);\n                } else{\n                    re.add(nums[start]+\"->\"+nums[pointer-1]);\n                }\n                start = pointer;\n            } \n            pointer++;\n        }\n        if (start == pointer-1){\n            re.add(\"\"+nums[start]);\n        } else{\n            re.add(nums[start]+\"->\"+nums[pointer-1]);\n        }\n        return re;\n    }\n}",
  "compare_result": "11111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1079008434,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "40.6 MB",
  "runtime": "5 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month",
  "timestamp": 1697701229,
  "title": "Summary Ranges",
  "title_slug": "summary-ranges",
  "url": "/submissions/detail/1079008434/"
}{
  "code": "class Solution {\n    public List<String> summaryRanges(int[] nums) {\n        int start = 0;\n        int pointer = 1;\n        // int prev = 0;\n        int n = nums.length;\n        int end = -1;\n        ArrayList<String> re = new ArrayList<>();\n        while (pointer<n){\n            if ( nums[pointer] != nums[pointer -1 ] + 1 ){\n                if (start == pointer-1){\n                    re.add(\"\"+nums[start]);\n                } else{\n                    re.add(nums[start]+\"->\"+nums[pointer-1]);\n                }\n                start = pointer;\n            } \n            pointer++;\n        }\n        if (start == pointer-1){\n            re.add(\"\"+nums[start]);\n        } else{\n            re.add(nums[start]+\"->\"+nums[pointer-1]);\n        }\n        return re;\n    }\n}",
  "compare_result": "11000000000000000000000000000000",
  "flag_type": 1,
  "has_notes": false,
  "id": 1079008119,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 15,
  "status_display": "Runtime Error",
  "time": "1 month",
  "timestamp": 1697701197,
  "title": "Summary Ranges",
  "title_slug": "summary-ranges",
  "url": "/submissions/detail/1079008119/"
}{
  "code": "class Solution {\n    public int maxArea(int[] height) {\n        int max = 0;\n        int n = height.length;\n        int l= 0;\n        int r = n-1;\n        while (l<r){\n            int val = Integer.min(height[l],height[r]) * (r-l);\n            if (val > max) max = val;\n            if (height[l]<height[r]) l++;\n            else r--;\n        }\n        return max;\n    }\n}",
  "compare_result": "1111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1078092930,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "55 MB",
  "runtime": "4 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month",
  "timestamp": 1697605207,
  "title": "Container With Most Water",
  "title_slug": "container-with-most-water",
  "url": "/submissions/detail/1078092930/"
}{
  "code": "class Solution {\n    public int maxArea(int[] height) {\n        int max = 0;\n        int n = height.length;\n        for (int i = 0;i<n-1;i++){\n            for (int j= i+1; j<n;j++){\n                int val= Integer.min(height[i],height[j]) * (j-i);\n                if (val >max) max = val;\n            }\n        }\n        return max;\n    }\n}",
  "compare_result": "1111111111111111111111111111111111111111111111111111111100000",
  "flag_type": 1,
  "has_notes": false,
  "id": 1078090155,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 14,
  "status_display": "Time Limit Exceeded",
  "time": "1 month",
  "timestamp": 1697604923,
  "title": "Container With Most Water",
  "title_slug": "container-with-most-water",
  "url": "/submissions/detail/1078090155/"
}{
  "code": "class Solution {\n    public int[] twoSum(int[] numbers, int target) {\n        int l = 0;\n        int r = numbers.length-1;\n        while(numbers[l]+numbers[r]!=target){\n            if (numbers[l]+numbers[r]> target) \n                r--;\n            else \n                l++;\n        }\n        int [] re = {l+1,r+1};\n        return re;\n        \n    }\n}",
  "compare_result": "11111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1078072802,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "45.2 MB",
  "runtime": "2 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month",
  "timestamp": 1697603101,
  "title": "Two Sum II - Input Array Is Sorted",
  "title_slug": "two-sum-ii-input-array-is-sorted",
  "url": "/submissions/detail/1078072802/"
}{
  "code": "class Solution {\n    public boolean isSubsequence(String s, String t) {\n        int p1 = 0;\n        int p2 = 0;\n        while (p1<s.length() && p2<t.length()){\n            if (s.charAt(p1)==t.charAt(p2)){\n                p1++;\n                p2++;\n            } else{\n                p2++;\n            }\n        }\n        return p1>(s.length()-1);\n\n    }\n}",
  "compare_result": "1111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1078058309,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "40.4 MB",
  "runtime": "1 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month",
  "timestamp": 1697601594,
  "title": "Is Subsequence",
  "title_slug": "is-subsequence",
  "url": "/submissions/detail/1078058309/"
}{
  "code": "class Solution {\n    public List<String> fullJustify(String[] words, int maxWidth) {\n        List<String> re = new ArrayList<>();\n        Queue<String> q = new LinkedList<>();\n        int count = 0;\n        int c = -1;\n        for (int i=0;i<words.length;i++){\n            count = count + words[i].length();\n            c++;\n            if (count+c<=maxWidth){\n                q.add(words[i]);\n            } else{\n                String s = \"\";\n                String sp = \"\";\n                String sp1 = \"\";\n\n                count = count - words[i].length();\n                int numspace;\n                int tempcount = 0;\n                if (q.size() == 1) {\n                    numspace = maxWidth - count;\n                    tempcount = 0;\n                } else{\n                    numspace = (maxWidth - count) /(q.size() -1);\n                    tempcount = (maxWidth - count) % (q.size() -1);\n                }\n                \n                while (sp.length()<numspace) sp=sp+\" \";\n                while (sp1.length()<numspace+1) sp1=sp1+\" \";\n                System.out.println(tempcount + \" \"+ numspace);\n                if (q.size() > 1)\n                {\n                    while (q.size()>1){\n                    if (tempcount > 0){\n                        s= s+ q.poll() + sp1;\n                    }\n                    else{\n                        s= s+ q.poll() + sp;\n                    }\n                    tempcount--;\n                    }\n                    if (q.size()==1)\n                    {\n                        s= s+q.poll();\n                    }\n                } else{\n                    s= s+q.poll();\n                    while (s.length()<maxWidth){\n                        s= s+\" \";\n                    }\n\n                }\n                \n                re.add(s);\n                q.add(words[i]);\n\n                count = 0;\n                c= -1;\n                count = count + words[i].length();\n                c++;\n            }\n        }\n        String s = \"\";\n        while (!q.isEmpty()){\n            s = s + q.poll() +\" \";\n        }\n        s = s.substring(0,s.length()-1);\n        while (s.length()<maxWidth){\n            s= s+\" \";\n        }\n\n        re.add(s);\n        for (String i:re){\n            System.out.println(i);\n        }\n        System.out.println(re.get(0).length());\n\n        return re;\n        \n    }\n}\n",
  "compare_result": "11111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1078005534,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "41.7 MB",
  "runtime": "18 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month",
  "timestamp": 1697595467,
  "title": "Text Justification",
  "title_slug": "text-justification",
  "url": "/submissions/detail/1078005534/"
}{
  "code": "class Solution {\n    public List<String> fullJustify(String[] words, int maxWidth) {\n        List<String> re = new ArrayList<>();\n        Queue<String> q = new LinkedList<>();\n        int count = 0;\n        int c = -1;\n        for (int i=0;i<words.length;i++){\n            count = count + words[i].length();\n            c++;\n            if (count+c<=maxWidth){\n                q.add(words[i]);\n            } else{\n                String s = \"\";\n                String sp = \"\";\n                count = count - words[i].length();\n                int numspace1;\n                int numspace;\n                if (q.size() == 1) {\n                    numspace = maxWidth - count;\n                    numspace1 = numspace;\n                } else{\n                    numspace = (maxWidth - count) /(q.size() -1);\n                    numspace1 = numspace + (maxWidth - count) % (q.size() -1);\n                }\n                \n                while (sp.length()<numspace1) sp=sp+\" \";\n                s = q.poll() + sp;\n                sp = \"\";\n                while (sp.length()<numspace) sp=sp+\" \";\n                while (q.size()>1){\n                    s= s+ q.poll() + sp;\n                }\n                if (q.size()==1)\n                {\n                    s= s+q.poll();\n                }\n                re.add(s);\n                q.add(words[i]);\n\n                count = 0;\n                c= -1;\n                count = count + words[i].length();\n                c++;\n            }\n        }\n        String s = \"\";\n        while (!q.isEmpty()){\n            s = s + q.poll() +\" \";\n        }\n        s = s.substring(0,s.length()-1);\n        while (s.length()<maxWidth){\n            s= s+\" \";\n        }\n\n        re.add(s);\n        for (String i:re){\n            System.out.println(i);\n        }\n        System.out.println(re.get(0).length());\n\n        return re;\n        \n    }\n}",
  "compare_result": "11000111111111111110100100011",
  "flag_type": 1,
  "has_notes": false,
  "id": 1077962591,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "1 month",
  "timestamp": 1697589329,
  "title": "Text Justification",
  "title_slug": "text-justification",
  "url": "/submissions/detail/1077962591/"
}{
  "code": "class Solution {\n    public int strStr(String haystack, String needle) {\n        return haystack.indexOf(needle);\n    }\n}",
  "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1077930590,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "40.2 MB",
  "runtime": "0 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month",
  "timestamp": 1697584485,
  "title": "Find the Index of the First Occurrence in a String",
  "title_slug": "find-the-index-of-the-first-occurrence-in-a-string",
  "url": "/submissions/detail/1077930590/"
}{
  "code": "class Solution {\n    public int strStr(String haystack, String needle) {\n        return haystack.indexOf(needle);\n    }\n}",
  "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1077930522,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "40.8 MB",
  "runtime": "0 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month",
  "timestamp": 1697584475,
  "title": "Find the Index of the First Occurrence in a String",
  "title_slug": "find-the-index-of-the-first-occurrence-in-a-string",
  "url": "/submissions/detail/1077930522/"
}{
  "code": "class Solution {\n    public String convert(String s, int numRows) {\n        StringBuilder[] st = new StringBuilder[numRows];\n        for (int i = 0;i<numRows;i++) st[i] = new StringBuilder();\n        int count = 0;\n        main:\n        while (count<s.length()){\n            for (int i = 0;i< numRows;i++){\n                if (count >=s.length() ) break main;\n                st[i].append(s.charAt(count));\n                count++;\n            }\n            for (int i = numRows - 2 ; i>=1; i--){\n                if (count >=s.length() ) break main;\n                st[i].append(s.charAt(count));\n                count++;\n            }\n        }\n        StringBuilder re = new StringBuilder();\n        for (StringBuilder si:st){\n            re.append( si.toString() );\n        }\n        return re.toString();\n        \n    }\n}",
  "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1077929824,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "44.5 MB",
  "runtime": "4 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month",
  "timestamp": 1697584370,
  "title": "Zigzag Conversion",
  "title_slug": "zigzag-conversion",
  "url": "/submissions/detail/1077929824/"
}{
  "code": "class Solution {\n    public String convert(String s, int numRows) {\n        String []st = new String[numRows];\n        Arrays.fill(st,\"\");\n        int count = 0;\n        main:\n        while (count<s.length()){\n            for (int i = 0;i< numRows;i++){\n                if (count >=s.length() ) break main;\n                st[i] = st[i] + s.charAt(count);\n                count++;\n            }\n            for (int i = numRows - 2 ; i>=1; i--){\n                if (count >=s.length() ) break main;\n                st[i] = st[i] + s.charAt(count);\n                count++;\n            }\n        }\n        String re = \"\";\n        for (String si:st){\n            re= re + si;\n        }\n        return re;\n        \n    }\n}",
  "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1077928086,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "44.6 MB",
  "runtime": "14 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month",
  "timestamp": 1697584088,
  "title": "Zigzag Conversion",
  "title_slug": "zigzag-conversion",
  "url": "/submissions/detail/1077928086/"
}{
  "code": "class Solution {\n    public String convert(String s, int numRows) {\n        String []st = new String[numRows];\n        // Arrays.fill(st,\"\");\n        int count = 0;\n        main:\n        while (count<s.length()){\n            for (int i = 0;i< numRows;i++){\n                if (count >=s.length() ) break main;\n                st[i] = st[i] + s.charAt(count);\n                count++;\n            }\n            for (int i = numRows - 2 ; i>=1; i--){\n                if (count >=s.length() ) break main;\n                st[i] = st[i] + s.charAt(count);\n                count++;\n            }\n        }\n        String re = \"\";\n        for (String si:st){\n            re= re + si;\n        }\n        return re;\n        \n    }\n}",
  "compare_result": "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
  "flag_type": 1,
  "has_notes": false,
  "id": 1077928047,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "1 month",
  "timestamp": 1697584082,
  "title": "Zigzag Conversion",
  "title_slug": "zigzag-conversion",
  "url": "/submissions/detail/1077928047/"
}{
  "code": "class Solution {\n    public String convert(String s, int numRows) {\n        String []st = new String[numRows];\n        // Arrays.fill(st,\"\");\n        int count = 0;\n        main:\n        while (count<s.length()){\n            for (int i = 0;i< numRows;i++){\n                if (count >=s.length() ) break main;\n                st[i] = st[i] + s.charAt(count);\n                count++;\n            }\n            for (int i = numRows - 2 ; i>=1; i--){\n                if (count >=s.length() ) break main;\n                st[i] = st[i] + s.charAt(count);\n                count++;\n            }\n        }\n        String re = \"\";\n        for (String si:st){\n            re= re + si;\n        }\n        return re;\n        \n    }\n}",
  "compare_result": "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
  "flag_type": 1,
  "has_notes": false,
  "id": 1077927996,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "1 month",
  "timestamp": 1697584073,
  "title": "Zigzag Conversion",
  "title_slug": "zigzag-conversion",
  "url": "/submissions/detail/1077927996/"
}{
  "code": "class Solution {\n    public String convert(String s, int numRows) {\n        String []st = new String[numRows];\n        Arrays.fill(st,\"\");\n        int count = 0;\n        main:\n        while (count<s.length()){\n            for (int i = 0;i< numRows;i++){\n                if (count >=s.length() ) break main;\n                st[i] = st[i] + s.charAt(count);\n                count++;\n            }\n            for (int i = numRows - 2 ; i>=1; i--){\n                if (count >=s.length() ) break main;\n                st[i] = st[i] + s.charAt(count);\n                count++;\n            }\n        }\n        String re = \"\";\n        for (String si:st){\n            re= re + si;\n        }\n        return re;\n        \n    }\n}",
  "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1077927917,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "44.3 MB",
  "runtime": "14 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month",
  "timestamp": 1697584063,
  "title": "Zigzag Conversion",
  "title_slug": "zigzag-conversion",
  "url": "/submissions/detail/1077927917/"
}{
  "code": "class Solution {\n    public String reverseWords(String s) {\n        String [] temp = s.split(\"\\\\s+\");\n        StringBuilder sb = new StringBuilder();\n        for (int i = temp.length-1; i>=0;i--){\n            // System.out.println(temp[i]);\n            sb.append(temp[i] + \" \");\n        }\n        return sb.toString().trim();\n        \n    }\n}",
  "compare_result": "1111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1077923764,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "43.9 MB",
  "runtime": "8 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month",
  "timestamp": 1697583427,
  "title": "Reverse Words in a String",
  "title_slug": "reverse-words-in-a-string",
  "url": "/submissions/detail/1077923764/"
}{
  "code": "class Solution {\n    public String reverseWords(String s) {\n        String [] temp = s.split(\"\\\\s+\");\n        StringBuilder sb = new StringBuilder();\n        for (int i = temp.length-1; i>=0;i--){\n            System.out.println(temp[i]);\n            sb.append(temp[i] + \" \");\n        }\n        return sb.toString().trim();\n        \n    }\n}",
  "compare_result": "1111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1077923727,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "43.7 MB",
  "runtime": "21 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month",
  "timestamp": 1697583421,
  "title": "Reverse Words in a String",
  "title_slug": "reverse-words-in-a-string",
  "url": "/submissions/detail/1077923727/"
}{
  "code": "class Solution {\n    public String longestCommonPrefix(String[] strs) {\n        int count = 0;\n        boolean check = true;\n        while (check){\n            if (count>=strs[0].length()) break;\n            char temp = strs[0].charAt(count);\n            for (String st: strs){\n\n                if ( count>=st.length() || st.charAt(count)!=temp){\n                    check = false;\n                    break;\n                }\n            }\n            if (!check) break;\n            count++;\n        }\n        System.out.println(count);\n        return strs[0].substring(0,count);\n    }\n}",
  "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1077913294,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "40.3 MB",
  "runtime": "2 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month",
  "timestamp": 1697581877,
  "title": "Longest Common Prefix",
  "title_slug": "longest-common-prefix",
  "url": "/submissions/detail/1077913294/"
}{
  "code": "class Solution {\n    public int lengthOfLastWord(String s) {\n        String [] temp = s.split(\" \");\n        return temp[temp.length-1].length();\n    }\n}",
  "compare_result": "1111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1077908823,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "40.7 MB",
  "runtime": "1 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month",
  "timestamp": 1697581260,
  "title": "Length of Last Word",
  "title_slug": "length-of-last-word",
  "url": "/submissions/detail/1077908823/"
}{
  "code": "class Solution {\n    public String intToRoman(int num) {\n        StringBuilder sb = new StringBuilder();\n        while(  num>=1000){\n            num = num - 1000;\n            sb.append(\"M\");\n        }\n\n        if (num >=900) {\n            num = num - 900;\n            sb.append(\"CM\");\n        }\n        if (num >=500) {\n            num = num - 500;\n            sb.append(\"D\");\n        }\n        if (num >=400) {\n            num = num - 400;\n            sb.append(\"CD\");\n        }\n        while (num >=100){\n            num = num-100;\n            sb.append(\"C\");\n        }\n\n        if (num >=90) {\n            num = num - 90;\n            sb.append(\"XC\");\n        }\n        if (num >=50) {\n            num = num - 50;\n            sb.append(\"L\");\n        }\n        if (num >=40) {\n            num = num - 40;\n            sb.append(\"XL\");\n        }\n        while (num >=10){\n            num = num-10;\n            sb.append(\"X\");\n        }\n\n        if (num >=9) {\n            num = num - 9;\n            sb.append(\"IX\");\n        }\n        if (num >=5) {\n            num = num - 5;\n            sb.append(\"V\");\n        }\n        if (num >=4) {\n            num = num - 4;\n            sb.append(\"IV\");\n        }\n        while (num >=1){\n            num = num-1;\n            sb.append(\"I\");\n        }\n        return sb.toString();\n        \n    }\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1077907368,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "43.2 MB",
  "runtime": "2 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month",
  "timestamp": 1697581058,
  "title": "Integer to Roman",
  "title_slug": "integer-to-roman",
  "url": "/submissions/detail/1077907368/"
}{
  "code": "class Solution {\n    public String intToRoman(int num) {\n        StringBuilder sb = new StringBuilder();\n        while(  num>=1000){\n            num = num - 1000;\n            sb.append(\"M\");\n        }\n\n        if (num >=900) {\n            num = num - 900;\n            sb.append(\"CM\");\n        }\n        if (num >=500) {\n            num = num - 900;\n            sb.append(\"D\");\n        }\n        if (num >=400) {\n            num = num - 400;\n            sb.append(\"CD\");\n        }\n        while (num >=100){\n            num = num-100;\n            sb.append(\"C\");\n        }\n\n        if (num >=90) {\n            num = num - 90;\n            sb.append(\"XC\");\n        }\n        if (num >=50) {\n            num = num - 50;\n            sb.append(\"L\");\n        }\n        if (num >=40) {\n            num = num - 40;\n            sb.append(\"XL\");\n        }\n        while (num >=10){\n            num = num-10;\n            sb.append(\"X\");\n        }\n\n        if (num >=9) {\n            num = num - 9;\n            sb.append(\"IX\");\n        }\n        if (num >=5) {\n            num = num - 5;\n            sb.append(\"V\");\n        }\n        if (num >=4) {\n            num = num - 4;\n            sb.append(\"IV\");\n        }\n        while (num >=1){\n            num = num-1;\n            sb.append(\"I\");\n        }\n        return sb.toString();\n        \n    }\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1077907232,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "1 month",
  "timestamp": 1697581042,
  "title": "Integer to Roman",
  "title_slug": "integer-to-roman",
  "url": "/submissions/detail/1077907232/"
}{
  "code": "class Solution {\n    public String intToRoman(int num) {\n        StringBuilder sb = new StringBuilder();\n        while(  num>=1000){\n            num = num - 1000;\n            sb.append(\"M\");\n        }\n\n        if (num >=900) {\n            num = num - 900;\n            sb.append(\"CM\");\n        }\n        if (num >=500) {\n            num = num - 900;\n            sb.append(\"D\");\n        }\n        if (num >=400) {\n            num = num - 400;\n            sb.append(\"CD\");\n        }\n        while (num >=100){\n            num = num-100;\n            sb.append(\"C\");\n        }\n\n        if (num >=90) {\n            num = num - 90;\n            sb.append(\"XC\");\n        }\n        if (num >=50) {\n            num = num - 50;\n            sb.append(\"L\");\n        }\n        if (num >=40) {\n            num = num - 400;\n            sb.append(\"XL\");\n        }\n        while (num >=10){\n            num = num-10;\n            sb.append(\"X\");\n        }\n\n        if (num >=9) {\n            num = num - 9;\n            sb.append(\"IX\");\n        }\n        if (num >=5) {\n            num = num - 5;\n            sb.append(\"V\");\n        }\n        if (num >=4) {\n            num = num - 4;\n            sb.append(\"IV\");\n        }\n        while (num >=1){\n            num = num-1;\n            sb.append(\"I\");\n        }\n        return sb.toString();\n        \n    }\n}",
  "compare_result": "111111111111111111111111111111111111111111000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000000001111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000000111111111111111111111111111111111111111111111111111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000111111111111111111111111111111111111111110000000001111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000000001111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000011111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011111111111111111111111111111111111111111000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000000001111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000011111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011111111111111111111111111111111111111111000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000000001111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000000001111111111111111111111111111111111111111111111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001111111111111111111111111111111111111111100000000011111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1077907042,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "1 month",
  "timestamp": 1697581017,
  "title": "Integer to Roman",
  "title_slug": "integer-to-roman",
  "url": "/submissions/detail/1077907042/"
}{
  "code": "class Solution {\n    public int trap(int[] r) {\n        int n = r.length;\n        int max = 0;\n        int sum = 0;\n        int [] left = new int[n];\n        int [] right = new int[n];\n        for (int i=0;i<n;i++){\n            if (r[i]>max){\n                max = r[i];\n                left[i] = 0;\n            } else{\n                left[i] = max- r[i];\n            }\n        }\n        max = 0;\n        for (int i=n-1;i>=0;i--){\n            if (r[i]>max){\n                max = r[i];\n                right[i] = 0;\n            }\n            else{\n                right[i] = max-r[i];\n            }\n        }\n        for (int i = 0;i<n;i++){\n            sum = sum + Integer.min(left[i],right[i]);\n        }\n        \n        return sum;\n        \n    }\n}",
  "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1077167694,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "44.3 MB",
  "runtime": "1 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697511241,
  "title": "Trapping Rain Water",
  "title_slug": "trapping-rain-water",
  "url": "/submissions/detail/1077167694/"
}{
  "code": "class Solution {\n    public int trap(int[] r) {\n        int n = r.length;\n        int max = 0;\n        int sum = 0;\n        int [] left = new int[n];\n        int [] right = new int[n];\n        for (int i=0;i<n;i++){\n            if (r[i]>max){\n                max = r[i];\n                // temp = i;\n                left[i] = 0;\n            } else{\n                left[i] = max- r[i];\n                // sum = sum + max-r[i];\n            }\n        }\n        max = 0;\n        for (int i=n-1;i>=0;i--){\n            if (r[i]>max){\n                max = r[i];\n                right[i] = 0;\n            }\n            else{\n                right[i] = max-r[i];\n            }\n        }\n        for (int i = 0;i<n;i++){\n            // System.out.println(left[i] + \" \" + right[i]);\n            sum = sum + Integer.min(left[i],right[i]);\n        }\n        \n        return sum;\n        \n    }\n}",
  "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1077164357,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "44.4 MB",
  "runtime": "1 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697510873,
  "title": "Trapping Rain Water",
  "title_slug": "trapping-rain-water",
  "url": "/submissions/detail/1077164357/"
}{
  "code": "class Solution {\n    public int trap(int[] r) {\n        int n = r.length;\n        int ind = 0;\n        int max = 0;\n        int sum = 0;\n        int min = Integer.MAX_VALUE;\n        int temp = -1;\n        int [] left = new int[n];\n        int [] right = new int[n];\n        for (int i=0;i<n;i++){\n            if (r[i]>max){\n                max = r[i];\n                // temp = i;\n                left[i] = 0;\n            } else{\n                left[i] = max- r[i];\n                // sum = sum + max-r[i];\n            }\n        }\n        max = 0;\n        for (int i=n-1;i>=0;i--){\n            if (r[i]>max){\n                max = r[i];\n                right[i] = 0;\n            }\n            else{\n                right[i] = max-r[i];\n            }\n        }\n        for (int i = 0;i<n;i++){\n            // System.out.println(left[i] + \" \" + right[i]);\n            sum = sum + Integer.min(left[i],right[i]);\n        }\n        \n        return sum;\n        \n    }\n}",
  "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1077163814,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "43.7 MB",
  "runtime": "1 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697510806,
  "title": "Trapping Rain Water",
  "title_slug": "trapping-rain-water",
  "url": "/submissions/detail/1077163814/"
}{
  "code": "class Solution {\n    public int[] productExceptSelf(int[] nums) {\n        int [] re = new int [nums.length];\n        // Array.fills(1);\n        int left = 1;\n        re[0] = 1;\n        for (int i = 1;i<nums.length;i++){\n            left = left*nums[i-1];\n            re[i] = left;\n        }\n        int right = 1;\n        for (int i = nums.length-2;i>=0;i--){\n            right = right*nums[i+1];\n            re [i] = re[i]*right;\n        }\n        return re;\n    }\n}",
  "compare_result": "1111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1077078915,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "52.9 MB",
  "runtime": "2 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697499422,
  "title": "Product of Array Except Self",
  "title_slug": "product-of-array-except-self",
  "url": "/submissions/detail/1077078915/"
}{
  "code": "class RandomizedSet {\n    HashMap<Integer,Integer> map;\n    ArrayList<Integer> list;\n    public RandomizedSet() {\n        map = new HashMap<>();\n        list= new ArrayList<>();\n    }\n    \n    public boolean insert(int val) {\n        if (map.containsKey(val)) return false;\n        map.put(val,list.size());\n        list.add(val);\n        return true;\n    }\n    \n    public boolean remove(int val) {\n        if (!map.containsKey(val)) return false;\n        int temp = list.remove(list.size()-1);\n        if (temp!=val){\n            list.set(map.get(val),temp);\n            map.put(temp,map.get(val));\n        }\n        map.remove(val);\n        return true;\n    }\n    \n    public int getRandom() {\n        return list.get(new Random().nextInt(list.size()));\n        \n    }\n}\n\n/**\n * Your RandomizedSet object will be instantiated and called as such:\n * RandomizedSet obj = new RandomizedSet();\n * boolean param_1 = obj.insert(val);\n * boolean param_2 = obj.remove(val);\n * int param_3 = obj.getRandom();\n */",
  "compare_result": "1111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1077076182,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "92.5 MB",
  "runtime": "29 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697499004,
  "title": "Insert Delete GetRandom O(1)",
  "title_slug": "insert-delete-getrandom-o1",
  "url": "/submissions/detail/1077076182/"
}{
  "code": "class RandomizedSet {\n    HashMap<Integer,Integer> map;\n    ArrayList<Integer> list;\n    public RandomizedSet() {\n        map = new HashMap<>();\n        list= new ArrayList<>();\n    }\n    \n    public boolean insert(int val) {\n        if (map.containsKey(val)) return false;\n        map.put(val,list.size());\n        list.add(val);\n        return true;\n    }\n    \n    public boolean remove(int val) {\n        if (!map.containsKey(val)) return false;\n        int temp = list.remove(list.size()-1);\n        if (temp!=val){\n            list.set(map.get(val),temp);\n            map.put(temp,map.get(val));\n        }\n        map.remove(val);\n        return true;\n    }\n    \n    public int getRandom() {\n        return list.get(new Random().nextInt(list.size()));\n        \n    }\n}\n\n/**\n * Your RandomizedSet object will be instantiated and called as such:\n * RandomizedSet obj = new RandomizedSet();\n * boolean param_1 = obj.insert(val);\n * boolean param_2 = obj.remove(val);\n * int param_3 = obj.getRandom();\n */",
  "compare_result": "1111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1077076084,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "84.9 MB",
  "runtime": "29 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697498992,
  "title": "Insert Delete GetRandom O(1)",
  "title_slug": "insert-delete-getrandom-o1",
  "url": "/submissions/detail/1077076084/"
}{
  "code": "class Solution {\n    public boolean canJump(int[] nums) {\n        int n = nums.length;\n        if (n==1) return true;\n        if (nums[0]==0) return false;\n        int max = 0;\n        for (int i=0;i<n;i++){\n            if (i>max) return false;\n            if (max<i+nums[i]) max = i+nums[i];\n        }\n        return true;\n\n        \n    }\n}",
  "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1077070761,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "44.2 MB",
  "runtime": "2 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697498205,
  "title": "Jump Game",
  "title_slug": "jump-game",
  "url": "/submissions/detail/1077070761/"
}{
  "code": "class Solution {\n    public int maxProfit(int[] prices) {\n        int count = 0;\n        int re = 0;\n        int ind = 0;\n        int n = prices.length;\n        while (ind<n){\n            while (ind <n-1 && prices[ind]>prices[ind+1]) ind++;\n            int temp = ind;\n            if (temp == n-1) break;\n            while (ind < n-1 && prices[ind]<=prices[ind+1]) ind++;\n            re = re + prices[ind] - prices[temp];\n            if (ind == n-1) break;\n            ind++;\n        }\n\n        return re;\n    }\n}",
  "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1077067643,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "43.6 MB",
  "runtime": "1 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697497759,
  "title": "Best Time to Buy and Sell Stock II",
  "title_slug": "best-time-to-buy-and-sell-stock-ii",
  "url": "/submissions/detail/1077067643/"
}{
  "code": "class Solution {\n    public void rotate(int[] nums, int k) {\n        k = k % nums.length;\n\t\trev(nums,0,nums.length-1);\n\t\trev(nums,0,k-1);\n\t\trev(nums,k,nums.length-1);\n    }\n    void rev(int [] nums, int x, int y) {\n\t\t\n\t\twhile (x< y) {\n\t\t\tint temp = nums[x];\n\t\t\tnums[x] = nums[y];\n\t\t\tnums[y] = temp;\n\t\t\tx ++;\n\t\t\ty --;\n\t\t}\n\t}\n}",
  "compare_result": "11111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1077062343,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "55.3 MB",
  "runtime": "0 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697496996,
  "title": "Rotate Array",
  "title_slug": "rotate-array",
  "url": "/submissions/detail/1077062343/"
}{
  "code": "class Solution {\n    public int romanToInt(String s) {\n        char [] c = s.toCharArray();\n        HashMap<Character,Integer> m = new HashMap<>();\n        m.put('I',1);\n        m.put('V',5);\n        m.put('X',10);\n        m.put('L',50);\n        m.put('C',100);\n        m.put('D',500);\n        m.put('M',1000);\n        int n = c.length;\n        int prev = 0;\n        int sum = 0;\n        for (int i = n-1;i>=0;i--){\n            int cur = m.get(c[i]);\n            if (cur>=prev) sum = sum+m.get(c[i]);\n            else sum = sum - m.get(c[i]);\n            prev= cur; \n        }\n        return sum;\n    }\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1077061850,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "43.4 MB",
  "runtime": "4 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697496929,
  "title": "Roman to Integer",
  "title_slug": "roman-to-integer",
  "url": "/submissions/detail/1077061850/"
}{
  "code": "class Solution {\n    public int removeDuplicates(int[] nums) {\n        int p1 = 0;\n        int n = nums.length;\n        int p2 = 0;\n        while (p2<n){\n            int count = 1;\n            while (p2<n-1&&nums[p2]==nums[p2+1]){\n                if (count<3)\n                {\n                    nums[p1] = nums[p2];\n                    p1++;\n                }                \n                count++;\n                p2++;\n            }\n            if (count<3){\n                nums[p1] = nums[p2];\n                p1++;\n                p2++;\n            } else{\n                p2++;\n            }\n\n        }\n        \n        return p1;       \n    }\n}",
  "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1077056614,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "44.1 MB",
  "runtime": "0 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697496200,
  "title": "Remove Duplicates from Sorted Array II",
  "title_slug": "remove-duplicates-from-sorted-array-ii",
  "url": "/submissions/detail/1077056614/"
}{
  "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    \n    int prev =-100001;\n    int min = Integer.MAX_VALUE;\n    public int minDiffInBST(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        minDiffInBST(root.left);\n        int val = root.val - prev;\n        if (val<min) min = val;\n        prev = root.val;\n        // System.out.println(root.val);\n        minDiffInBST(root.right);\n        \n        return min;\n        \n    }\n}",
  "compare_result": "1111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1077027033,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "39.9 MB",
  "runtime": "0 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697492248,
  "title": "Minimum Distance Between BST Nodes",
  "title_slug": "minimum-distance-between-bst-nodes",
  "url": "/submissions/detail/1077027033/"
}{
  "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int prev =-100001;\n    int min = Integer.MAX_VALUE;\n    public int getMinimumDifference(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        getMinimumDifference(root.left);\n        int val = root.val - prev;\n        if (val<min) min = val;\n        prev = root.val;\n        // System.out.println(root.val);\n        getMinimumDifference(root.right);\n        \n        return min;\n        \n    }\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1076542721,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "43.4 MB",
  "runtime": "0 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697448133,
  "title": "Minimum Absolute Difference in BST",
  "title_slug": "minimum-absolute-difference-in-bst",
  "url": "/submissions/detail/1076542721/"
}{
  "code": "class Solution {\n    public int searchInsert(int[] nums, int target) {\n        return search(nums,target,0,nums.length);\n    }\n    public int search(int [] nums, int t, int l, int r){\n        System.out.println(l+ \" \"+ r);\n        if (l<0) return 0;\n        if (r>nums.length) return nums.length;\n        if (l == r) return l;\n        if (l>r) return l;\n        int mid =  l + (r-l)/2;\n        if (nums[mid]<t) return search(nums,t,mid+1,r);\n        if (nums[mid]>t) return search(nums,t,l,mid-1);\n        return mid;\n\n    }\n}",
  "compare_result": "11111111101111011111111110111111001111110111111111111111111101111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1076521255,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "1 month, 1 week",
  "timestamp": 1697445813,
  "title": "Search Insert Position",
  "title_slug": "search-insert-position",
  "url": "/submissions/detail/1076521255/"
}{
  "code": "class Solution {\n    public int searchInsert(int[] nums, int target) {\n        return search(nums,target,0,nums.length);\n    }\n    public int search(int [] nums, int t, int l, int r){\n        System.out.println(l+ \" \"+ r);\n        if (l<0) return 0;\n        if (r>nums.length) return nums.length;\n        if (l>=r) return l;\n        int mid =  l + (r-l)/2;\n        if (nums[mid]<t) return search(nums,t,mid+1,r);\n        if (nums[mid]>t) return search(nums,t,l,mid-1);\n        return mid;\n\n    }\n}",
  "compare_result": "11111111101111011111111110111111001111110111111111111111111101111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1076521133,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "1 month, 1 week",
  "timestamp": 1697445797,
  "title": "Search Insert Position",
  "title_slug": "search-insert-position",
  "url": "/submissions/detail/1076521133/"
}{
  "code": "class Solution {\n    public int searchInsert(int[] nums, int target) {\n        return search(nums,target,0,nums.length);\n    }\n    public int search(int [] nums, int t, int l, int r){\n        System.out.println(l+ \" \"+ r);\n        if (l<0) return 0;\n        if (r>nums.length) return nums.length;\n        if (l>r) return l;\n        int mid =  l + (r-l)/2;\n        if (nums[mid]<t) return search(nums,t,mid+1,r);\n        if (nums[mid]>t) return search(nums,t,l,mid-1);\n        return mid;\n\n    }\n}",
  "compare_result": "11000000000000000000000000000000000000000000000000000000000000000",
  "flag_type": 1,
  "has_notes": false,
  "id": 1076521041,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 15,
  "status_display": "Runtime Error",
  "time": "1 month, 1 week",
  "timestamp": 1697445788,
  "title": "Search Insert Position",
  "title_slug": "search-insert-position",
  "url": "/submissions/detail/1076521041/"
}{
  "code": "class Solution {\n    public int searchInsert(int[] nums, int target) {\n        return search(nums,target,0,nums.length-1);\n    }\n    public int search(int [] nums, int t, int l, int r){\n        System.out.println(l+ \" \"+ r);\n        if (l>r) return l;\n        int mid =  l + (r-l)/2;\n        if (nums[mid]<t) return search(nums,t,mid+1,r);\n        if (nums[mid]>t) return search(nums,t,l,mid-1);\n        return mid;\n\n    }\n}",
  "compare_result": "11111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1076519550,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "43.8 MB",
  "runtime": "8 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697445626,
  "title": "Search Insert Position",
  "title_slug": "search-insert-position",
  "url": "/submissions/detail/1076519550/"
}{
  "code": "class Solution {\n    public int searchInsert(int[] nums, int target) {\n        return search(nums,target,0,nums.length);\n    }\n    public int search(int [] nums, int t, int l, int r){\n        System.out.println(l+ \" \"+ r);\n        if (r>nums.length) return nums.length;\n        if (l == r) return l;\n        if (l>r) return l;\n        int mid =  l + (r-l)/2;\n        if (nums[mid]<t) return search(nums,t,mid+1,r);\n        if (nums[mid]>t) return search(nums,t,l,mid-1);\n        return mid;\n\n    }\n}",
  "compare_result": "11111111101111011111111110111111001111110111111111111111111101111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1076519066,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "1 month, 1 week",
  "timestamp": 1697445573,
  "title": "Search Insert Position",
  "title_slug": "search-insert-position",
  "url": "/submissions/detail/1076519066/"
}{
  "code": "class Solution {\n    public int searchInsert(int[] nums, int target) {\n        return search(nums,target,0,nums.length);\n    }\n    public int search(int [] nums, int t, int l, int r){\n        System.out.println(l+ \" \"+ r);\n        if (l<0) return 0;\n        if (r>nums.length) return nums.length;\n        if (l == r) return l;\n        if (l>r) return l;\n        int mid =  l + (r-l)/2;\n        if (nums[mid]<t) return search(nums,t,mid+1,r);\n        if (nums[mid]>t) return search(nums,t,l,mid-1);\n        return mid;\n\n    }\n}",
  "compare_result": "11111111101111011111111110111111001111110111111111111111111101111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1076517979,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "1 month, 1 week",
  "timestamp": 1697445450,
  "title": "Search Insert Position",
  "title_slug": "search-insert-position",
  "url": "/submissions/detail/1076517979/"
}{
  "code": "class Solution {\n    public int searchInsert(int[] nums, int target) {\n        return search(nums,target,0,nums.length);\n    }\n    public int search(int [] nums, int t, int l, int r){\n        System.out.println(l+ \" \"+ r);\n        if (l<0) return 0;\n        if (r>nums.length) return nums.length;\n        if (l == r) return l;\n        if (l>r) return r;\n        int mid =  l + (r-l)/2;\n        if (nums[mid]<t) return search(nums,t,mid+1,r);\n        if (nums[mid]>t) return search(nums,t,l,mid-1);\n        return mid;\n\n    }\n}",
  "compare_result": "11100111101111010110111010101111001111110111111111010111111101101",
  "flag_type": 1,
  "has_notes": false,
  "id": 1076517629,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "1 month, 1 week",
  "timestamp": 1697445414,
  "title": "Search Insert Position",
  "title_slug": "search-insert-position",
  "url": "/submissions/detail/1076517629/"
}{
  "code": "class Solution {\n    public int searchInsert(int[] nums, int target) {\n        return search(nums,target,0,nums.length);\n    }\n    public int search(int [] nums, int t, int l, int r){\n        System.out.println(l+ \" \"+ r);\n        if (l == r) return l;\n        if (l>r) return r;\n        int mid =  l + (r-l)/2;\n        if (nums[mid]<t) return search(nums,t,mid+1,r);\n        if (nums[mid]>t) return search(nums,t,l,mid-1);\n        return mid;\n\n    }\n}",
  "compare_result": "11100111101111010110111010101111001111110111111111010111111101101",
  "flag_type": 1,
  "has_notes": false,
  "id": 1076517020,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "1 month, 1 week",
  "timestamp": 1697445350,
  "title": "Search Insert Position",
  "title_slug": "search-insert-position",
  "url": "/submissions/detail/1076517020/"
}{
  "code": "class Solution {\n    public int singleNumber(int[] nums) {\n        int re = 0;\n        for (int i: nums) re = re^i;\n        return re;\n    }\n}",
  "compare_result": "1111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1076489271,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "44.3 MB",
  "runtime": "1 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697442082,
  "title": "Single Number",
  "title_slug": "single-number",
  "url": "/submissions/detail/1076489271/"
}{
  "code": "class Solution {\n    public boolean isPalindrome(int x) {\n        if (x<0) return false;\n        return x == rev(x);\n    }\n    public int rev(int x){\n        int re = 0;\n        \n        while (x!=0){\n            re = 10*re + x %10;\n            x = x/10;\n        }\n        return re;\n    }\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1076486538,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "42.7 MB",
  "runtime": "5 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697441777,
  "title": "Palindrome Number",
  "title_slug": "palindrome-number",
  "url": "/submissions/detail/1076486538/"
}{
  "code": "class Solution {\n    public int[] plusOne(int[] digits) {\n        int n = digits.length;\n        LinkedList<Integer> re = new LinkedList<>();\n        int i = n-1;\n        int left = 1;\n        while (i>=0){\n            if (digits[i] + left >9 ){\n                left = 1;\n                re.addFirst(0);\n            } else{\n                re.addFirst(digits[i]+left);\n                left = 0;\n            }\n            i--;\n        }\n        if (left==1) re.addFirst(1);\n        int re1 [] = new int[re.size()];\n        int count = 0;\n        for (int val:re){\n            re1[count] = val;\n            count++;\n        }\n        return re1;\n    }\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1076485171,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "41.1 MB",
  "runtime": "1 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697441614,
  "title": "Plus One",
  "title_slug": "plus-one",
  "url": "/submissions/detail/1076485171/"
}{
  "code": "class Solution {\n    public int[] plusOne(int[] digits) {\n        int n = digits.length;\n        LinkedList<Integer> re = new LinkedList<>();\n        int i = n-1;\n        int left = 1;\n        while (i>=0){\n            if (digits[i] + left >9 ){\n                left = 1;\n                re.addFirst(0);\n            } else{\n                re.addFirst(digits[i]+left);\n                left = 0;\n            }\n            i--;\n        }\n        if (left==1) re.addFirst(1);\n        int re1 [] = new int[re.size()];\n        int count = 0;\n        for (int val:re){\n            re1[count] = val;\n            count++;\n        }\n        return re1;\n    }\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1076485095,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "41.2 MB",
  "runtime": "1 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697441605,
  "title": "Plus One",
  "title_slug": "plus-one",
  "url": "/submissions/detail/1076485095/"
}{
  "code": "class Solution {\n    public int mySqrt(int x) {\n        long r = x;\n        while (r*r > x)\n            r = (r + x/r) / 2;\n        return (int) r;\n    }\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1076478896,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "40.2 MB",
  "runtime": "1 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697440925,
  "title": "Sqrt(x)",
  "title_slug": "sqrtx",
  "url": "/submissions/detail/1076478896/"
}{
  "code": "class Solution {\n    public int maxProfit(int[] prices) {\n        int runMin = Integer.MAX_VALUE;\n        int max = 0;\n        for (int i:prices){\n            if (i>runMin){\n                if (i-runMin > max) max = i - runMin;\n            }\n            if (i<runMin){\n                runMin = i;\n            }\n        }\n        return max;\n    }\n}",
  "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1076469419,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "61.6 MB",
  "runtime": "2 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697439960,
  "title": "Best Time to Buy and Sell Stock",
  "title_slug": "best-time-to-buy-and-sell-stock",
  "url": "/submissions/detail/1076469419/"
}{
  "code": "class Solution {\n    public int majorityElement(int[] nums) {\n        int candidate = 0;\n        int freq = 0;\n        for (int i: nums){\n            if (i!=candidate) freq--;\n            else freq++;\n            if (freq<0) {\n                candidate = i;\n                freq = 1;\n            }\n\n        }\n        return candidate;\n        \n    }\n}",
  "compare_result": "111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1076465295,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "48.2 MB",
  "runtime": "1 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697439566,
  "title": "Majority Element",
  "title_slug": "majority-element",
  "url": "/submissions/detail/1076465295/"
}{
  "code": "class Solution {\n    public int removeDuplicates(int[] nums) {\n        int p1 = 0;\n        int n = nums.length;\n        int p2 = 0;\n        while (p2<n){\n            while (p2<n-1 && nums[p2]==nums[p2+1]){\n                p2++;\n            } \n            nums[p1] = nums[p2];\n            p1++;\n            p2++;\n        }\n        return p1;\n\n        \n    }\n}",
  "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1076461449,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "44 MB",
  "runtime": "1 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697439202,
  "title": "Remove Duplicates from Sorted Array",
  "title_slug": "remove-duplicates-from-sorted-array",
  "url": "/submissions/detail/1076461449/"
}{
  "code": "class Solution {\n    public int removeDuplicates(int[] nums) {\n        int p1 = 0;\n        int n = nums.length;\n        int p2 = 0;\n        // int count = 0;\n        while (p2<n){\n            while (p2<n-1 && nums[p2]==nums[p2+1]){\n                p2++;\n            } \n            System.out.println(p1 +\" \" + p2);\n\n            nums[p1] = nums[p2];\n            p1++;\n            p2++;\n            // count++;\n        }\n        // System.out.println(p1);\n        return p1;\n\n        \n    }\n}",
  "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1076461200,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "46.3 MB",
  "runtime": "23 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697439179,
  "title": "Remove Duplicates from Sorted Array",
  "title_slug": "remove-duplicates-from-sorted-array",
  "url": "/submissions/detail/1076461200/"
}{
  "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n\n    public boolean hasPathSum(TreeNode root, int targetSum) {\n        if (root == null){\n            return false;\n        }\n        return hasPathSum1(root, targetSum);        \n    }\n    public boolean hasPathSum1(TreeNode root, int targetSum) {\n        if (root == null){\n            if (targetSum == 0) return true;\n            return false;\n        }\n        if (root.left == null) return hasPathSum1(root.right, targetSum-root.val);\n        if (root.right == null) return hasPathSum1(root.left, targetSum-root.val);\n\n        return hasPathSum1(root.left, targetSum-root.val) || hasPathSum1(root.right, targetSum-root.val);        \n    }\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1076454742,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "43 MB",
  "runtime": "0 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697438589,
  "title": "Path Sum",
  "title_slug": "path-sum",
  "url": "/submissions/detail/1076454742/"
}{
  "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n\n    public boolean hasPathSum(TreeNode root, int targetSum) {\n        if (root == null){\n            return false;\n        }\n        return hasPathSum1(root, targetSum);        \n    }\n    public boolean hasPathSum1(TreeNode root, int targetSum) {\n        if (root == null){\n            if (targetSum == 0) return true;\n            return false;\n        }\n        return hasPathSum1(root.left, targetSum-root.val) || hasPathSum1(root.right, targetSum-root.val);        \n    }\n}",
  "compare_result": "111111110111011111111101011101011111111010111101111111101111111011111111101111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1076452529,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "1 month, 1 week",
  "timestamp": 1697438380,
  "title": "Path Sum",
  "title_slug": "path-sum",
  "url": "/submissions/detail/1076452529/"
}{
  "code": "class Solution {\n    public int removeElement(int[] nums, int val) {\n        int count = 0;\n        int n = nums.length;\n        for (int i = 0;i<n;i++){\n            if (nums[i]!=val){\n                nums[count] = nums[i];\n                count++;\n            }\n        }\n        return count;\n    }\n}",
  "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1076449732,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "40.4 MB",
  "runtime": "0 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697438109,
  "title": "Remove Element",
  "title_slug": "remove-element",
  "url": "/submissions/detail/1076449732/"
}{
  "code": "class Solution {\n    public int removeElement(int[] nums, int val) {\n        int count = 0;\n        int n = nums.length;\n        for (int i=0;i<n;i++){\n            if (nums[i] != val){\n                count++;\n            }\n        }\n        for (int i = 0; i< n-1;i++){\n            if (nums[i] == val){\n                for (int j=i+1;j<n;j++){\n                    if (nums[j]!= val){\n                        nums[i] = nums[j];\n                        nums[j] = val;\n                        break;\n                    }\n                }\n            }\n        }\n        return count;\n    }\n}",
  "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1076447445,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "40.9 MB",
  "runtime": "0 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697437883,
  "title": "Remove Element",
  "title_slug": "remove-element",
  "url": "/submissions/detail/1076447445/"
}{
  "code": "class Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        int p1 = m - 1;\n        int p2 = n-1;\n        int p = n+m-1;\n        while (p1>=0 && p2>=0){\n            \n            if (nums1[p1]>nums2[p2]){\n                nums1[p] = nums1[p1];\n                p1--;\n                p--;\n            } else if (nums2[p2]>nums1[p1]){\n                nums1[p] = nums2[p2];\n                p2--;\n                p--;\n            } else{\n                nums1[p] = nums1[p1];\n                p1--;\n                p--;\n                nums1[p] = nums2[p2];\n                p2--;\n                p--;\n            }\n        }\n        while (p2>=0){\n            nums1[p] = nums2[p2];\n            p2--;\n            p--;\n        } \n        while (p1>=0){\n            nums1[p] = nums1[p1];\n            p1--;\n            p--;\n        } \n        \n    }\n}",
  "compare_result": "11111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1076439592,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "40.6 MB",
  "runtime": "0 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697437150,
  "title": "Merge Sorted Array",
  "title_slug": "merge-sorted-array",
  "url": "/submissions/detail/1076439592/"
}{
  "code": "class Solution {\n    HashSet<String> set ;\n    HashSet<String> notSet ;\n\n    public boolean wordBreak(String s, List<String> wordDict) {\n        set= new HashSet<>(wordDict);\n        notSet= new HashSet<>();\n        if (set.contains(s)) return true;\n        return check(s);\n        \n    }\n\n    boolean check(String s){\n        // if (index >= s.length) return true;\n        if (s==\"\") return true;\n        if (set.contains(s)) return true;\n        if (notSet.contains(s)) return false;\n        for (String si: set){\n            if (s.startsWith(si)){\n                // System.out.println(si+\" \"+s.substring(si.length()));\n                if (check(s.substring(si.length()))) return true;\n                else notSet.add(s);\n            }\n        }\n        if (!notSet.contains(s))\n            notSet.add(s);\n        return false;\n    }\n}",
  "compare_result": "1111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1076420906,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "40.6 MB",
  "runtime": "2 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697435382,
  "title": "Word Break",
  "title_slug": "word-break",
  "url": "/submissions/detail/1076420906/"
}{
  "code": "class Solution {\n    HashSet<String> set ;\n    HashSet<String> notSet ;\n\n    public boolean wordBreak(String s, List<String> wordDict) {\n        set= new HashSet<>(wordDict);\n        notSet= new HashSet<>();\n        if (set.contains(s)) return true;\n        return check(s);\n        \n    }\n\n    boolean check(String s){\n        // if (index >= s.length) return true;\n        if (s==\"\") return true;\n        if (set.contains(s)) return true;\n        if (notSet.contains(s)) return false;\n        for (String si: set){\n            if (s.startsWith(si)){\n                // System.out.println(si+\" \"+s.substring(si.length()));\n                if (check(s.substring(si.length()))) return true;\n                else notSet.add(s);\n            }\n        }\n        notSet.add(s);\n        return false;\n    }\n}",
  "compare_result": "1111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1076420656,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "40.9 MB",
  "runtime": "3 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697435360,
  "title": "Word Break",
  "title_slug": "word-break",
  "url": "/submissions/detail/1076420656/"
}{
  "code": "class Solution {\n    HashSet<String> set ;\n    HashSet<String> notSet ;\n\n    public boolean wordBreak(String s, List<String> wordDict) {\n        set= new HashSet<>(wordDict);\n        notSet= new HashSet<>();\n        if (set.contains(s)) return true;\n        return check(s);\n        \n    }\n\n    boolean check(String s){\n        // if (index >= s.length) return true;\n        if (s==\"\") return true;\n        if (set.contains(s)) return true;\n        if (notSet.contains(s)) return false;\n        for (String si: set){\n            if (s.startsWith(si)){\n                // System.out.println(si+\" \"+s.substring(si.length()));\n                if (check(s.substring(si.length()))) return true;\n                else notSet.add(s);\n            }\n        }\n        return false;\n    }\n}",
  "compare_result": "1111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1076419392,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "41.3 MB",
  "runtime": "2 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697435244,
  "title": "Word Break",
  "title_slug": "word-break",
  "url": "/submissions/detail/1076419392/"
}{
  "code": "class Solution {\n    HashSet<String> set ;\n\n    public boolean wordBreak(String s, List<String> wordDict) {\n        set= new HashSet<>(wordDict);\n        // notSet= new HashSet<>();\n        if (set.contains(s)) return true;\n        return check(s);\n        \n    }\n\n    boolean check(String s){\n        // if (index >= s.length) return true;\n        if (s==\"\") return true;\n        if (set.contains(s)) return true;\n        for (String si: set){\n            if (s.startsWith(si)){\n                // System.out.println(si+\" \"+s.substring(si.length()));\n                if (check(s.substring(si.length()))) return true;\n            }\n        }\n        return false;\n    }\n}",
  "compare_result": "1111111111111111111111111111111111100000000000",
  "flag_type": 1,
  "has_notes": false,
  "id": 1076417033,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 14,
  "status_display": "Time Limit Exceeded",
  "time": "1 month, 1 week",
  "timestamp": 1697435024,
  "title": "Word Break",
  "title_slug": "word-break",
  "url": "/submissions/detail/1076417033/"
}{
  "code": "class Solution {\n    HashSet<String> set ;\n    HashSet<String> notSet;\n    public boolean wordBreak(String s, List<String> wordDict) {\n        set= new HashSet<>(wordDict);\n        notSet= new HashSet<>();\n\n        if (set.contains(s)) return true;\n        \n\n        return check(s);\n        \n    }\n\n    boolean check(String s){\n        if (set.contains(s)) return true;\n        if (notSet.contains(s)) return false;\n        for (int i = 1;i<s.length();i++){\n            String sl = s.substring(0,i);\n            String sr = s.substring(i,s.length());\n            // System.out.println\n            boolean left = check(sl);\n            if (left) set.add(sl);\n            else notSet.add(sl);\n            boolean right = check(sr);\n            if (right) set.add(sr);\n            else notSet.add(sr);\n            if (left && right) return true;\n        }\n        return false;\n    }\n}",
  "compare_result": "1111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1076389096,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "45.7 MB",
  "runtime": "379 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697432228,
  "title": "Word Break",
  "title_slug": "word-break",
  "url": "/submissions/detail/1076389096/"
}{
  "code": "class Solution {\n    HashSet<String> set ;\n    public boolean wordBreak(String s, List<String> wordDict) {\n        set= new HashSet<>(wordDict);\n        if (set.contains(s)) return true;\n        \n\n        return check(s);\n        \n    }\n\n    boolean check(String s){\n        if (set.contains(s)) return true;\n        for (int i = 1;i<s.length();i++){\n            String sl = s.substring(0,i);\n            String sr = s.substring(i,s.length());\n            // System.out.println\n            boolean left = check(sl);\n            if (left) set.add(sl);\n            boolean right = check(sr);\n            if (right) set.add(sr);\n            if (left && right) return true;\n        }\n        return false;\n    }\n}",
  "compare_result": "1111111111111111111111111111111111000000000000",
  "flag_type": 1,
  "has_notes": false,
  "id": 1076387672,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 14,
  "status_display": "Time Limit Exceeded",
  "time": "1 month, 1 week",
  "timestamp": 1697432089,
  "title": "Word Break",
  "title_slug": "word-break",
  "url": "/submissions/detail/1076387672/"
}{
  "code": "class Solution {\n    HashSet<String> set ;\n    public boolean wordBreak(String s, List<String> wordDict) {\n        set= new HashSet<>(wordDict);\n        if (set.contains(s)) return true;\n        \n\n        return check(s);\n        \n    }\n\n    boolean check(String s){\n        if (set.contains(s)) return true;\n        for (int i = 1;i<s.length()-1;i++){\n            String sl = s.substring(0,i);\n            String sr = s.substring(i,s.length());\n            boolean left = check(sl);\n            if (left) set.add(sl);\n            boolean right = check(sr);\n            if (right) set.add(sr);\n            if (left && right) return true;\n        }\n        return false;\n    }\n}",
  "compare_result": "1111100101111111111111111111011111000000000000",
  "flag_type": 1,
  "has_notes": false,
  "id": 1076386858,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "1 month, 1 week",
  "timestamp": 1697432009,
  "title": "Word Break",
  "title_slug": "word-break",
  "url": "/submissions/detail/1076386858/"
}{
  "code": "class Solution {\n    public int rob(int[] nums) {\n        int n = nums.length;\n        if (n==1) return nums[0];\n        if (n==2) return Integer.max(nums[0],nums[1]);;\n        int [] dp = new int [n];\n        dp[0] = nums[0];\n        dp[1] = Integer.max(nums[0],nums[1]);\n        for (int i = 2;i<n;i++){\n            dp[i]= Integer.max(dp[i-2]+nums[i],dp[i-1]);\n        }\n        return dp[n-1];\n    }\n}",
  "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1076333570,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "40.3 MB",
  "runtime": "0 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697426031,
  "title": "House Robber",
  "title_slug": "house-robber",
  "url": "/submissions/detail/1076333570/"
}{
  "code": "class Solution {\n    public int rob(int[] nums) {\n        int n = nums.length;\n        int [] dp = new int [n];\n        dp[0] = nums[0];\n        dp[1] = Integer.max(nums[0],nums[1]);\n        for (int i = 2;i<n;i++){\n            dp[i]= Integer.max(dp[i-2]+nums[i],dp[i-1]);\n        }\n        return dp[n-1];\n    }\n}",
  "compare_result": "1100000000000000000000000000000000000000000000000000000000000000000000",
  "flag_type": 1,
  "has_notes": false,
  "id": 1076333037,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 15,
  "status_display": "Runtime Error",
  "time": "1 month, 1 week",
  "timestamp": 1697425966,
  "title": "House Robber",
  "title_slug": "house-robber",
  "url": "/submissions/detail/1076333037/"
}{
  "code": "class Solution {\n    public int climbStairs(int n) {\n        if (n<=2) return n;\n        int a = 1;\n        int b = 2;\n        int c = 2;\n        int count = 2;\n        while (count<n){\n            count++;\n            c = a + b;\n            a = b;\n            b = c;\n        }\n        return c;\n        \n    }\n}",
  "compare_result": "111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1076330917,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "39.2 MB",
  "runtime": "0 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697425703,
  "title": "Climbing Stairs",
  "title_slug": "climbing-stairs",
  "url": "/submissions/detail/1076330917/"
}{
  "code": "class Solution {\n    int [] dp;\n    public int candy(int[] r) {\n        int n = r.length;\n        int []left = new int[n];\n        int [] right = new int [n];        \n        int sum = 0;\n        left [0] = 1;\n        for (int i=1;i<n;i++){\n            if (r[i]>r[i-1]) left[i] = left[i-1]+1;\n            else left[i] = 1;\n        }\n        right[n-1] = 1;\n        for (int i=n-2;i>=0;i--){\n            if (r[i]>r[i+1]) right[i] = right[i+1]+1;\n            else right[i] = 1;\n        }\n        for (int i = 0; i<n;i++){\n            // System.out.println(left[i] + \" \"+ right[i]);\n            sum = sum + Integer.max(left[i],right[i]);\n        }\n        \n        return sum;\n\n    }\n\n    // public int getCandy(int x, int[] ratings){\n    //     System.out.println(x);\n    //     if (x<=0) return 0;\n    //     if (x>=dp.length-1) return 0;\n    //     if (dp[x]!=0) return dp[x];\n    //     if (ratings[x]<ratings[x-1] && ratings[x]<ratings[x+1]) return 1;\n    //     // int min = Integer.min(getCandy(x-1,ratings),getCandy(x+1,ratings))+1;\n    //     int a = getCandy(x-1,ratings);\n    //     int b = getCandy(x+1,ratings);\n    //     int min = Integer.min(a,b)+1;\n    //     dp[x] = min;\n    //     return min;\n    // }\n}",
  "compare_result": "111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1076327826,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "43.2 MB",
  "runtime": "3 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697425307,
  "title": "Candy",
  "title_slug": "candy",
  "url": "/submissions/detail/1076327826/"
}{
  "code": "class Solution {\n    public int canCompleteCircuit(int[] gas, int[] cost) {\n\n        \n        int g = 0;\n        int c = 0;\n        for (int i: gas){\n            g= g + i;\n        }\n        for (int i:cost){\n            c = c+i;\n        }\n        if (g<c) return -1;\n        int n = gas.length;\n        int a [] = new int [n];\n        for (int i=0;i<n;i++){\n            a[i] = gas[i] - cost[i];\n        }\n        int start = 0;\n        int runSum = 0;\n        for (int i = 0; i< n ; i++){\n            runSum = runSum+a[i];\n            if (runSum<0){\n                start = i+1;\n                runSum=0;\n            }\n            // System.out.println(start+\" \"+runSum);\n\n        }\n        // for (int i: a){\n        //     System.out.print(i +\" \");\n\n        // }\n        // System.out.println();\n        \n\n        return start;\n        \n    }\n\n    \n}",
  "compare_result": "1111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1075591421,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "61.3 MB",
  "runtime": "2 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697346572,
  "title": "Gas Station",
  "title_slug": "gas-station",
  "url": "/submissions/detail/1075591421/"
}{
  "code": "class Solution {\n    public int canCompleteCircuit(int[] gas, int[] cost) {\n        int g = 0;\n        int c = 0;\n        for (int i: gas){\n            g= g + i;\n        }\n        for (int i:cost){\n            c = c+i;\n        }\n        if (g<c) return -1;\n        int n = gas.length;\n        int a [] = new int [n];\n        for (int i=0;i<n;i++){\n            a[i] = gas[i] - cost[i];\n        }\n        int start =0;\n        while (a[start]*a[start+1]>=0){\n            start++;\n        }\n        start = start + 1;\n        int count = start;\n        boolean check = false;\n        int runSum = 0;\n        int max = 0;\n        int res = 0;\n        for (int i: a){\n            System.out.print(i +\" \");\n\n        }\n        System.out.println();\n        while (!check){\n            if (a[count]>=0){\n                int temp = count;\n                runSum = 0;\n                while (a[count]>=0){\n                    runSum=runSum+a[count];\n                    count++;\n                    if (count >=n) count =0;\n                    if (count == start) check = true;\n\n                }\n                if (runSum> max) {\n                    max = runSum;\n                    res = temp;\n                }\n\n            }\n            // System.out.println(count+\" \"+runSum);\n            count++;\n            if (count >=n) count =0;\n            if (count == start) check = true;\n\n        }\n        System.out.println(start+\" \"+max);\n\n        return res;\n        \n    }\n\n    \n}",
  "compare_result": "1111101111111111100000000000000000000000",
  "flag_type": 1,
  "has_notes": false,
  "id": 1075584351,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "1 month, 1 week",
  "timestamp": 1697345870,
  "title": "Gas Station",
  "title_slug": "gas-station",
  "url": "/submissions/detail/1075584351/"
}{
  "code": "class Solution {\n    public int canCompleteCircuit(int[] gas, int[] cost) {\n        int g = 0;\n        int c = 0;\n        for (int i: gas){\n            g= g + i;\n        }\n        for (int i:cost){\n            c = c+i;\n        }\n        if (g<c) return -1;\n        int n = gas.length;\n        int a [] = new int [n];\n        for (int i=0;i<n;i++){\n            a[i] = gas[i] - cost[i];\n        }\n        int start =0;\n        while (a[start]*a[start+1]>=0){\n            start++;\n        }\n        start = start + 1;\n        int count = start;\n        boolean check = false;\n        int runSum = 0;\n        int max = 0;\n        int res = 0;\n        for (int i: a){\n            System.out.print(i +\" \");\n\n        }\n        System.out.println();\n        while (!check){\n            if (a[count]>=0){\n                int temp = count;\n                while (a[count]>=0){\n                    runSum=runSum+a[count];\n                    count++;\n                    if (count >=n) count =0;\n                    if (count == start) check = true;\n\n                }\n                if (runSum> max) {\n                    max = runSum;\n                    res = temp;\n                }\n\n            }\n            // System.out.println(count+\" \"+runSum);\n            count++;\n            if (count >=n) count =0;\n            if (count == start) check = true;\n\n        }\n        // System.out.println(start);\n\n        return res;\n        \n    }\n\n    \n}",
  "compare_result": "1111111111111110100000000000000000000000",
  "flag_type": 1,
  "has_notes": false,
  "id": 1075582880,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "1 month, 1 week",
  "timestamp": 1697345731,
  "title": "Gas Station",
  "title_slug": "gas-station",
  "url": "/submissions/detail/1075582880/"
}{
  "code": "class Solution {\n    public int canCompleteCircuit(int[] gas, int[] cost) {\n        int g = 0;\n        int c = 0;\n        for (int i: gas){\n            g= g + i;\n        }\n        for (int i:cost){\n            c = c+i;\n        }\n        if (g<c) return -1;\n        int n = gas.length;\n        int a [] = new int [n];\n        for (int i=0;i<n;i++){\n            a[i] = gas[i] - cost[i];\n        }\n        int start =0;\n        while (a[start]*a[start+1]>=0){\n            start++;\n        }\n        start = start + 1;\n        int count = start;\n        boolean check = false;\n        int runSum = 0;\n        int max = 0;\n        int res = 0;\n        while (!check){\n            if (a[count]>=0){\n                int temp = count;\n                while (a[count]>=0){\n                    runSum=runSum+a[count];\n                    count++;\n                    if (count >=n) count =0;\n                    if (count == start) check = true;\n\n                }\n                if (runSum> max) {\n                    max = runSum;\n                    res = temp;\n                }\n\n            }\n            // System.out.println(count+\" \"+runSum);\n            count++;\n            if (count >=n) count =0;\n            if (count == start) check = true;\n\n        }\n        // System.out.println(start);\n\n        return res;\n        \n    }\n\n    \n}",
  "compare_result": "1111111111111110100000000000000000000000",
  "flag_type": 1,
  "has_notes": false,
  "id": 1075582236,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "1 month, 1 week",
  "timestamp": 1697345664,
  "title": "Gas Station",
  "title_slug": "gas-station",
  "url": "/submissions/detail/1075582236/"
}{
  "code": "class Solution {\n    public int canCompleteCircuit(int[] gas, int[] cost) {\n        int g = 0;\n        int c = 0;\n        for (int i: gas){\n            g= g + i;\n        }\n        for (int i:cost){\n            c = c+i;\n        }\n        if (g<c) return -1;\n        int n = gas.length;\n        int a [] = new int [n];\n        for (int i=0;i<n;i++){\n            a[i] = gas[i] - cost[i];\n        }\n        int start =0;\n        while (a[start]*a[start+1]>=0){\n            start++;\n        }\n        start = start + 1;\n        int count = start;\n        boolean check = false;\n        int runSum = 0;\n        int max = 0;\n        int res = 0;\n        while (!check){\n            if (a[count]>=0){\n                int temp = count;\n                while (a[count]>=0){\n                    runSum=runSum+a[count];\n                    count++;\n                    if (count >=n) count =0;\n                }\n                if (runSum> max) {\n                    max = runSum;\n                    res = temp;\n                }\n\n            }\n            // System.out.println(count+\" \"+runSum);\n            count++;\n            if (count >=n) count =0;\n            if (count == start) check = true;\n\n        }\n        // System.out.println(start);\n\n        return res;\n        \n    }\n\n    \n}",
  "compare_result": "1110000000000000000000000000000000000000",
  "flag_type": 1,
  "has_notes": false,
  "id": 1075581822,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 14,
  "status_display": "Time Limit Exceeded",
  "time": "1 month, 1 week",
  "timestamp": 1697345620,
  "title": "Gas Station",
  "title_slug": "gas-station",
  "url": "/submissions/detail/1075581822/"
}{
  "code": "class Solution {\n    public int canCompleteCircuit(int[] gas, int[] cost) {\n        int g = 0;\n        int c = 0;\n        for (int i: gas){\n            g= g + i;\n        }\n        for (int i:cost){\n            c = c+i;\n        }\n        if (g<c) return -1;\n        int n = gas.length;\n        int a [] = new int [n];\n        for (int i=0;i<n;i++){\n            a[i] = gas[i] - cost[i];\n        }\n        int start =0;\n        while (a[start]*a[start+1]>=0){\n            start++;\n        }\n        start = start + 1;\n        int count = start;\n        boolean check = false;\n        int runSum = 0;\n        int max = 0;\n        int res = 0;\n        while (!check){\n            if (a[count]>=0){\n                int temp = count;\n                while (a[count]>=0){\n                    runSum=runSum+a[count];\n                    count++;\n                    if (count >=n) count =0;\n                }\n                if (runSum> max) {\n                    max = runSum;\n                    res = temp;\n                }\n\n            }\n            // System.out.println(count+\" \"+runSum);\n            count++;\n            if (count >=n) count =0;\n            if (count == start) check = true;\n\n        }\n        // System.out.println(start);\n\n        return res;\n        \n    }\n\n    \n}",
  "compare_result": "1110000000000000000000000000000000000000",
  "flag_type": 1,
  "has_notes": false,
  "id": 1075581621,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 14,
  "status_display": "Time Limit Exceeded",
  "time": "1 month, 1 week",
  "timestamp": 1697345599,
  "title": "Gas Station",
  "title_slug": "gas-station",
  "url": "/submissions/detail/1075581621/"
}{
  "code": "class Solution {\n    public int canCompleteCircuit(int[] gas, int[] cost) {\n        int g = 0;\n        int c = 0;\n        for (int i: gas){\n            g= g + i;\n        }\n        for (int i:cost){\n            c = c+i;\n        }\n        if (g<c) return -1;\n        int n = gas.length;\n        int a [] = new int [n];\n        for (int i=0;i<n;i++){\n            a[i] = gas[i] - cost[i];\n        }\n        int start =0;\n        while (a[start]*a[start+1]>=0){\n            start++;\n        }\n        start = start + 1;\n        int count = start;\n        boolean check = false;\n        int runSum = 0;\n        int max = 0;\n        int res = 0;\n        while (!check){\n            if (a[count]>=0){\n                int temp = count;\n                while (a[count]>=0){\n                    runSum=runSum+a[count];\n                    count++;\n                    if (count >=n) count =0;\n                }\n                if (runSum> max) {\n                    max = runSum;\n                    res = temp;\n                }\n\n            }\n            System.out.println(count+\" \"+runSum);\n            count++;\n            if (count >=n) count =0;\n            if (count == start) check = true;\n\n        }\n        // System.out.println(start);\n\n        return res;\n        \n    }\n\n    \n}",
  "compare_result": "1110000000000000000000000000000000000000",
  "flag_type": 1,
  "has_notes": false,
  "id": 1075581447,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 13,
  "status_display": "Output Limit Exceeded",
  "time": "1 month, 1 week",
  "timestamp": 1697345583,
  "title": "Gas Station",
  "title_slug": "gas-station",
  "url": "/submissions/detail/1075581447/"
}{
  "code": "class Solution {\n    public int coinChange(int[] coins, int amount) {\n        if (amount == 0) return 0;\n        int [] dp = new int[amount+1];\n        HashSet<Integer> set = new HashSet<>();\n        dp[0] = 0;\n        for (int i=1;i<=amount;i++){\n            dp[i] = Integer.MAX_VALUE;\n        }\n        for (int i : coins){\n            if (i<=amount){\n                dp[i] = 1;\n                set.add(i);\n            }\n            \n        }\n\n        for (int i = 1;i<=amount; i++){\n            int min = dp[i];\n            for (int coin: coins){\n                if (i>coin){\n                    if (dp[i-coin]!=Integer.MAX_VALUE)\n                        if (dp[i-coin]+1 < min) min = dp[i-coin] +1;\n                }\n            }\n            if (min!=Integer.MAX_VALUE)\n                dp[i] = min;\n            \n        }\n        // for (int i = 0; i<=amount;i++){\n        //     System.out.println(i+\" \"+dp[i]);\n        // }\n\n        return dp[amount]!=Integer.MAX_VALUE?dp[amount]:-1;\n        \n    }\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1075232509,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "43 MB",
  "runtime": "16 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697309659,
  "title": "Coin Change",
  "title_slug": "coin-change",
  "url": "/submissions/detail/1075232509/"
}{
  "code": "class Solution {\n    public int coinChange(int[] coins, int amount) {\n        if (amount == 0) return 0;\n        int [] dp = new int[amount+1];\n        HashSet<Integer> set = new HashSet<>();\n        dp[0] = 0;\n        for (int i=1;i<=amount;i++){\n            dp[i] = Integer.MAX_VALUE;\n        }\n        for (int i : coins){\n            if (i<=amount){\n                dp[i] = 1;\n                set.add(i);\n            }\n            \n        }\n\n        for (int i = 1;i<=amount; i++){\n            int min = dp[i];\n            for (int coin: coins){\n                if (i>coin){\n                    if (dp[i-coin]!=Integer.MAX_VALUE)\n                        if (dp[i-coin]+1 < min) min = dp[i-coin] +1;\n                }\n            }\n            if (min!=Integer.MAX_VALUE)\n                dp[i] = min;\n            \n        }\n        // for (int i = 0; i<=amount;i++){\n        //     System.out.println(i+\" \"+dp[i]);\n        // }\n\n        return dp[amount]>0&&dp[amount]!=Integer.MAX_VALUE?dp[amount]:-1;\n        \n    }\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1075226455,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "43.7 MB",
  "runtime": "15 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697309094,
  "title": "Coin Change",
  "title_slug": "coin-change",
  "url": "/submissions/detail/1075226455/"
}{
  "code": "class Solution {\n    public int coinChange(int[] coins, int amount) {\n        if (amount == 0) return 0;\n        int [] dp = new int[amount+1];\n        HashSet<Integer> set = new HashSet<>();\n        dp[0] = 0;\n        for (int i=1;i<=amount;i++){\n            dp[i] = Integer.MAX_VALUE;\n        }\n        for (int i : coins){\n            if (i<=amount){\n                dp[i] = 1;\n                set.add(i);\n            }\n            \n        }\n\n        for (int i = 1;i<=amount; i++){\n            int min = Integer.MAX_VALUE;\n            for (int coin: coins){\n                if (i>coin){\n                    if (dp[i-coin]+1 < min) min = dp[i-coin] +1;\n                }\n            }\n            if (min!=Integer.MAX_VALUE)\n                dp[i] = Integer.min(min,dp[i]);\n            \n        }\n        // for (int i = 0; i<=amount;i++){\n        //     System.out.println(i+\" \"+dp[i]);\n        // }\n\n        return dp[amount]>0&&dp[amount]!=Integer.MAX_VALUE?dp[amount]:-1;\n        \n    }\n}",
  "compare_result": "111111111111111111111111111111100000000000001000010000010000010001000100000000000000000000010000000000001000000011000000000000000000000000000000000000000000000000000001100000000000000110111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1075223060,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "1 month, 1 week",
  "timestamp": 1697308785,
  "title": "Coin Change",
  "title_slug": "coin-change",
  "url": "/submissions/detail/1075223060/"
}{
  "code": "class Solution {\n    public int coinChange(int[] coins, int amount) {\n        if (amount == 0) return 0;\n        int [] dp = new int[amount+1];\n        HashSet<Integer> set = new HashSet<>();\n        dp[0] = 0;\n        for (int i=1;i<=amount;i++){\n            dp[i] = Integer.MAX_VALUE;\n        }\n        for (int i : coins){\n            if (i<=amount){\n                dp[i] = 1;\n                set.add(i);\n            }\n            \n        }\n\n        for (int i = 1;i<=amount; i++){\n            int min = Integer.MAX_VALUE;\n            for (int coin: coins){\n                if (i>coin){\n                    if (dp[i-coin]+1 < min) min = dp[i-coin] +1;\n                }\n            }\n            if (min!=Integer.MAX_VALUE)\n                dp[i] = min;\n            \n        }\n        // for (int i = 0; i<=amount;i++){\n        //     System.out.println(i+\" \"+dp[i]);\n        // }\n\n        return dp[amount]>0&&dp[amount]!=Integer.MAX_VALUE?dp[amount]:-1;\n        \n    }\n}",
  "compare_result": "111111111110110011101011010110000000000000001000010000010000010001000100000000000000000000010000000000001000000011000000000000000000000000000000000000000000000000000000100000000000000110111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1075222276,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "1 month, 1 week",
  "timestamp": 1697308720,
  "title": "Coin Change",
  "title_slug": "coin-change",
  "url": "/submissions/detail/1075222276/"
}{
  "code": "class Solution {\n    public int coinChange(int[] coins, int amount) {\n        if (amount == 0) return 0;\n        int [] dp = new int[amount+1];\n        HashSet<Integer> set = new HashSet<>();\n        dp[0] = 0;\n        for (int i=1;i<=amount;i++){\n            dp[i] = Integer.MAX_VALUE;\n        }\n        for (int i : coins){\n            if (i<=amount){\n                dp[i] = 1;\n                set.add(i);\n            }\n            \n        }\n\n        for (int i = 1;i<=amount; i++){\n            int min = Integer.MAX_VALUE;\n            for (int coin: coins){\n                if (i>coin){\n                    if (dp[i-coin]+1 < min) min = dp[i-coin] +1;\n                }\n            }\n            if (min!=Integer.MAX_VALUE)\n                dp[i] = min;\n            \n        }\n        // for (int i = 0; i<=amount;i++){\n        //     System.out.println(i+\" \"+dp[i]);\n        // }\n\n        return dp[amount]>0?dp[amount]:-1;\n        \n    }\n}",
  "compare_result": "111110110110110011101011010110000000000000001000010000010000010000000100000000000000000000010000000000001000000011000000000000000000000000000000000000000000000000000000100000000000000110011",
  "flag_type": 1,
  "has_notes": false,
  "id": 1075221760,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "1 month, 1 week",
  "timestamp": 1697308674,
  "title": "Coin Change",
  "title_slug": "coin-change",
  "url": "/submissions/detail/1075221760/"
}{
  "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        HashSet<Character> tracker =  new HashSet<>();\n        char [] ch = s.toCharArray();\n\n        int p_l = 0;\n        int p_r = 0;\n        int count = 0;\n        int max = 0;\n        while (p_l<s.length() && p_r<s.length()){\n            if (tracker.contains(ch[p_r])){\n                while (tracker.contains(ch[p_r])){\n                    tracker.remove(ch[p_l]);\n                    p_l++;\n                    count --;\n                }\n            }\n            \n            count++;\n            if (count > max) max= count;\n            tracker.add(ch[p_r]);\n            \n            p_r++;\n        }\n\n        return max;\n        \n    }\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1074721918,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "43.7 MB",
  "runtime": "7 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697259456,
  "title": "Longest Substring Without Repeating Characters",
  "title_slug": "longest-substring-without-repeating-characters",
  "url": "/submissions/detail/1074721918/"
}{
  "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        HashSet<Character> tracker =  new HashSet<>();\n        char [] ch = s.toCharArray();\n\n        int p_l = 0;\n        int p_r = 0;\n        int count = 0;\n        int max = 0;\n        while (p_l<s.length() && p_r<s.length()){\n            if (tracker.contains(ch[p_r])){\n                while (tracker.contains(ch[p_r])){\n                    tracker.remove(ch[p_l]);\n                    p_l++;\n                    count --;\n                }\n            }\n            else{\n                count++;\n                if (count > max) max= count;\n                tracker.add(ch[p_r]);\n            }\n            p_r++;\n        }\n\n        return max;\n        \n    }\n}",
  "compare_result": "111111111011111111101111111101111110111110011111000110011111111111011111100110110010011111001110110011000101000110100001001100110000000010010000010010000010110100100011001000011001100100011100000000001001000101000100000100000000110010000000000101000000000010000000010001000001000010000000000001000000000100100000001010000000001000000000100000000001100000000011001100000000000000000000000000010000000010001100010100001000010001000000000000001000010000000000000000000000010000000001010000000100000000000000011000011000010101000000001000000010000000000000010000000001000000000000010000010010010000000000000000000100000010000000000100000000000000000000000000000001000100000000000001001000000000000000000000000000000000110010000000001000001000000001100001000000010000000000000000100000000000000000010100000011010100000010000000110000010000000100000000000000000000000000000000000001000000000000000000000000010000000000000000000000000000000010000000001000000000000000000010000000000000000000011",
  "flag_type": 1,
  "has_notes": false,
  "id": 1074662574,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "1 month, 1 week",
  "timestamp": 1697250360,
  "title": "Longest Substring Without Repeating Characters",
  "title_slug": "longest-substring-without-repeating-characters",
  "url": "/submissions/detail/1074662574/"
}{
  "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode l1_p = l1;\n        ListNode l2_p = l2;\n        ListNode re = null;\n        ListNode re_p = re;\n        int left = 0;\n        while (l1_p!=null || l2_p !=null){\n            int val = left;\n            if (l1_p != null) {\n                val = val+l1_p.val;\n                l1_p = l1_p.next;\n            }\n            if (l2_p != null) {\n                val = val+l2_p.val;\n                l2_p = l2_p.next;\n            }\n            if (val > 9 ){\n                val = val- 10;\n                left = 1;\n            }else{\n                left = 0;\n            }\n            if (re_p==null){\n                re = new ListNode(val);\n                re_p = re;\n            }else{\n                re_p.next = new ListNode(val);\n                re_p = re_p.next;\n            }\n            \n        }\n        if (left > 0) re_p.next = new ListNode(left);\n\n        return re;\n        \n    }\n}",
  "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1074655235,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "42.6 MB",
  "runtime": "1 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697248954,
  "title": "Add Two Numbers",
  "title_slug": "add-two-numbers",
  "url": "/submissions/detail/1074655235/"
}{
  "code": "class Solution {\n    public int numberOfPoints(List<List<Integer>> nums) {\n        List<Data> nums_data = new ArrayList<>();\n        int n = nums.size();\n        for (List<Integer> i : nums){\n            nums_data.add(new Data(i.get(0),i.get(1)));\n        }\n        Collections.sort(nums_data);\n\n        LinkedList<Data> re = new LinkedList<>();\n        re.add(nums_data.get(0));\n        for (int i =1;i<n;i++){\n            Data d = re.getLast();\n            Data i_d = nums_data.get(i);\n            if (d.b>=i_d.a) {\n                d.b = Integer.max(d.b,i_d.b);\n            } else{\n                re.add(i_d);\n            }\n        }\n        int count = 0;\n        for (Data d: re){\n            count = count + d.b-d.a+1;\n        }\n        return count;\n    }\n}\n\nclass Data implements Comparable<Data>{\n    int a;\n    int b;\n    public Data (int x, int y){\n        a= x;\n        b = y;\n    }\n\n    @Override\n    public int compareTo(Data o){\n        if (a==o.a) return Integer.compare(b,o.b);\n        return Integer.compare(a,o.a);\n    }\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1074626816,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "42.9 MB",
  "runtime": "5 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697243027,
  "title": "Points That Intersect With Cars",
  "title_slug": "points-that-intersect-with-cars",
  "url": "/submissions/detail/1074626816/"
}{
  "code": "class Solution {\n    public int numberOfPoints(List<List<Integer>> nums) {\n        List<Data> nums_data = new ArrayList<>();\n        int n = nums.size();\n        for (List<Integer> i : nums){\n            nums_data.add(new Data(i.get(0),i.get(1)));\n        }\n        Collections.sort(nums_data);\n        for (Data d: nums_data){\n                        System.out.println(d.a+\" \"+d.b);\n\n        }\n        LinkedList<Data> re = new LinkedList<>();\n        re.add(nums_data.get(0));\n        for (int i =1;i<n;i++){\n            Data d = re.getLast();\n            Data i_d = nums_data.get(i);\n            if (d.b>=i_d.a) {\n                d.b = Integer.max(d.b,i_d.b);\n            } else{\n                re.add(i_d);\n            }\n        }\n        int count = 0;\n        for (Data d: re){\n            System.out.println(d.a+\" \"+d.b);\n            count = count + d.b-d.a+1;\n        }\n        return count;\n    }\n}\n\nclass Data implements Comparable<Data>{\n    int a;\n    int b;\n    public Data (int x, int y){\n        a= x;\n        b = y;\n    }\n\n    @Override\n    public int compareTo(Data o){\n        if (a==o.a) return Integer.compare(b,o.b);\n        return Integer.compare(a,o.a);\n    }\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1074626752,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "43.8 MB",
  "runtime": "32 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697243013,
  "title": "Points That Intersect With Cars",
  "title_slug": "points-that-intersect-with-cars",
  "url": "/submissions/detail/1074626752/"
}{
  "code": "class Solution {\n    public int numberOfPoints(List<List<Integer>> nums) {\n        List<Data> nums_data = new ArrayList<>();\n        int n = nums.size();\n        for (List<Integer> i : nums){\n            nums_data.add(new Data(i.get(0),i.get(1)));\n        }\n        Collections.sort(nums_data);\n        LinkedList<Data> re = new LinkedList<>();\n        re.add(nums_data.get(0));\n        for (int i =1;i<n;i++){\n            Data d = re.getLast();\n            Data i_d = nums_data.get(i);\n            if (d.b>=i_d.a) {\n                d.b = Integer.max(d.b,i_d.b);\n            } else{\n                re.add(i_d);\n            }\n        }\n        int count = 0;\n        for (Data d: re){\n            System.out.println(d.a+\" \"+d.b);\n            count = count + d.b-d.a+1;\n        }\n        return count;\n    }\n}\n\nclass Data implements Comparable<Data>{\n    int a;\n    int b;\n    public Data (int x, int y){\n        a= x;\n        b = y;\n    }\n\n    @Override\n    public int compareTo(Data o){\n        if (a==o.a) return Integer.compare(b,o.b);\n        return Integer.compare(b,o.b);\n    }\n}",
  "compare_result": "110001011001110101100110001011110001010000100101011110111010100011111101100100011111100000100101110100110011100110100110101101010100101100000110000110001111000000001000100011111010010110110110101100001010110001100100010011110001000010010111010101000110010001101100011110111111001101111101111101001010101000011100101001001000011110110111111111111011110110110011011111011010111100000001011011010110100000111110101010100000011101000101101100100011000011110100101111011001000100010000111100011111111011100100000001000110001001010000000010000100000001100010000000100100000001001000000010001000010001001100100001000000101000000001000000000010000001001000001000000101000001000000000000000000100010000001000100000001000000000010000000011000010010100001000000000000000000000010000000000000001000100000000000001011111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1074626422,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "1 month, 1 week",
  "timestamp": 1697242948,
  "title": "Points That Intersect With Cars",
  "title_slug": "points-that-intersect-with-cars",
  "url": "/submissions/detail/1074626422/"
}{
  "code": "class Solution {\n    public int numberOfPoints(List<List<Integer>> nums) {\n        List<Data> nums_data = new ArrayList<>();\n        int n = nums.size();\n        for (List<Integer> i : nums){\n            nums_data.add(new Data(i.get(0),i.get(1)));\n        }\n        Collections.sort(nums_data);\n        LinkedList<Data> re = new LinkedList<>();\n        re.add(nums_data.get(0));\n        for (int i =1;i<n;i++){\n            Data d = re.getLast();\n            Data i_d = nums_data.get(i);\n            if (d.b>=i_d.a) {\n                d.b = Integer.max(d.b,i_d.b);\n            } else{\n                re.add(i_d);\n            }\n        }\n        int count = 0;\n        for (Data d: re){\n            count = count + d.b-d.a+1;\n        }\n        return count;\n    }\n}\n\nclass Data implements Comparable<Data>{\n    int a;\n    int b;\n    public Data (int x, int y){\n        a= x;\n        b = y;\n    }\n\n    @Override\n    public int compareTo(Data o){\n        if (a==o.a) return Integer.compare(b,o.b);\n        return Integer.compare(b,o.b);\n    }\n}",
  "compare_result": "110001011001110101100110001011110001010000100101011110111010100011111101100100011111100000100101110100110011100110100110101101010100101100000110000110001111000000001000100011111010010110110110101100001010110001100100010011110001000010010111010101000110010001101100011110111111001101111101111101001010101000011100101001001000011110110111111111111011110110110011011111011010111100000001011011010110100000111110101010100000011101000101101100100011000011110100101111011001000100010000111100011111111011100100000001000110001001010000000010000100000001100010000000100100000001001000000010001000010001001100100001000000101000000001000000000010000001001000001000000101000001000000000000000000100010000001000100000001000000000010000000011000010010100001000000000000000000000010000000000000001000100000000000001011111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1074625819,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "1 month, 1 week",
  "timestamp": 1697242825,
  "title": "Points That Intersect With Cars",
  "title_slug": "points-that-intersect-with-cars",
  "url": "/submissions/detail/1074625819/"
}{
  "code": "class Solution {\n    public int numberOfPoints(List<List<Integer>> nums) {\n        List<Data> nums_data = new ArrayList<>();\n        int n = nums.size();\n        for (List<Integer> i : nums){\n            nums_data.add(new Data(i.get(0),i.get(1)));\n        }\n        Collections.sort(nums_data);\n        LinkedList<Data> re = new LinkedList<>();\n        re.add(nums_data.get(0));\n        for (int i =1;i<n;i++){\n            Data d = re.getLast();\n            Data i_d = nums_data.get(i);\n            if (d.b>i_d.a) {\n                d.b = Integer.max(d.b,i_d.b);\n            } else{\n                re.add(i_d);\n            }\n        }\n        int count = 0;\n        for (Data d: re){\n            count = count + d.b-d.a+1;\n        }\n        return count;\n    }\n}\n\nclass Data implements Comparable<Data>{\n    int a;\n    int b;\n    public Data (int x, int y){\n        a= x;\n        b = y;\n    }\n\n    @Override\n    public int compareTo(Data o){\n        if (a==o.a) return Integer.compare(b,o.b);\n        return Integer.compare(b,o.b);\n    }\n}",
  "compare_result": "110001010100000001100100001011110001010000000100001111011010000001110100000000110111101000000100100100001111100110000100111001110100000000000110000100000100000010011000110011101000000111011100110110010010111110100000010001111011101010000111011101000010000000011001001010000011010000001001010101011000100000001100101001001100011110001011011101001011100100001011010111001000110000000000010101001001000000101010001010111000011000000101100101100111000000110100001001011001100000100000111000011011011101101100000000100000100000010000000000000100000001100000000000001000000001011000000010100100001001000000100001000000000000000000000000000000000001000000000010000001000001000000000000000000100001000100000000000001000000000010000001010000010000100000000000000000000000000010000000001000001000100000010000001011011",
  "flag_type": 1,
  "has_notes": false,
  "id": 1074625602,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "1 month, 1 week",
  "timestamp": 1697242782,
  "title": "Points That Intersect With Cars",
  "title_slug": "points-that-intersect-with-cars",
  "url": "/submissions/detail/1074625602/"
}{
  "code": "class Solution {\n    public int countSymmetricIntegers(int low, int high) {\n        int count = 0;\n        for (int i = low;i<=high;i++){\n            if (isSym(i)) count ++;\n        }\n        return count;\n        \n    }\n    public boolean isSym(int num){\n        String s = \"\" + num;\n        if (s.length()%2!=0) return false;\n        int left = 0;\n        int right = 0;\n        int n = s.length();\n        for (int i=0;i<n/2;i++){\n            left = left + s.charAt(i)-'0';\n            right = right + s.charAt(i+n/2)-'0';\n        }\n        return left==right;\n\n    }\n}",
  "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1074622122,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "43.6 MB",
  "runtime": "27 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697242056,
  "title": "  Count Symmetric Integers",
  "title_slug": "count-symmetric-integers",
  "url": "/submissions/detail/1074622122/"
}{
  "code": "class Solution {\n    public boolean canBeEqual(String s1, String s2) {\n        String s1_1 = \"\"+s1.charAt(2)+s1.charAt(1)+s1.charAt(0)+s1.charAt(3);\n        String s1_2 = \"\"+s1.charAt(2)+s1.charAt(3)+s1.charAt(0)+s1.charAt(1);\n        String s1_3 = \"\"+s1.charAt(0)+s1.charAt(3)+s1.charAt(2)+s1.charAt(1);\n        return s1.equals(s2) || s1_1.equals(s2) || s1_2.equals(s2) || s1_3.equals(s2);\n    }\n}",
  "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1074620248,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "42.3 MB",
  "runtime": "10 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697241691,
  "title": "Check if Strings Can be Made Equal With Operations I",
  "title_slug": "check-if-strings-can-be-made-equal-with-operations-i",
  "url": "/submissions/detail/1074620248/"
}{
  "code": "class Solution {\n    public boolean canBeEqual(String s1, String s2) {\n        String s1_1 = \"\"+s1.charAt(2)+s1.charAt(1)+s1.charAt(0)+s1.charAt(3);\n        String s1_2 = \"\"+s1.charAt(2)+s1.charAt(3)+s1.charAt(0)+s1.charAt(1);\n        String s1_3 = \"\"+s1.charAt(0)+s1.charAt(3)+s1.charAt(2)+s1.charAt(2);\n        return s1.equals(s2) || s1_1.equals(s2) || s1_2.equals(s2) || s1_3.equals(s2);\n    }\n}",
  "compare_result": "1101101111111110111111111111111111011111111111111111011111010011101101101111111111111111111111111111111011011111111100111111111111111111111011111111111111111101111111111111111110111111111111111111111111101111111111110111111111111111111111111111111111110101110111111111111001111011111011111101111111110101111110111010101110011101111111111110111111111111011111111110111111111111111111111110111011111111101111110111101110110111111011111101011111011110011111111111110011111111111111011011100001101110101100101111101101111111111111011111111110111001111011111111111101111111111111110111011111111110010111111110111011110111111111101111111111011111111111111101111111111111100011111011111011111101111111111110101101111111111011111011110111011111111111101111111111101101111111111111111111101111111111011111110011111111111111101111111011111111011101001111110110101011111111111101011111111111111101111011011111111111001101101111111011110111111111111111111111111111011110111011110111111111111010111111111101111111101",
  "flag_type": 1,
  "has_notes": false,
  "id": 1074619981,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "1 month, 1 week",
  "timestamp": 1697241634,
  "title": "Check if Strings Can be Made Equal With Operations I",
  "title_slug": "check-if-strings-can-be-made-equal-with-operations-i",
  "url": "/submissions/detail/1074619981/"
}{
  "code": "class Solution {\n    public int furthestDistanceFromOrigin(String moves) {\n        int countL=0;\n        int countR=0;\n        int count = 0;\n        int n = moves.length();\n        for (int i = 0;i<n;i++){\n            if (moves.charAt(i)=='L') countL++;\n            if (moves.charAt(i)=='R') countR++;\n            if (moves.charAt(i)=='_') count++;\n        }\n        if (countL==countR) return count;\n        if (countL>countR) return countL+count-countR;\n        return countR+count-countL;\n        \n    }\n}",
  "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1074618190,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "41.2 MB",
  "runtime": "1 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697241279,
  "title": "Furthest Point From Origin",
  "title_slug": "furthest-point-from-origin",
  "url": "/submissions/detail/1074618190/"
}{
  "code": "class Solution {\n    public boolean isAcronym(List<String> words, String s) {\n        StringBuilder sb = new StringBuilder();\n        for (String d:words){\n            sb.append(d.charAt(0));\n        }\n        return sb.toString().equals(s);\n        \n    }\n}",
  "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1074617067,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "44.2 MB",
  "runtime": "1 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697241057,
  "title": "Check if a String Is an Acronym of Words",
  "title_slug": "check-if-a-string-is-an-acronym-of-words",
  "url": "/submissions/detail/1074617067/"
}{
  "code": "class Solution {\n    public int countPairs(List<Integer> nums, int target) {\n        int count = 0;\n        int n = nums.size();\n        for (int i = 0; i<n-1;i++){\n            for (int j = i+1;j<n;j++){\n                if (nums.get(i)+nums.get(j)<target) count++;\n            }\n        }\n        return count;\n        \n    }\n}",
  "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1074616399,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "41.5 MB",
  "runtime": "2 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697240931,
  "title": "Count Pairs Whose Sum is Less than Target",
  "title_slug": "count-pairs-whose-sum-is-less-than-target",
  "url": "/submissions/detail/1074616399/"
}{
  "code": "class Solution {\n    public long maximumTripletValue(int[] nums) {\n        long max = 0;\n        int n = nums.length;\n        for (int i = 0; i<n-2;i++){\n            for (int j = i+1;j<n-1;j++){\n                for (int k = j+1;k<n;k++){\n                    long temp = (long)(nums[i]-nums[j])*nums[k];\n                    if (temp>max) max = temp;\n                }\n            }\n        }\n        return max;\n    }\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1074615354,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "40.6 MB",
  "runtime": "3 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697240726,
  "title": "Maximum Value of an Ordered Triplet I",
  "title_slug": "maximum-value-of-an-ordered-triplet-i",
  "url": "/submissions/detail/1074615354/"
}{
  "code": "class Solution {\n    public long maximumTripletValue(int[] nums) {\n        long max = 0;\n        int n = nums.length;\n        for (int i = 0; i<n-2;i++){\n            for (int j = i+1;j<n-1;j++){\n                for (int k = j+1;k<n;k++){\n                    long temp = (nums[i]-nums[j])*nums[k];\n                    if (temp>max) max = temp;\n                }\n            }\n        }\n        return max;\n    }\n}",
  "compare_result": "111110111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000100000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000100000000001001000000000000000000100010000000000000000000000100000000000000000000001000000000000000000000000000000010000000000000000000001000000000000000000000000000000000000000000000000000000000001",
  "flag_type": 1,
  "has_notes": false,
  "id": 1074614941,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "1 month, 1 week",
  "timestamp": 1697240649,
  "title": "Maximum Value of an Ordered Triplet I",
  "title_slug": "maximum-value-of-an-ordered-triplet-i",
  "url": "/submissions/detail/1074614941/"
}{
  "code": "class Solution {\n    public long maximumTripletValue(int[] nums) {\n        int max = 0;\n        int n = nums.length;\n        for (int i = 0; i<n-2;i++){\n            for (int j = i+1;j<n-1;j++){\n                for (int k = j+1;k<n;k++){\n                    int temp = (nums[i]-nums[j])*nums[k];\n                    if (temp>max) max = temp;\n                }\n            }\n        }\n        return max;\n    }\n}",
  "compare_result": "111110111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000100000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000100000000001001000000000000000000100010000000000000000000000100000000000000000000001000000000000000000000000000000010000000000000000000001000000000000000000000000000000000000000000000000000000000001",
  "flag_type": 1,
  "has_notes": false,
  "id": 1074614751,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "1 month, 1 week",
  "timestamp": 1697240613,
  "title": "Maximum Value of an Ordered Triplet I",
  "title_slug": "maximum-value-of-an-ordered-triplet-i",
  "url": "/submissions/detail/1074614751/"
}{
  "code": "class Solution {\n    public int minOperations(List<Integer> nums, int k) {\n        HashSet<Integer> check= new HashSet<>();\n        int n = nums.size();\n        Collections.reverse(nums);\n        int count =0;\n        for (int i = 0;i<n;i++){\n            if (nums.get(i)<=k && nums.get(i)>=1 && !check.contains(nums.get(i))){\n                count++;\n                check.add(nums.get(i));\n            }\n            if (count == k ){\n                return i+1;\n            }\n        }\n        return 0;\n\n        \n    }\n}",
  "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1074613638,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "40.8 MB",
  "runtime": "2 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697240394,
  "title": "Minimum Operations to Collect Elements",
  "title_slug": "minimum-operations-to-collect-elements",
  "url": "/submissions/detail/1074613638/"
}{
  "code": "class Solution {\n    public String maximumOddBinaryNumber(String s) {\n        char [] c = s.toCharArray();\n        int n = s.length();\n        int count = 0;\n        for (char i: c){\n            if (i=='1'){\n                count ++;\n            }\n        }\n        \n        String re = \"\";\n        count --;\n        for (int i = 0;i<count;i++){\n            re='1'+re;\n        }\n        for (int i=0;i<n-count-1;i++){\n            re=re + \"0\";\n        }\n        return re+\"1\";\n    }\n}",
  "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1074610512,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "44 MB",
  "runtime": "3 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697239804,
  "title": "Maximum Odd Binary Number",
  "title_slug": "maximum-odd-binary-number",
  "url": "/submissions/detail/1074610512/"
}{
  "code": "class Solution {\n    public int differenceOfSums(int n, int m) {\n        int l = (n/m) * m;\n        int sum2 = (m+l)*((l-m)/m+1)/2;\n        int sum = (n+1)*n /2;\n        int sum1 = sum - sum2;\n        // System.out.println(sum1 + \" \" + sum2);\n        return sum1-sum2;\n        \n    }\n}",
  "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1074609403,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "40.1 MB",
  "runtime": "0 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697239586,
  "title": "Divisible and Non-divisible Sums Difference",
  "title_slug": "divisible-and-non-divisible-sums-difference",
  "url": "/submissions/detail/1074609403/"
}{
  "code": "class Solution {\n    public int hIndex(int[] citations) {\n        Arrays.sort(citations);\n        int count = 0;\n        for (int i = citations.length-1;i>=0;i--){\n            System.out.println(citations[i]);\n            if (citations[i]<=count) break;\n            \n            count++;\n        }\n\n        return count;\n        \n    }\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1074543534,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "40.6 MB",
  "runtime": "8 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697229253,
  "title": "H-Index",
  "title_slug": "h-index",
  "url": "/submissions/detail/1074543534/"
}{
  "code": "class Solution {\n    public int numberOfEmployeesWhoMetTarget(int[] hours, int target) {\n        int re = 0;\n        for (int i: hours){\n            if (i>= target) re ++;\n        }\n        return re;\n        \n    }\n}",
  "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1073946748,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "41.8 MB",
  "runtime": "0 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697166764,
  "title": "Number of Employees Who Met the Target",
  "title_slug": "number-of-employees-who-met-the-target",
  "url": "/submissions/detail/1073946748/"
}{
  "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        StringBuilder sb = new StringBuilder();\n        s = s.toLowerCase();\n        for (int i = 0; i< s.length();i++){\n            char t = s.charAt(i);\n            if ((t<='z' && t >='a') || (t>='0' && t<='9')){\n                sb.append(t);\n            }\n        }\n        String st = \"\";\n        st = sb.toString();\n        if (st.length()<2) return true;\n        for (int i = 0;i<st.length()/2;i++){\n            if (st.charAt(i)!=st.charAt(st.length()-i-1)) return false;\n        }\n    return true;\n    }\n}",
  "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1073850664,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "43.6 MB",
  "runtime": "3 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697152587,
  "title": "Valid Palindrome",
  "title_slug": "valid-palindrome",
  "url": "/submissions/detail/1073850664/"
}{
  "code": "class Solution {\n    public boolean isPalindrome(String s) {\n\n        String st = \"\";\n        s = s.toLowerCase();\n        for (int i = 0; i< s.length();i++){\n            char t = s.charAt(i);\n            if ((t<='z' && t >='a') || (t>='0' && t<='9')){\n                st = st + t;\n            }\n        }\n        if (st.length()<2) return true;\n        for (int i = 0;i<st.length()/2;i++){\n            if (st.charAt(i)!=st.charAt(st.length()-i-1)) return false;\n        }\n    return true;\n    }\n}",
  "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1073849705,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "44.9 MB",
  "runtime": "128 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697152429,
  "title": "Valid Palindrome",
  "title_slug": "valid-palindrome",
  "url": "/submissions/detail/1073849705/"
}{
  "code": "class Solution {\n    public boolean isPalindrome(String s) {\n\n        String st = \"\";\n        s = s.toLowerCase();\n        for (int i = 0; i< s.length();i++){\n            char t = s.charAt(i);\n            if ((t<='z' && t >='a') || (t>='0' && t<='9')){\n                st = st + t;\n            }\n        }\n        if (st.length()<2) return true;\n        for (int i = 0;i<st.length()/2;i++){\n            if (st.charAt(i)!=st.charAt(st.length()-i-1)) return false;\n        }\n    return true;\n    }\n}",
  "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1073849633,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "45 MB",
  "runtime": "131 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697152418,
  "title": "Valid Palindrome",
  "title_slug": "valid-palindrome",
  "url": "/submissions/detail/1073849633/"
}{
  "code": "class Solution {\n    public boolean isPalindrome(String s) {\n\n        String st = \"\";\n        s = s.toLowerCase();\n        for (int i = 0; i< s.length();i++){\n            char t = s.charAt(i);\n            if ((t<='z' && t >='a') || (t>='0' && t<='9')){\n                st = st + t;\n            }\n        }\n        if (st.length()<2) return true;\n        for (int i = 0;i<st.length();i++){\n            if (st.charAt(i)!=st.charAt(st.length()-i-1)) return false;\n        }\n    return true;\n    }\n}",
  "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1073849341,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "45 MB",
  "runtime": "126 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697152370,
  "title": "Valid Palindrome",
  "title_slug": "valid-palindrome",
  "url": "/submissions/detail/1073849341/"
}{
  "code": "class Solution {\n    public boolean isPalindrome(String s) {\n\n        String st = \"\";\n        s = s.toLowerCase();\n        for (int i = 0; i< s.length();i++){\n            char t = s.charAt(i);\n            if (t<='z' && t >='a'){\n                st = st + t;\n            }\n        }\n        if (st.length()<2) return true;\n        for (int i = 0;i<st.length();i++){\n            if (st.charAt(i)!=st.charAt(st.length()-i-1)) return false;\n        }\n    return true;\n    }\n}",
  "compare_result": "11111111111011111110110111111101111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100111111101111101111101110101111110111111111111111011101101111010111111111011101101011111111111110011111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1073848988,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "1 month, 1 week",
  "timestamp": 1697152308,
  "title": "Valid Palindrome",
  "title_slug": "valid-palindrome",
  "url": "/submissions/detail/1073848988/"
}{
  "code": "class Solution {\n\n    public int[][] merge(int[][] inp) {\n        int n = inp.length;\n        ArrayList<Pair> l = new ArrayList<>();\n        LinkedList<Pair> m = new LinkedList<>();\n\n        for (int[] i : inp){\n            l.add(new Pair(i[0],i[1]));\n        }\n        Collections.sort(l);\n        \n        m.add(l.get(0));\n        for (int i = 1;i<n;i++){\n            Pair pointer_m = m.getLast();\n            Pair pointer_l = l.get(i);\n            if (pointer_m.b>=pointer_l.a){\n                pointer_m.b = Integer.max(pointer_m.b, pointer_l.b);\n            } else{\n                m.add(pointer_l);\n            }\n        }\n        // System.out.println(m.size());\n        int [][] re = new int[m.size()][2];\n        int count = 0;\n        for (Pair i : m){\n            re[count][0] = i.a;\n            re[count][1] = i.b;\n            count++;\n        }\n        return re;\n    }\n}\nclass Pair implements Comparable<Pair>{\n    int a;\n    int b;\n    public Pair(int x, int y){\n        a = x;\n        b = y;\n\n    }\n    @Override\n    public int compareTo(Pair o){\n        if (a == o.a) return Integer.compare(b,o.b);\n        return Integer.compare(a,o.a);\n    }\n\n    @Override\n    public String toString(){\n        return a+\" \"+b;\n    }\n}",
  "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1073841303,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "45.6 MB",
  "runtime": "9 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697151078,
  "title": "Merge Intervals",
  "title_slug": "merge-intervals",
  "url": "/submissions/detail/1073841303/"
}{
  "code": "class Solution {\n\n    public int[][] merge(int[][] inp) {\n        int n = inp.length;\n        ArrayList<Pair> l = new ArrayList<>();\n        LinkedList<Pair> m = new LinkedList<>();\n\n        for (int[] i : inp){\n            l.add(new Pair(i[0],i[1]));\n        }\n        Collections.sort(l);\n        \n        m.add(l.get(0));\n        for (int i = 1;i<n;i++){\n            Pair pointer_m = m.getLast();\n            Pair pointer_l = l.get(i);\n            if (pointer_m.b>=pointer_l.a){\n                pointer_m.b = pointer_l.b;\n            } else{\n                m.add(pointer_l);\n            }\n        }\n        // System.out.println(m.size());\n        int [][] re = new int[m.size()][2];\n        int count = 0;\n        for (Pair i : m){\n            re[count][0] = i.a;\n            re[count][1] = i.b;\n            count++;\n        }\n        return re;\n    }\n}\nclass Pair implements Comparable<Pair>{\n    int a;\n    int b;\n    public Pair(int x, int y){\n        a = x;\n        b = y;\n\n    }\n    @Override\n    public int compareTo(Pair o){\n        if (a == o.a) return Integer.compare(b,o.b);\n        return Integer.compare(a,o.a);\n    }\n\n    @Override\n    public String toString(){\n        return a+\" \"+b;\n    }\n}",
  "compare_result": "11111111110011101110111110111111111111110111111111111111101111111011111111110111101101110111111010101110101111111111110110011101100001001100010110000000000000000000000111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1073840906,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "1 month, 1 week",
  "timestamp": 1697151015,
  "title": "Merge Intervals",
  "title_slug": "merge-intervals",
  "url": "/submissions/detail/1073840906/"
}{
  "code": "class Solution {\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n        \n        HashSet<String> dict = new HashSet<String>(wordList);\n        if (!dict.contains(endWord)) return new ArrayList<>();\n        dict.add(beginWord);\n        System.out.println(dict.size());\n        List<List<String>> re = new ArrayList<>();\n        HashMap<String,HashSet<String>> map = new HashMap<>();\n\n        for (String s: dict){\n            map.put(s, new HashSet<>());\n        }\n        \n        for (String s1: dict){\n            for (String s2: dict){\n                if (!s1.equals(s2)){\n                    if (comp(s1,s2))\n                        map.get(s1).add(s2);\n                }\n            }\n        }\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        HashMap<String,Integer> shortPath = new HashMap<>();\n        HashMap<String,HashSet<String>> tracer = new HashMap<>();\n\n        for (String s: dict){\n            shortPath.put(s,Integer.MAX_VALUE);\n            tracer.put(s,new HashSet<>());\n        }\n\n        shortPath.put(beginWord,1);\n        \n        bfs.add(beginWord);\n        // int size = 1;\n        while (!bfs.isEmpty()){\n            String cur = bfs.poll();\n\n            if (!visited.contains(cur)){\n                visited.add(cur);\n                if (cur.equals(endWord)) break;\n                    for (String s: map.get(cur)){\n                        if (!visited.contains(s)){\n                            bfs.add(s);\n                            int min = shortPath.get(s);\n                            if (shortPath.get(cur)+1<=min){\n                                min = shortPath.get(cur)+1;\n                                shortPath.put(s,min);\n                                tracer.get(s).add(cur);\n                            }\n                        }\n                    }\n            }\n            \n        }\n\n        List<String> temp = new ArrayList<String>();\n        // System.out.println(shortPath.get(endWord));\n        gen(tracer,re,temp,beginWord,endWord);\n        return re;\n    }\n\n    public boolean comp(String s1, String s2){\n        if (s1.length()!=s2.length()) return false;\n        int n = s1.length(); \n        int count =0;\n        for (int i = 0;i<n;i++){\n            if (s1.charAt(i)!=s2.charAt(i))\n                count++;\n            if (count>1) return false;\n        }\n        return true;\n\n    }\n\n    public void gen(HashMap<String,HashSet<String>> tracer,List<List<String>> re, List<String> temp, String beginWord, String cur){\n        temp.add(cur);\n        // System.out.print(cur+\" \");\n        for (String s: tracer.get(cur)){\n            gen(tracer,re,temp,beginWord,s);\n        }\n        if (cur.equals(beginWord)){\n            List<String> t = new ArrayList<>(temp);\n            Collections.reverse(t);\n            re.add(t);\n            // System.out.println();\n        }\n        temp.remove(cur);\n        \n    }   \n}",
  "compare_result": "111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1073833042,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "43.9 MB",
  "runtime": "41 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697149783,
  "title": "Word Ladder II",
  "title_slug": "word-ladder-ii",
  "url": "/submissions/detail/1073833042/"
}{
  "code": "class Solution {\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n        \n        HashSet<String> dict = new HashSet<String>(wordList);\n        if (!dict.contains(endWord)) return new ArrayList<>();\n        dict.add(beginWord);\n        System.out.println(dict.size());\n        List<List<String>> re = new ArrayList<>();\n        HashMap<String,HashSet<String>> map = new HashMap<>();\n\n        for (String s: dict){\n            map.put(s, new HashSet<>());\n        }\n        \n        for (String s1: dict){\n            for (String s2: dict){\n                if (!s1.equals(s2)){\n                    if (comp(s1,s2))\n                        map.get(s1).add(s2);\n                }\n            }\n        }\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        HashMap<String,Integer> shortPath = new HashMap<>();\n        HashMap<String,HashSet<String>> tracer = new HashMap<>();\n\n        for (String s: dict){\n            shortPath.put(s,Integer.MAX_VALUE);\n            tracer.put(s,new HashSet<>());\n        }\n\n        shortPath.put(beginWord,1);\n        \n        bfs.add(beginWord);\n        // int size = 1;\n        while (!bfs.isEmpty()){\n            String cur = bfs.poll();\n            // System.out.println(cur);\n            // System.out.println(visited.size());\n            if (!visited.contains(cur)){\n                visited.add(cur);\n                if (cur.equals(endWord)) break;\n                    for (String s: map.get(cur)){\n                        if (!visited.contains(s)){\n                            bfs.add(s);\n                            int min = shortPath.get(s);\n                            if (shortPath.get(cur)+1<=min){\n                                min = shortPath.get(cur)+1;\n                                shortPath.put(s,min);\n                                tracer.get(s).add(cur);\n                            }\n                        }\n                    }\n            }\n            \n        }\n\n        List<String> temp = new ArrayList<String>();\n        // System.out.println(shortPath.get(endWord));\n        gen(tracer,re,temp,beginWord,endWord);\n        return re;\n    }\n\n    public boolean comp(String s1, String s2){\n        if (s1.length()!=s2.length()) return false;\n        int n = s1.length(); \n        int count =0;\n        for (int i = 0;i<n;i++){\n            if (s1.charAt(i)!=s2.charAt(i))\n                count++;\n            if (count>1) return false;\n        }\n        return true;\n\n    }\n\n    public void gen(HashMap<String,HashSet<String>> tracer,List<List<String>> re, List<String> temp, String beginWord, String cur){\n        temp.add(cur);\n        // System.out.print(cur+\" \");\n        for (String s: tracer.get(cur)){\n            gen(tracer,re,temp,beginWord,s);\n        }\n        if (cur.equals(beginWord)){\n            List<String> t = new ArrayList<>(temp);\n            Collections.reverse(t);\n            re.add(t);\n            // System.out.println();\n        }\n        temp.remove(cur);\n        \n    }   \n}",
  "compare_result": "111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1073832870,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "43.8 MB",
  "runtime": "39 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697149757,
  "title": "Word Ladder II",
  "title_slug": "word-ladder-ii",
  "url": "/submissions/detail/1073832870/"
}{
  "code": "class Solution {\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n        \n        HashSet<String> dict = new HashSet<String>(wordList);\n        if (!dict.contains(endWord)) return new ArrayList<>();\n        dict.add(beginWord);\n\n        List<List<String>> re = new ArrayList<>();\n        HashMap<String,HashSet<String>> map = new HashMap<>();\n\n        for (String s: dict){\n            map.put(s, new HashSet<>());\n        }\n        \n        for (String s1: dict){\n            for (String s2: dict){\n                if (!s1.equals(s2)){\n                    if (comp(s1,s2))\n                        map.get(s1).add(s2);\n                }\n            }\n        }\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        HashMap<String,Integer> shortPath = new HashMap<>();\n        HashMap<String,HashSet<String>> tracer = new HashMap<>();\n\n        for (String s: dict){\n            shortPath.put(s,Integer.MAX_VALUE);\n            tracer.put(s,new HashSet<>());\n        }\n\n        shortPath.put(beginWord,1);\n        \n        bfs.add(beginWord);\n        // int size = 1;\n        while (!bfs.isEmpty()){\n            String cur = bfs.poll();\n            // System.out.println(cur);\n            visited.add(cur);\n            if (cur.equals(endWord)) break;\n                for (String s: map.get(cur)){\n                    if (!visited.contains(s)){\n                        bfs.add(s);\n                        int min = shortPath.get(s);\n                        if (shortPath.get(cur)+1<=min){\n                            min = shortPath.get(cur)+1;\n                            shortPath.put(s,min);\n                            tracer.get(s).add(cur);\n                        }\n                    }\n                }\n        }\n\n        List<String> temp = new ArrayList<String>();\n        System.out.println(shortPath.get(endWord));\n        gen(tracer,re,temp,beginWord,endWord);\n        return re;\n    }\n\n    public boolean comp(String s1, String s2){\n        if (s1.length()!=s2.length()) return false;\n        int n = s1.length(); \n        int count =0;\n        for (int i = 0;i<n;i++){\n            if (s1.charAt(i)!=s2.charAt(i))\n                count++;\n            if (count>1) return false;\n        }\n        return true;\n\n    }\n\n    public void gen(HashMap<String,HashSet<String>> tracer,List<List<String>> re, List<String> temp, String beginWord, String cur){\n        temp.add(cur);\n        // System.out.print(cur+\" \");\n        for (String s: tracer.get(cur)){\n            gen(tracer,re,temp,beginWord,s);\n        }\n        if (cur.equals(beginWord)){\n            List<String> t = new ArrayList<>(temp);\n            Collections.reverse(t);\n            re.add(t);\n            // System.out.println();\n        }\n        temp.remove(cur);\n        \n    }   \n}",
  "compare_result": "111111111111111111111111111111110000",
  "flag_type": 1,
  "has_notes": false,
  "id": 1073807323,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 14,
  "status_display": "Time Limit Exceeded",
  "time": "1 month, 1 week",
  "timestamp": 1697146236,
  "title": "Word Ladder II",
  "title_slug": "word-ladder-ii",
  "url": "/submissions/detail/1073807323/"
}{
  "code": "class Solution {\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n        \n        HashSet<String> dict = new HashSet<String>(wordList);\n        if (!dict.contains(endWord)) return new ArrayList<>();\n        dict.add(beginWord);\n\n        List<List<String>> re = new ArrayList<>();\n        HashMap<String,HashSet<String>> map = new HashMap<>();\n\n        for (String s: dict){\n            map.put(s, new HashSet<>());\n        }\n        \n        for (String s1: dict){\n            for (String s2: dict){\n                if (!s1.equals(s2)){\n                    if (comp(s1,s2))\n                        map.get(s1).add(s2);\n                }\n            }\n        }\n\n        // for (String s: dict){\n        //     System.out.print(s+\": \");\n        //         for (String si: map.get(s)){\n        //             System.out.print(si+\" \");\n        //         }\n        //     System.out.println();\n        // }\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        HashMap<String,Integer> shortPath = new HashMap<>();\n        HashMap<String,HashSet<String>> tracer = new HashMap<>();\n\n        for (String s: dict){\n            shortPath.put(s,Integer.MAX_VALUE);\n            tracer.put(s,new HashSet<>());\n        }\n\n        shortPath.put(beginWord,1);\n        \n        bfs.add(beginWord);\n        // int size = 1;\n        while (!bfs.isEmpty()){\n            String cur = bfs.poll();\n            // System.out.println(cur);\n            visited.add(cur);\n            if (cur.equals(endWord)) break;\n                for (String s: map.get(cur)){\n                    if (!visited.contains(s)){\n                        bfs.add(s);\n                        int min = shortPath.get(s);\n                        if (shortPath.get(cur)+1<=min){\n                            min = shortPath.get(cur)+1;\n                            shortPath.put(s,min);\n                            tracer.get(s).add(cur);\n                        }\n                    }\n                }\n        }\n        // System.out.println(shortPath.get(endWord));\n        // for (String s: dict){\n        //     System.out.print(s+\": \" + shortPath.get(s)+\": \");\n        //         for (String si: tracer.get(s)){\n        //             System.out.print(si+\" \");\n        //         }\n        //     System.out.println();\n        // }\n        List<String> temp = new ArrayList<String>();\n        System.out.println(shortPath.get(endWord));\n        gen(tracer,re,temp,beginWord,endWord);\n        return re;\n    }\n\n    public boolean comp(String s1, String s2){\n        if (s1.length()!=s2.length()) return false;\n        int n = s1.length(); \n        int count =0;\n        for (int i = 0;i<n;i++){\n            if (s1.charAt(i)!=s2.charAt(i))\n                count++;\n            if (count>1) return false;\n        }\n        return true;\n\n    }\n\n    public void gen(HashMap<String,HashSet<String>> tracer,List<List<String>> re, List<String> temp, String beginWord, String cur){\n        temp.add(cur);\n        // System.out.print(cur+\" \");\n        for (String s: tracer.get(cur)){\n            gen(tracer,re,temp,beginWord,s);\n        }\n        if (cur.equals(beginWord)){\n            List<String> t = new ArrayList<>(temp);\n            Collections.reverse(t);\n            re.add(t);\n            // System.out.println();\n        }\n        temp.remove(cur);\n        \n    }   \n}",
  "compare_result": "111111111111111111111111111111110000",
  "flag_type": 1,
  "has_notes": false,
  "id": 1073806540,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 14,
  "status_display": "Time Limit Exceeded",
  "time": "1 month, 1 week",
  "timestamp": 1697146139,
  "title": "Word Ladder II",
  "title_slug": "word-ladder-ii",
  "url": "/submissions/detail/1073806540/"
}{
  "code": "class Solution {\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n        \n        HashSet<String> dict = new HashSet<String>(wordList);\n        if (!dict.contains(endWord)) return new ArrayList<>();\n        dict.add(beginWord);\n\n        List<List<String>> re = new ArrayList<>();\n        HashMap<String,HashSet<String>> map = new HashMap<>();\n\n        for (String s: dict){\n            map.put(s, new HashSet<>());\n        }\n        \n        for (String s1: dict){\n            for (String s2: dict){\n                if (!s1.equals(s2)){\n                    if (comp(s1,s2))\n                        map.get(s1).add(s2);\n                }\n            }\n        }\n\n        // for (String s: dict){\n        //     System.out.print(s+\": \");\n        //         for (String si: map.get(s)){\n        //             System.out.print(si+\" \");\n        //         }\n        //     System.out.println();\n        // }\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        HashMap<String,Integer> shortPath = new HashMap<>();\n        HashMap<String,HashSet<String>> tracer = new HashMap<>();\n\n        for (String s: dict){\n            shortPath.put(s,Integer.MAX_VALUE);\n            tracer.put(s,new HashSet<>());\n        }\n\n        shortPath.put(beginWord,1);\n        \n        bfs.add(beginWord);\n        // int size = 1;\n        while (!bfs.isEmpty()){\n            String cur = bfs.poll();\n            // System.out.println(cur);\n            visited.add(cur);\n            if (cur.equals(endWord)) break;\n                for (String s: map.get(cur)){\n                    if (!visited.contains(s)){\n                        bfs.add(s);\n                        int min = shortPath.get(s);\n                        if (shortPath.get(cur)+1<=min){\n                            min = shortPath.get(cur)+1;\n                            shortPath.put(s,min);\n                            tracer.get(s).add(cur);\n                        }\n                    }\n                }\n        }\n        // System.out.println(shortPath.get(endWord));\n        // for (String s: dict){\n        //     System.out.print(s+\": \" + shortPath.get(s)+\": \");\n        //         for (String si: tracer.get(s)){\n        //             System.out.print(si+\" \");\n        //         }\n        //     System.out.println();\n        // }\n        List<String> temp = new ArrayList<String>();\n        gen(tracer,re,temp,beginWord,endWord);\n        return re;\n    }\n\n    public boolean comp(String s1, String s2){\n        if (s1.length()!=s2.length()) return false;\n        int n = s1.length(); \n        int count =0;\n        for (int i = 0;i<n;i++){\n            if (s1.charAt(i)!=s2.charAt(i))\n                count++;\n            if (count>1) return false;\n        }\n        return true;\n\n    }\n\n    public void gen(HashMap<String,HashSet<String>> tracer,List<List<String>> re, List<String> temp, String beginWord, String cur){\n        temp.add(cur);\n        // System.out.print(cur+\" \");\n        for (String s: tracer.get(cur)){\n            gen(tracer,re,temp,beginWord,s);\n        }\n        if (cur.equals(beginWord)){\n            List<String> t = new ArrayList<>(temp);\n            Collections.reverse(t);\n            re.add(t);\n            // System.out.println();\n        }\n        temp.remove(cur);\n        \n    }   \n}",
  "compare_result": "111111111111111111111111111111110000",
  "flag_type": 1,
  "has_notes": false,
  "id": 1073803125,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 14,
  "status_display": "Time Limit Exceeded",
  "time": "1 month, 1 week",
  "timestamp": 1697145719,
  "title": "Word Ladder II",
  "title_slug": "word-ladder-ii",
  "url": "/submissions/detail/1073803125/"
}{
  "code": "class Solution {\n    public int jump(int[] nums) {\n        int n = nums.length;\n        if (n==1) return 0;\n        int max = 0 + nums[0];\n        int cap = nums[0];\n        int re = 1;\n        for (int i = 1;i<n-1;i++){\n            if (i+ nums[i]>max) {\n                max = i+ nums[i];\n            }\n            if (i == cap){\n                cap = max;\n                re++;\n            }\n        }\n        return re;\n        \n    }\n}",
  "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1073199266,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "44.5 MB",
  "runtime": "1 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697088490,
  "title": "Jump Game II",
  "title_slug": "jump-game-ii",
  "url": "/submissions/detail/1073199266/"
}{
  "code": "class Solution {\n    public int jump(int[] nums) {\n        int n = nums.length;\n        if (n==1) return 0;\n        int max = 0 + nums[0];\n        int cap = nums[0];\n        int re = 1;\n        for (int i = 1;i<n-1;i++){\n            if (i+ nums[i]>max) {\n                max = i+ nums[i];\n            }\n            if (i == cap){\n                cap = max;\n                re++;\n            }\n        }\n        return re;\n        \n    }\n}",
  "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1073199147,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "44.7 MB",
  "runtime": "1 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697088478,
  "title": "Jump Game II",
  "title_slug": "jump-game-ii",
  "url": "/submissions/detail/1073199147/"
}{
  "code": "class Solution {\n    public int jump(int[] nums) {\n        int n = nums.length;\n        if (n==1) return 0;\n        int [] maxPos = new int [n];\n        for(int i = 0;i<n;i++){\n            maxPos[i] = i + nums[i];\n        }\n        int max = maxPos[0];\n        int cap = nums[0];\n        int re = 1;\n        for (int i = 1;i<n-1;i++){\n            if (maxPos[i]>max) {\n                max = maxPos[i];\n            }\n            if (i == cap){\n                cap = max;\n                re++;\n            }\n        }\n        return re;\n        \n    }\n}",
  "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1073198455,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "43.9 MB",
  "runtime": "1 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697088410,
  "title": "Jump Game II",
  "title_slug": "jump-game-ii",
  "url": "/submissions/detail/1073198455/"
}{
  "code": "class Solution {\n    public int jump(int[] nums) {\n        int n = nums.length;\n        if (n==1) return 0;\n        int [] maxPos = new int [n];\n        for(int i = 0;i<n;i++){\n            maxPos[i] = i + nums[i];\n        }\n        int max = maxPos[0];\n        int cap = nums[0];\n        int re = 1;\n        int count = 0;\n        int temp = 0;\n        for (int i = 1;i<n-1;i++){\n            if (maxPos[i]>max) {\n                max = maxPos[i];\n                temp = nums[i];\n            }\n            // count++;\n            if (i == cap){\n                cap = max;\n                // count = 0;\n                re++;\n            }\n        }\n        return re;\n        \n    }\n}",
  "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1073198211,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "44.4 MB",
  "runtime": "2 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697088385,
  "title": "Jump Game II",
  "title_slug": "jump-game-ii",
  "url": "/submissions/detail/1073198211/"
}{
  "code": "class Solution {\n    public int jump(int[] nums) {\n        int n = nums.length;\n        if (n==1) return 0;\n        int [] maxPos = new int [n];\n        for(int i = 0;i<n;i++){\n            maxPos[i] = i + nums[i];\n        }\n        int max = maxPos[0];\n        int cap = nums[0];\n        int re = 0;\n        int count = 0;\n        int temp = 0;\n        for (int i = 1;i<n;i++){\n            if (maxPos[i]>max) {\n                max = maxPos[i];\n                temp = nums[i];\n            }\n            count++;\n            if (count == 1) re ++;\n            if (count == cap){\n                cap = temp;\n                count = 0;\n            }\n        }\n        return re;\n        \n    }\n}",
  "compare_result": "1111111111111111111111111101111101011111111111111111111111111111111010100111001101000000100000111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1073191094,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "1 month, 1 week",
  "timestamp": 1697087684,
  "title": "Jump Game II",
  "title_slug": "jump-game-ii",
  "url": "/submissions/detail/1073191094/"
}{
  "code": "class Solution {\n    public int jump(int[] nums) {\n        int n = nums.length;\n        if (n==1) return 0;\n        int [] maxPos = new int [n];\n        for(int i = 0;i<n;i++){\n            maxPos[i] = i + nums[i];\n        }\n        int max = maxPos[0];\n        int cap = nums[0];\n        int re = 0;\n        int count = 0;\n        for (int i = 1;i<n;i++){\n            if (maxPos[i]>max) max = maxPos[i];\n            count++;\n            if (count == 1) re ++;\n            if (count == cap){\n                cap = max;\n                count = 0;\n            }\n        }\n        return re;\n        \n    }\n}",
  "compare_result": "1111111111011100100111110101111101011100001111111111010110111010000010000000000000000000000000010000001100111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1073189748,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "1 month, 1 week",
  "timestamp": 1697087554,
  "title": "Jump Game II",
  "title_slug": "jump-game-ii",
  "url": "/submissions/detail/1073189748/"
}{
  "code": "class Solution {\n    public int jump(int[] nums) {\n        int n = nums.length;\n        if (n==1) return 0;\n        int [] maxPos = new int [n];\n        for(int i = 0;i<n;i++){\n            maxPos[i] = i + nums[i];\n        }\n        int max = maxPos[0];\n        int cap = nums[0];\n        int re = 1;\n        int count = 0;\n        for (int i = 1;i<n;i++){\n            if (maxPos[i]>max) max = maxPos[i];\n            count++;\n            if (count == cap){\n                cap = max;\n                re ++;\n                count = 0;\n            }\n        }\n        return re;\n        \n    }\n}",
  "compare_result": "1111011110111100110111111100111101011111101011110111010110111110000010000000000000000000000000010000000100100",
  "flag_type": 1,
  "has_notes": false,
  "id": 1073187160,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "1 month, 1 week",
  "timestamp": 1697087300,
  "title": "Jump Game II",
  "title_slug": "jump-game-ii",
  "url": "/submissions/detail/1073187160/"
}{
  "code": "class Solution {\n    public int jump(int[] nums) {\n        if (nums[0] == 0) return 0;\n        int n = nums.length;\n        int [] maxPos = new int [n];\n        for(int i = 0;i<n;i++){\n            maxPos[i] = i + nums[i];\n        }\n        int max = maxPos[0];\n        int cap = nums[0];\n        int re = 1;\n        int count = 0;\n        for (int i = 1;i<n;i++){\n            if (maxPos[i]>max) max = maxPos[i];\n            count++;\n            if (count == cap){\n                cap = max;\n                re ++;\n                count = 0;\n            }\n        }\n        return re;\n        \n    }\n}",
  "compare_result": "1110011110111100110111111100111101011111101011110111010110111110000010000000000000000000000000010000000100100",
  "flag_type": 1,
  "has_notes": false,
  "id": 1073186903,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "1 month, 1 week",
  "timestamp": 1697087274,
  "title": "Jump Game II",
  "title_slug": "jump-game-ii",
  "url": "/submissions/detail/1073186903/"
}{
  "code": "class Solution {\n    public int jump(int[] nums) {\n        int n = nums.length;\n        int [] maxPos = new int [n];\n        for(int i = 0;i<n;i++){\n            maxPos[i] = i + nums[i];\n        }\n        int max = maxPos[0];\n        int cap = nums[0];\n        int re = 1;\n        int count = 0;\n        for (int i = 1;i<n;i++){\n            if (maxPos[i]>max) max = maxPos[i];\n            count++;\n            if (count == cap){\n                cap = max;\n                re ++;\n                count = 0;\n            }\n        }\n        return re;\n        \n    }\n}",
  "compare_result": "1100011110111100110111111100111101011111101011110111010110111110000010000000000000000000000000010000000100100",
  "flag_type": 1,
  "has_notes": false,
  "id": 1073186404,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "1 month, 1 week",
  "timestamp": 1697087229,
  "title": "Jump Game II",
  "title_slug": "jump-game-ii",
  "url": "/submissions/detail/1073186404/"
}{
  "code": "class Solution {\n    public int swimInWater(int[][] grid) {\n        int n = grid.length;\n        PriorityQueue<Data> q = new PriorityQueue<>();\n\n        int cur_x = n-1;\n        int cur_y = n-1;\n        q.add(new Data(grid[cur_x][cur_y],cur_x,cur_y));\n        int max = grid[cur_x][cur_y];\n        boolean [][] marker = new boolean[n][n];\n        // marker[n-1][n-1]= true;\n\n        while (cur_x!=0 || cur_y!=0){\n            Data temp = q.poll();\n            cur_x = temp.x;\n            cur_y = temp.y;\n            marker[cur_x][cur_y] = true;\n            // System.out.println(cur_x+\" \"+cur_y + \" \"+temp.val);\n            if (temp.val > max) max = temp.val;\n            if (cur_x>0 && !marker[cur_x-1][cur_y])\n            {\n                int x = cur_x -1;\n                int y = cur_y;\n                q.add(new Data(grid[x][y],x,y));\n            }\n            if (cur_y>0 && !marker[cur_x][cur_y-1]){\n                int x = cur_x;\n                int y= cur_y - 1;\n                q.add(new Data(grid[x][y],x,y));\n            }\n            if (cur_x+1<n && !marker[cur_x+1][cur_y]){\n                int x = cur_x + 1;\n                int y = cur_y;\n                q.add(new Data(grid[x][y],x,y));\n            }\n            if (cur_y+1<n && !marker[cur_x][cur_y+1]){\n                int x = cur_x;\n                int y = cur_y + 1;\n                q.add(new Data(grid[x][y],x,y));\n            }\n            // for (Data d: q){\n            //     System.out.println(d);\n            // }\n            // System.out.println(\"******\");\n                \n        }\n\n        return max;     \n    }\n}\n\nclass Data implements Comparable<Data>{\n    int val;\n    int x;\n    int y;\n    public Data(int val, int x, int y){\n        this.val = val;\n        this.x = x;\n        this.y = y;\n    }\n        @Override\n    \tpublic int compareTo(Data o) {\n\t\t// TODO Auto-generated method stub\n\t\treturn Integer.compare(val,o.val);\n        }\n\n        @Override\n        public String toString(){\n            return x+\" \"+y+\": \"+val;\n        }\n\t\n}",
  "compare_result": "1111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1073026486,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "43.6 MB",
  "runtime": "17 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697067092,
  "title": "Swim in Rising Water",
  "title_slug": "swim-in-rising-water",
  "url": "/submissions/detail/1073026486/"
}{
  "code": "class Solution {\n    public List<String> findItinerary(List<List<String>> tickets) {\n\t        HashMap<String,List<String>> map = new HashMap<>();\n\t        HashMap<String,Integer> in = new HashMap<>();\n\t        HashMap<String,Integer> out = new HashMap<>();\n\t        List<String> path = new LinkedList<>();\n\t        for (List<String> i : tickets){\n\t            if (map.keySet().contains(i.get(0))){\n\t                map.get(i.get(0)).add(i.get(1));\n\t            } else{\n\t                map.put(i.get(0),new ArrayList<>());\n\t                map.get(i.get(0)).add(i.get(1));\n\t            }\n\t            if (!map.keySet().contains(i.get(1))){\n\t                map.put(i.get(1),new ArrayList<>());\n\t            }\n\t        }\n\t        for (String s : map.keySet()){\n\t            in.put(s,0);\n\t            out.put(s,0);\n\t        }\n\n\t        for (List<String> i:tickets){\n\t            String fr = i.get(0);\n\t            String to = i.get(1);\n\t            out.put(fr,out.get(fr)+1);\n\t            in.put(to,in.get(to)+1);\n\t        }\n            for (String i: map.keySet()){\n                Collections.sort(map.get(i),Collections.reverseOrder());\n            }\n\n\t        //since the problem assume there is a path starting from JFK, im not writing code to check for ecluid path (there is 1 start and 1 end or all equal)\n\t        for (String i : map.keySet()){\n\t            System.out.print(i+\":\");\n\t            for (String j: map.get(i)){\n\t                System.out.print(j+\", \");\n\t            }\n\t            System.out.println(in.get(i)+\" \"+out.get(i));\n\t        }\n\t        dfs(\"JFK\",map,out,path);\n\t        \n\n\t        return path;\n\t        \n\t    }\n\n\t    public void dfs(String cur, HashMap<String,List<String>> map, HashMap<String,Integer> out, List<String> path){\n\t        System.out.println(cur +\" \"+ out.get(cur));\n\t        while(out.get(cur)!=0){\n\t            out.put(cur,out.get(cur)-1);\n\t            dfs(map.get(cur).get(out.get(cur)),map,out,path);\n\n\t            // for (String s:map.get(cur)){\n\t            // }\n\t        }\n\t        path.add(0,cur);\n\t    }\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1072990876,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "44.3 MB",
  "runtime": "49 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697061691,
  "title": "Reconstruct Itinerary",
  "title_slug": "reconstruct-itinerary",
  "url": "/submissions/detail/1072990876/"
}{
  "code": "class Solution {\n    public List<String> findItinerary(List<List<String>> tickets) {\n\t        HashMap<String,List<String>> map = new HashMap<>();\n\t        HashMap<String,Integer> in = new HashMap<>();\n\t        HashMap<String,Integer> out = new HashMap<>();\n\t        List<String> path = new LinkedList<>();\n\t        for (List<String> i : tickets){\n\t            if (map.keySet().contains(i.get(0))){\n\t                map.get(i.get(0)).add(i.get(1));\n\t            } else{\n\t                map.put(i.get(0),new ArrayList<>());\n\t                map.get(i.get(0)).add(i.get(1));\n\t            }\n\t            if (!map.keySet().contains(i.get(1))){\n\t                map.put(i.get(1),new ArrayList<>());\n\t            }\n\t        }\n\t        for (String s : map.keySet()){\n\t            in.put(s,0);\n\t            out.put(s,0);\n\t        }\n\n\t        for (List<String> i:tickets){\n\t            String fr = i.get(0);\n\t            String to = i.get(1);\n\t            out.put(fr,out.get(fr)+1);\n\t            in.put(to,in.get(to)+1);\n\t        }\n            for (String i: map.keySet()){\n                Collections.sort(map.get(i),Collections.reverseOrder());\n            }\n\n\t        //since the problem assume there is a path starting from JFK, im not writing code to check for ecluid path (there is 1 start and 1 end or all equal)\n\t        for (String i : map.keySet()){\n\t            System.out.print(i+\":\");\n\t            for (String j: map.get(i)){\n\t                System.out.print(j+\", \");\n\t            }\n\t            System.out.println(in.get(i)+\" \"+out.get(i));\n\t        }\n\t        dfs(\"JFK\",map,out,path);\n\t        \n\n\t        return path;\n\t        \n\t    }\n\n\t    public void dfs(String cur, HashMap<String,List<String>> map, HashMap<String,Integer> out, List<String> path){\n\t        System.out.println(cur +\" \"+ out.get(cur));\n\t        while(out.get(cur)!=0){\n\t            out.put(cur,out.get(cur)-1);\n\t            dfs(map.get(cur).get(out.get(cur)),map,out,path);\n\n\t            // for (String s:map.get(cur)){\n\t            // }\n\t        }\n\t        path.add(0,cur);\n\t    }\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1072987982,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "44.5 MB",
  "runtime": "50 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697061293,
  "title": "Reconstruct Itinerary",
  "title_slug": "reconstruct-itinerary",
  "url": "/submissions/detail/1072987982/"
}{
  "code": "class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashSet<String> list = new HashSet<String>();\n        for (String s:wordList){\n            list.add(s);\n        }\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        for (String s:list){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        bfs.add(beginWord);\n        shortPath.put(beginWord,1);\n\n        while(!bfs.isEmpty()){\n            String cur = bfs.poll();\n            if (cur.equals(endWord)){\n                break;\n            }\n            int n = cur.length();\n            for (int i=0;i<n;i++){\n                char [] cList = cur.toCharArray();\n                for (char c = 'a';c<='z';c++){\n                    cList[i] = c;\n                    String temp = new String(cList);\n                    // System.out.println(temp);\n                    if (list.contains(temp) && !visited.contains(temp)){\n                        bfs.add(temp);\n                        shortPath.put(temp,Integer.min(shortPath.get(temp),shortPath.get(cur)+1));\n                        visited.add(temp);\n\n                    }\n                }\n            }\n            // break;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1072911648,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "47.4 MB",
  "runtime": "78 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1697052526,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1072911648/"
}{
  "code": "class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        Set<String> set = new HashSet<>(wordList);\n        if (!set.contains(endWord)) return 0;\n\n        Queue<String> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n\n        queue.add(beginWord);\n\n        visited.add(beginWord);\n        int changes = 1;\n        while(!queue.isEmpty()){\n            int size = queue.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = queue.poll();\n                // visited.add(cur);\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] arr = cur.toCharArray();\n                    for (int k = 'a';k<='z';k++){\n                        arr[i] = (char)k;\n                        String temp = new String(arr);\n                        if (set.contains(temp) && !visited.contains(temp)){\n                            queue.add(temp);\n                            visited.add(temp);\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1072229299,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "46.8 MB",
  "runtime": "72 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1696983655,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1072229299/"
}{
  "code": "class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        Set<String> set = new HashSet<>(wordList);\n        if (!set.contains(endWord)) return 0;\n\n        Queue<String> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n\n        queue.add(beginWord);\n\n        visited.add(beginWord);\n        int changes = 1;\n        while(!queue.isEmpty()){\n            int size = queue.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = queue.poll();\n                visited.add(cur);\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] arr = cur.toCharArray();\n                    for (int k = 'a';k<='z';k++){\n                        arr[i] = (char)k;\n                        String temp = new String(arr);\n                        if (set.contains(temp) && !visited.contains(temp)){\n                            queue.add(temp);\n                            visited.add(temp);\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1072229199,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "46.5 MB",
  "runtime": "74 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1696983641,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1072229199/"
}{
  "code": "class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        Set<String> set = new HashSet<>(wordList);\n        if (!set.contains(endWord)) return 0;\n\n        Queue<String> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n\n        queue.add(beginWord);\n\n        visited.add(beginWord);\n        int changes = 1;\n        while(!queue.isEmpty()){\n            int size = queue.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = queue.poll();\n                visited.add(cur);\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] arr = cur.toCharArray();\n                    for (int k = 'a';k<='z';k++){\n                        arr[i] = (char)k;\n                        String temp = new String(arr);\n                        if (set.contains(temp) && !visited.contains(temp)){\n                            queue.add(temp);\n                            visited.add(cur);\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1072229095,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "54 MB",
  "runtime": "1363 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1696983626,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1072229095/"
}{
  "code": "class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        Set<String> set = new HashSet<>(wordList);\n        if (!set.contains(endWord)) return 0;\n\n        Queue<String> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n\n        queue.add(beginWord);\n\n        visited.add(beginWord);\n        int changes = 1;\n        while(!queue.isEmpty()){\n            int size = queue.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = queue.poll();\n                visited.add(cur);\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] arr = cur.toCharArray();\n                    for (int c = 'a';c<='z';c++){\n                        arr[i] = (char)c;\n                        String temp = new String(arr);\n                        if (set.contains(temp) && !visited.contains(temp)){\n                            queue.add(temp);\n                            visited.add(cur);\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1072228950,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "55.1 MB",
  "runtime": "1383 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1696983606,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1072228950/"
}{
  "code": "class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        Set<String> set = new HashSet<>(wordList);\n        if (!set.contains(endWord)) return 0;\n\n        Queue<String> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n\n        queue.add(beginWord);\n\n        visited.add(beginWord);\n        int changes = 1;\n        while(!queue.isEmpty()){\n            int size = queue.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = queue.poll();\n                visited.add(cur);\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] cList = cur.toCharArray();\n                    for (char c = 'a';c<='z';c++){\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        if (set.contains(temp) && !visited.contains(temp)){\n                            queue.add(temp);\n                            visited.add(cur);\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1072228537,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "54.6 MB",
  "runtime": "1347 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1696983538,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1072228537/"
}{
  "code": "class Solution {\n\n    public int ladderLength(String beginWord, String endWord, set<String> wordList) {\n        Set<String> set = new HashSet<>(wordList);\n        if (!set.contains(endWord)) return 0;\n\n        Queue<String> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n\n        queue.add(beginWord);\n\n        visited.add(beginWord);\n        int changes = 1;\n        while(!queue.isEmpty()){\n            int size = queue.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = queue.poll();\n                visited.add(cur);\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] cList = cur.toCharArray();\n                    for (char c = 'a';c<='z';c++){\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        if (set.contains(temp) && !visited.contains(temp)){\n                            queue.add(temp);\n                            visited.add(cur);\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}",
  "compare_result": null,
  "flag_type": 1,
  "has_notes": false,
  "id": 1072228421,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 20,
  "status_display": "Compile Error",
  "time": "1 month, 1 week",
  "timestamp": 1696983519,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1072228421/"
}{
  "code": "class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        Set<String> list = new HashSet<>(wordList);\n        if (!list.contains(endWord)) return 0;\n\n        Queue<String> bfs = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n\n        bfs.add(beginWord);\n\n        visited.add(beginWord);\n        int changes = 1;\n        while(!bfs.isEmpty()){\n            int size = bfs.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = bfs.poll();\n                visited.add(cur);\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] cList = cur.toCharArray();\n                    for (char c = 'a';c<='z';c++){\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        if (list.contains(temp) && !visited.contains(temp)){\n                            bfs.add(temp);\n                            visited.add(cur);\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1072228002,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "54.2 MB",
  "runtime": "1387 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1696983455,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1072228002/"
}{
  "code": "class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        Set<String> list = new HashSet<String>(wordList);\n        if (!list.contains(endWord)) return 0;\n\n        Queue<String> bfs = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n\n        bfs.add(beginWord);\n\n        visited.add(beginWord);\n        int changes = 1;\n        while(!bfs.isEmpty()){\n            int size = bfs.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = bfs.poll();\n                visited.add(cur);\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] cList = cur.toCharArray();\n                    for (char c = 'a';c<='z';c++){\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        if (list.contains(temp) && !visited.contains(temp)){\n                            bfs.add(temp);\n                            visited.add(cur);\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1072227878,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "54.5 MB",
  "runtime": "1363 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1696983437,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1072227878/"
}{
  "code": "class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        HashSet<String> list = new HashSet<String>(wordList);\n        if (!list.contains(endWord)) return 0;\n\n        Queue<String> bfs = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n\n        bfs.add(beginWord);\n\n        visited.add(beginWord);\n        int changes = 1;\n        while(!bfs.isEmpty()){\n            int size = bfs.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = bfs.poll();\n                visited.add(cur);\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] cList = cur.toCharArray();\n                    for (char c = 'a';c<='z';c++){\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        if (list.contains(temp) && !visited.contains(temp)){\n                            bfs.add(temp);\n                            visited.add(cur);\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1072226524,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "54.2 MB",
  "runtime": "1366 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1696983222,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1072226524/"
}{
  "code": "class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        HashSet<String> list = new HashSet<String>(wordList);\n        if (!list.contains(endWord)) return 0;\n\n        Queue<String> bfs = new LinkedList<>();\n        HashSet<String> visited = new HashSet<>();\n\n        bfs.add(beginWord);\n\n        visited.add(beginWord);\n        int changes = 1;\n        while(!bfs.isEmpty()){\n            int size = bfs.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = bfs.poll();\n                visited.add(cur);\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] cList = cur.toCharArray();\n                    for (char c = 'a';c<='z';c++){\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        if (list.contains(temp) && !visited.contains(temp)){\n                            bfs.add(temp);\n                            visited.add(cur);\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1072226008,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "54.5 MB",
  "runtime": "1360 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1696983139,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1072226008/"
}{
  "code": "class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        HashSet<String> list = new HashSet<String>(wordList);\n        if (!list.contains(endWord)) return 0;\n\n        Queue<String> bfs = new LinkedList<>();\n        HashSet<String> visited = new HashSet<>();\n\n        bfs.add(beginWord);\n\n        visited.add(beginWord);\n        int changes = 1;\n        while(!bfs.isEmpty()){\n            int size = bfs.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = bfs.poll();\n                // visited.add(cur);\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    for (char c = 'a';c<='z';c++){\n                        char [] cList = cur.toCharArray();\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        if (list.contains(temp) && !visited.contains(temp)){\n                            bfs.add(temp);\n                            visited.add(cur);\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1072225838,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 14,
  "status_display": "Time Limit Exceeded",
  "time": "1 month, 1 week",
  "timestamp": 1696983114,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1072225838/"
}{
  "code": "class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        HashSet<String> list = new HashSet<String>(wordList);\n        if (!list.contains(endWord)) return 0;\n\n        Queue<String> bfs = new LinkedList<>();\n        HashSet<String> visited = new HashSet<>();\n\n        bfs.add(beginWord);\n\n        visited.add(beginWord);\n        int changes = 1;\n        while(!bfs.isEmpty()){\n            int size = bfs.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = bfs.poll();\n                visited.add(cur);\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    for (char c = 'a';c<='z';c++){\n                        char [] cList = cur.toCharArray();\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        if (list.contains(temp) && !visited.contains(temp)){\n                            bfs.add(temp);\n                            visited.add(cur);\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1072225796,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "54.5 MB",
  "runtime": "1754 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1696983106,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1072225796/"
}{
  "code": "class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        HashSet<String> list = new HashSet<String>(wordList);\n        if (!list.contains(endWord)) return 0;\n\n        Queue<String> bfs = new LinkedList<>();\n        HashSet<String> visited = new HashSet<>();\n\n        bfs.add(beginWord);\n        bfs.add(beginWord);\n\n        visited.add(beginWord);\n        int changes = 1;\n        while(!bfs.isEmpty()){\n            int size = bfs.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = bfs.poll();\n                visited.add(cur);\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] cList = cur.toCharArray();\n                    for (char c = 'a';c<='z';c++){\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        if (list.contains(temp) && !visited.contains(temp)){\n                            bfs.add(temp);\n                            visited.add(cur);\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1072225419,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "54.4 MB",
  "runtime": "1665 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1696983048,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1072225419/"
}{
  "code": "class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        HashSet<String> list = new HashSet<String>(wordList);\n        if (!list.contains(endWord)) return 0;\n\n        Queue<String> bfs = new LinkedList<>();\n        HashSet<String> visited = new HashSet<>();\n\n        bfs.add(beginWord);\n        visited.add(beginWord);\n        int changes = 1;\n        while(!bfs.isEmpty()){\n            int size = bfs.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = bfs.poll();\n                visited.add(cur);\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] cList = cur.toCharArray();\n                    for (char c = 'a';c<='z';c++){\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        if (list.contains(temp) && !visited.contains(temp)){\n                            bfs.add(temp);\n                            visited.add(cur);\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1072225117,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "54.7 MB",
  "runtime": "1383 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1696983003,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1072225117/"
}{
  "code": "class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        HashSet<String> list = new HashSet<String>(wordList);\n        if (!list.contains(endWord)) return 0;\n\n        Queue<String> bfs = new LinkedList<>();\n        HashSet<String> visited = new HashSet<>();\n\n        bfs.add(beginWord);\n        visited.add(beginWord);\n        int changes = 1;\n        while(!bfs.isEmpty()){\n            int size = bfs.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = bfs.poll();\n                visited.add(cur);\n\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] cList = cur.toCharArray();\n                    for (char c = 'a';c<='z';c++){\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        if (list.contains(temp) && !visited.contains(temp)){\n                            bfs.add(temp);\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1072224750,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "54.2 MB",
  "runtime": "1336 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1696982939,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1072224750/"
}{
  "code": "class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        HashSet<String> list = new HashSet<String>(wordList);\n        if (!list.contains(endWord)) return 0;\n\n        Queue<String> bfs = new LinkedList<>();\n        HashSet<String> visited = new HashSet<>();\n        // HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        // for (String s:list){\n        //     shortPath.put(s,Integer.MAX_VALUE);\n        // }\n        bfs.add(beginWord);\n        // shortPath.put(beginWord,1);\n        visited.add(beginWord);\n        int changes = 1;\n        while(!bfs.isEmpty()){\n            int size = bfs.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = bfs.poll();\n                visited.add(cur);\n\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] cList = cur.toCharArray();\n                    for (char c = 'a';c<='z';c++){\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        // System.out.println(temp);\n                        if (list.contains(temp) && !visited.contains(temp)){\n                            bfs.add(temp);\n                            // shortPath.put(temp,Integer.min(shortPath.get(temp),shortPath.get(cur)+1));\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1072224436,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "54.3 MB",
  "runtime": "1347 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1696982886,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1072224436/"
}{
  "code": "class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        HashSet<String> list = new HashSet<String>(wordList);\n        if (!list.contains(endWord)) return 0;\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        // HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        // for (String s:list){\n        //     shortPath.put(s,Integer.MAX_VALUE);\n        // }\n        bfs.add(beginWord);\n        // shortPath.put(beginWord,1);\n        visited.add(beginWord);\n        int changes = 1;\n        while(!bfs.isEmpty()){\n            int size = bfs.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = bfs.poll();\n                visited.add(cur);\n\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] cList = cur.toCharArray();\n                    for (char c = 'a';c<='z';c++){\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        // System.out.println(temp);\n                        if (list.contains(temp) && !visited.contains(temp)){\n                            bfs.add(temp);\n                            // shortPath.put(temp,Integer.min(shortPath.get(temp),shortPath.get(cur)+1));\n\n                        }\n                    }\n                }\n            }\n            ++changes;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1072222162,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "54.8 MB",
  "runtime": "1360 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1696982507,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1072222162/"
}{
  "code": "class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashSet<String> list = new HashSet<String>(wordList);\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        // HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        // for (String s:list){\n        //     shortPath.put(s,Integer.MAX_VALUE);\n        // }\n        bfs.add(beginWord);\n        // shortPath.put(beginWord,1);\n        visited.add(beginWord);\n        int changes = 1;\n        while(!bfs.isEmpty()){\n            int size = bfs.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = bfs.poll();\n                visited.add(cur);\n\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] cList = cur.toCharArray();\n                    for (char c = 'a';c<='z';c++){\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        // System.out.println(temp);\n                        if (list.contains(temp) && !visited.contains(temp)){\n                            bfs.add(temp);\n                            // shortPath.put(temp,Integer.min(shortPath.get(temp),shortPath.get(cur)+1));\n\n                        }\n                    }\n                }\n            }\n            ++changes;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1072218687,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "54.4 MB",
  "runtime": "1371 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1696981956,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1072218687/"
}{
  "code": "class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashSet<String> list = new HashSet<String>(wordList);\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        // HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        // for (String s:list){\n        //     shortPath.put(s,Integer.MAX_VALUE);\n        // }\n        bfs.add(beginWord);\n        // shortPath.put(beginWord,1);\n        visited.add(beginWord);\n        int changes = 1;\n        while(!bfs.isEmpty()){\n            int size = bfs.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = bfs.poll();\n                visited.add(cur);\n\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] cList = cur.toCharArray();\n                    for (char c = 'a';c<='z';c++){\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        // System.out.println(temp);\n                        if (list.contains(temp) && !visited.contains(temp)){\n                            bfs.add(temp);\n                            // shortPath.put(temp,Integer.min(shortPath.get(temp),shortPath.get(cur)+1));\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1072218213,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "54.8 MB",
  "runtime": "1377 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1696981879,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1072218213/"
}{
  "code": "class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashSet<String> list = new HashSet<String>(wordList);\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        // HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        // for (String s:list){\n        //     shortPath.put(s,Integer.MAX_VALUE);\n        // }\n        bfs.add(beginWord);\n        // shortPath.put(beginWord,1);\n        visited.add(beginWord);\n        int changes = 1;\n        while(!bfs.isEmpty()){\n            int size = bfs.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = bfs.poll();\n                visited.add(cur);\n\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    for (char c = 'a';c<='z';c++){\n                        char [] cList = cur.toCharArray();\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        // System.out.println(temp);\n                        if (list.contains(temp) && !visited.contains(temp)){\n                            bfs.add(temp);\n                            // shortPath.put(temp,Integer.min(shortPath.get(temp),shortPath.get(cur)+1));\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1072218044,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "54.6 MB",
  "runtime": "1748 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1696981854,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1072218044/"
}{
  "code": "class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashSet<String> list = new HashSet<String>(wordList);\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        // HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        // for (String s:list){\n        //     shortPath.put(s,Integer.MAX_VALUE);\n        // }\n        bfs.add(beginWord);\n        // shortPath.put(beginWord,1);\n        visited.add(beginWord);\n        int changes = 1;\n        while(!bfs.isEmpty()){\n            int size = bfs.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = bfs.poll();\n                visited.add(cur);\n\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] cList = cur.toCharArray();\n                    for (char c = 'a';c<='z';c++){\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        // System.out.println(temp);\n                        if (list.contains(temp) && !visited.contains(temp)){\n                            bfs.add(temp);\n                            // shortPath.put(temp,Integer.min(shortPath.get(temp),shortPath.get(cur)+1));\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1072217462,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "54.6 MB",
  "runtime": "1353 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1696981764,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1072217462/"
}{
  "code": "class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        Set<String> set = new HashSet<>(wordList);\n        if(!set.contains(endWord)) return 0;\n        \n        Queue<String> queue = new LinkedList<>();\n        queue.add(beginWord);\n        \n        Set<String> visited = new HashSet<>();\n        queue.add(beginWord);\n        \n        int changes = 1;\n        \n        while(!queue.isEmpty()){\n            int size = queue.size();\n            for(int i = 0; i < size; i++){\n                String word = queue.poll();\n                if(word.equals(endWord)) return changes;\n                \n                for(int j = 0; j < word.length(); j++){\n                    for(int k = 'a'; k <= 'z'; k++){\n                        char arr[] = word.toCharArray();\n                        arr[j] = (char) k;\n                        \n                        String str = new String(arr);\n                        if(set.contains(str) && !visited.contains(str)){\n                            queue.add(str);\n                            visited.add(str);\n                        }\n                    }\n                }\n            }\n            ++changes;\n        }\n        return 0;\n    }\n\n\n\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1072216668,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "46.5 MB",
  "runtime": "93 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1696981643,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1072216668/"
}{
  "code": "class Solution {\n\n    ppublic int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        Set<String> set = new HashSet<>(wordList);\n        if(!set.contains(endWord)) return 0;\n        \n        Queue<String> queue = new LinkedList<>();\n        queue.add(beginWord);\n        \n        Set<String> visited = new HashSet<>();\n        queue.add(beginWord);\n        \n        int changes = 1;\n        \n        while(!queue.isEmpty()){\n            int size = queue.size();\n            for(int i = 0; i < size; i++){\n                String word = queue.poll();\n                if(word.equals(endWord)) return changes;\n                \n                for(int j = 0; j < word.length(); j++){\n                    for(int k = 'a'; k <= 'z'; k++){\n                        char arr[] = word.toCharArray();\n                        arr[j] = (char) k;\n                        \n                        String str = new String(arr);\n                        if(set.contains(str) && !visited.contains(str)){\n                            queue.add(str);\n                            visited.add(str);\n                        }\n                    }\n                }\n            }\n            ++changes;\n        }\n        return 0;\n    }\n\n\n\n}",
  "compare_result": null,
  "flag_type": 1,
  "has_notes": false,
  "id": 1072216615,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 20,
  "status_display": "Compile Error",
  "time": "1 month, 1 week",
  "timestamp": 1696981634,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1072216615/"
}{
  "code": "class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashSet<String> list = new HashSet<String>(wordList);\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        // for (String s:list){\n        //     shortPath.put(s,Integer.MAX_VALUE);\n        // }\n        bfs.add(beginWord);\n        shortPath.put(beginWord,1);\n        visited.add(beginWord);\n        int changes = 1;\n        while(!bfs.isEmpty()){\n            int size = bfs.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = bfs.poll();\n                visited.add(cur);\n\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] cList = cur.toCharArray();\n                    for (char c = 'a';c<='z';c++){\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        // System.out.println(temp);\n                        if (list.contains(temp) && !visited.contains(temp)){\n                            bfs.add(temp);\n                            // shortPath.put(temp,Integer.min(shortPath.get(temp),shortPath.get(cur)+1));\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1072216455,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "55 MB",
  "runtime": "1360 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1696981607,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1072216455/"
}{
  "code": "class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashSet<String> list = new HashSet<String>(wordList);\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        // for (String s:list){\n        //     shortPath.put(s,Integer.MAX_VALUE);\n        // }\n        bfs.add(beginWord);\n        shortPath.put(beginWord,1);\n        visited.add(beginWord);\n        int changes = 1;\n        while(!bfs.isEmpty()){\n            int size = bfs.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = bfs.poll();\n                // visited.add(cur);\n\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] cList = cur.toCharArray();\n                    for (char c = 'a';c<='z';c++){\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        // System.out.println(temp);\n                        if (list.contains(temp) && !visited.contains(temp)){\n                            bfs.add(temp);\n                            // shortPath.put(temp,Integer.min(shortPath.get(temp),shortPath.get(cur)+1));\n                            visited.add(cur);\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1072216312,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "54.7 MB",
  "runtime": "2354 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1696981588,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1072216312/"
}{
  "code": "class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashSet<String> list = new HashSet<String>(wordList);\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        // for (String s:list){\n        //     shortPath.put(s,Integer.MAX_VALUE);\n        // }\n        bfs.add(beginWord);\n        shortPath.put(beginWord,1);\n        visited.add(beginWord);\n        int changes = 1;\n        while(!bfs.isEmpty()){\n            int size = bfs.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = bfs.poll();\n                visited.add(cur);\n\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] cList = cur.toCharArray();\n                    for (char c = 'a';c<='z';c++){\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        // System.out.println(temp);\n                        if (list.contains(temp) && !visited.contains(temp)){\n                            bfs.add(temp);\n                            // shortPath.put(temp,Integer.min(shortPath.get(temp),shortPath.get(cur)+1));\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1072215742,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "54.4 MB",
  "runtime": "1329 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1696981495,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1072215742/"
}{
  "code": "class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashSet<String> list = new HashSet<String>(wordList);\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        // for (String s:list){\n        //     shortPath.put(s,Integer.MAX_VALUE);\n        // }\n        bfs.add(beginWord);\n        shortPath.put(beginWord,1);\n        visited.add(beginWord);\n        int changes = 1;\n        while(!bfs.isEmpty()){\n            int size = bfs.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = bfs.poll();\n                visited.add(cur);\n\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] cList = cur.toCharArray();\n                    for (char c = 'a';c<='z';c++){\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        // System.out.println(temp);\n                        if (list.contains(temp) && !visited.contains(temp)){\n                            bfs.add(temp);\n                            // shortPath.put(temp,Integer.min(shortPath.get(temp),shortPath.get(cur)+1));\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1072215681,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "54.5 MB",
  "runtime": "1354 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1696981485,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1072215681/"
}{
  "code": "class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashSet<String> list = new HashSet<String>(wordList);\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        for (String s:list){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        bfs.add(beginWord);\n        shortPath.put(beginWord,1);\n        visited.add(beginWord);\n\n        while(!bfs.isEmpty()){\n            String cur = bfs.poll();\n            visited.add(cur);\n\n            if (cur.equals(endWord)){\n                return shortPath.get(endWord);\n            }\n            int n = cur.length();\n            for (int i=0;i<n;i++){\n                char [] cList = cur.toCharArray();\n                for (char c = 'a';c<='z';c++){\n                    cList[i] = c;\n                    String temp = new String(cList);\n                    // System.out.println(temp);\n                    if (list.contains(temp) && !visited.contains(temp)){\n                        bfs.add(temp);\n                        shortPath.put(temp,Integer.min(shortPath.get(temp),shortPath.get(cur)+1));\n\n                    }\n                }\n            }\n            // break;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1072213925,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "54.3 MB",
  "runtime": "1366 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1696981200,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1072213925/"
}{
  "code": "class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashSet<String> list = new HashSet<String>(wordList);\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        for (String s:list){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        bfs.add(beginWord);\n        shortPath.put(beginWord,1);\n        visited.add(beginWord);\n\n        while(!bfs.isEmpty()){\n            String cur = bfs.poll();\n            if (cur.equals(endWord)){\n                return shortPath.get(endWord);\n            }\n            int n = cur.length();\n            for (int i=0;i<n;i++){\n                char [] cList = cur.toCharArray();\n                for (char c = 'a';c<='z';c++){\n                    cList[i] = c;\n                    String temp = new String(cList);\n                    // System.out.println(temp);\n                    if (list.contains(temp) && !visited.contains(temp)){\n                        bfs.add(temp);\n                        shortPath.put(temp,Integer.min(shortPath.get(temp),shortPath.get(cur)+1));\n                        visited.add(cur);\n\n                    }\n                }\n            }\n            // break;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1072213596,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "55 MB",
  "runtime": "2338 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1696981144,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1072213596/"
}{
  "code": "class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashSet<String> list = new HashSet<String>(wordList);\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        for (String s:list){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        bfs.add(beginWord);\n        shortPath.put(beginWord,1);\n\n        while(!bfs.isEmpty()){\n            String cur = bfs.poll();\n            if (cur.equals(endWord)){\n                return shortPath.get(endWord);\n            }\n            int n = cur.length();\n            for (int i=0;i<n;i++){\n                char [] cList = cur.toCharArray();\n                for (char c = 'a';c<='z';c++){\n                    cList[i] = c;\n                    String temp = new String(cList);\n                    // System.out.println(temp);\n                    if (list.contains(temp) && !visited.contains(temp)){\n                        bfs.add(temp);\n                        shortPath.put(temp,Integer.min(shortPath.get(temp),shortPath.get(cur)+1));\n                        visited.add(cur);\n\n                    }\n                }\n            }\n            // break;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1072213444,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "54.4 MB",
  "runtime": "2443 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1696981120,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1072213444/"
}{
  "code": "class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashSet<String> list = new HashSet<String>(wordList);\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        for (String s:list){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        bfs.add(beginWord);\n        shortPath.put(beginWord,1);\n\n        while(!bfs.isEmpty()){\n            String cur = bfs.poll();\n            if (cur.equals(endWord)){\n                return shortPath.get(endWord);\n            }\n            int n = cur.length();\n            for (int i=0;i<n;i++){\n                char [] cList = cur.toCharArray();\n                for (char c = 'a';c<='z';c++){\n                    cList[i] = c;\n                    String temp = new String(cList);\n                    // System.out.println(temp);\n                    if (list.contains(temp) && !visited.contains(temp)){\n                        bfs.add(temp);\n                        shortPath.put(temp,Integer.min(shortPath.get(temp),shortPath.get(cur)+1));\n                        visited.add(cur);\n\n                    }\n                }\n            }\n            // break;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1072213356,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "54.6 MB",
  "runtime": "2416 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1696981106,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1072213356/"
}{
  "code": "class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashSet<String> list = new HashSet<String>(wordList);\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        for (String s:list){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        bfs.add(beginWord);\n        shortPath.put(beginWord,1);\n\n        while(!bfs.isEmpty()){\n            String cur = bfs.poll();\n            if (cur.equals(endWord)){\n                return shortPath.get(endWord);\n            }\n            visited.add(cur);\n            int n = cur.length();\n            for (int i=0;i<n;i++){\n                char [] cList = cur.toCharArray();\n                for (char c = 'a';c<='z';c++){\n                    cList[i] = c;\n                    String temp = new String(cList);\n                    // System.out.println(temp);\n                    if (list.contains(temp) && !visited.contains(temp)){\n                        bfs.add(temp);\n                        shortPath.put(temp,Integer.min(shortPath.get(temp),shortPath.get(cur)+1));\n                    }\n                }\n            }\n            // break;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1072212427,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "54.6 MB",
  "runtime": "1356 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1696980956,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1072212427/"
}{
  "code": "class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashSet<String> list = new HashSet<String>(wordList);\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        for (String s:list){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        bfs.add(beginWord);\n        shortPath.put(beginWord,1);\n\n        while(!bfs.isEmpty()){\n            String cur = bfs.poll();\n            if (cur.equals(endWord)){\n                break;\n            }\n            visited.add(cur);\n            int n = cur.length();\n            for (int i=0;i<n;i++){\n                char [] cList = cur.toCharArray();\n                for (char c = 'a';c<='z';c++){\n                    cList[i] = c;\n                    String temp = new String(cList);\n                    // System.out.println(temp);\n                    if (list.contains(temp) && !visited.contains(temp)){\n                        bfs.add(temp);\n                        shortPath.put(temp,Integer.min(shortPath.get(temp),shortPath.get(cur)+1));\n                    }\n                }\n            }\n            // break;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1072211942,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "54.8 MB",
  "runtime": "1378 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1696980877,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1072211942/"
}{
  "code": "class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashSet<String> list = new HashSet<String>();\n        for (String s:wordList){\n            list.add(s);\n        }\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        for (String s:list){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        bfs.add(beginWord);\n        shortPath.put(beginWord,1);\n\n        while(!bfs.isEmpty()){\n            String cur = bfs.poll();\n            if (cur.equals(endWord)){\n                break;\n            }\n            visited.add(cur);\n            int n = cur.length();\n            for (int i=0;i<n;i++){\n                char [] cList = cur.toCharArray();\n                for (char c = 'a';c<='z';c++){\n                    cList[i] = c;\n                    String temp = new String(cList);\n                    // System.out.println(temp);\n                    if (list.contains(temp) && !visited.contains(temp)){\n                        bfs.add(temp);\n                        shortPath.put(temp,Integer.min(shortPath.get(temp),shortPath.get(cur)+1));\n                    }\n                }\n            }\n            // break;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1072211632,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "54.5 MB",
  "runtime": "1434 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1696980831,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1072211632/"
}{
  "code": "class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashSet<String> list = new HashSet<String>();\n        for (String s:wordList){\n            list.add(s);\n        }\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        for (String s:list){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        bfs.add(beginWord);\n        shortPath.put(beginWord,1);\n\n        while(!bfs.isEmpty()){\n            String cur = bfs.poll();\n            if (cur.equals(endWord)){\n                break;\n            }\n            visited.add(cur);\n            int n = cur.length();\n            for (int i=0;i<n;i++){\n                char [] cList = cur.toCharArray();\n                for (char c = 'a';c<='z';c++){\n                    cList[i] = c;\n                    // String temp = new String(cList);\n                    System.out.println(temp);\n                    if (list.contains(temp) && !visited.contains(temp)){\n                        bfs.add(temp);\n                        shortPath.put(temp,Integer.min(shortPath.get(temp),shortPath.get(cur)+1));\n                    }\n                }\n            }\n            // break;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n\n}",
  "compare_result": null,
  "flag_type": 1,
  "has_notes": false,
  "id": 1072211551,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 20,
  "status_display": "Compile Error",
  "time": "1 month, 1 week",
  "timestamp": 1696980817,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1072211551/"
}{
  "code": "class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        Set<String> set = new HashSet<>(wordList);\n        if(!set.contains(endWord)) return 0;\n        \n        Queue<String> queue = new LinkedList<>();\n        queue.add(beginWord);\n        \n        Set<String> visited = new HashSet<>();\n        queue.add(beginWord);\n        \n        int changes = 1;\n        \n        while(!queue.isEmpty()){\n            int size = queue.size();\n            for(int i = 0; i < size; i++){\n                String word = queue.poll();\n                if(word.equals(endWord)) return changes;\n                \n                for(int j = 0; j < word.length(); j++){\n                    for(int k = 'a'; k <= 'z'; k++){\n                        char arr[] = word.toCharArray();\n                        arr[j] = (char) k;\n                        \n                        String str = new String(arr);\n                        if(set.contains(str) && !visited.contains(str)){\n                            queue.add(str);\n                            visited.add(str);\n                        }\n                    }\n                }\n            }\n            ++changes;\n        }\n        return 0;\n    }\n\n\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1072178071,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "46.6 MB",
  "runtime": "94 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 1 week",
  "timestamp": 1696975815,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1072178071/"
}{
  "code": "class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        // for (String s: map.keySet()){\n        //     if (s.equals(\"ito\")){\n        //         System.out.print(s + \": \");\n        //         for (String is:map.get(s)){\n        //             System.out.print(is+\", \");\n        //         }\n        //         System.out.println();\n        //     }\n        // }\n\n        HashSet<String> visited = new HashSet<String>();\n        Queue<String> bfs = new LinkedList<String>();\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        for (String s:map.keySet()){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        bfs.add(beginWord);\n        shortPath.put(beginWord,1);\n        String cur = \"\";\n        int count =0;\n        // boolean check = false;\n\n        while (!bfs.isEmpty())\n        {\n            cur = bfs.poll();\n            visited.add(cur);\n            if (cur.equals(endWord)){\n                break;\n            }\n            for (String s:map.get(cur)){\n                if (!visited.contains(s))\n                {\n                    bfs.add(s);\n                    shortPath.put(s,Integer.min(shortPath.get(s),shortPath.get(cur)+1));\n                    // if (s.equals(endWord)){\n                    //     check = true;\n                    //     break;\n                    // } ;\n                }\n            }\n            // if (check) break;\n        }\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n        // HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        // HashSet<String> visited = new HashSet<String>();\n        // // visisted.add(beginWord);\n        // String cur = beginWord;\n        // for (String s:map.keySet()){\n        //     shortPath.put(s,Integer.MAX_VALUE);\n        // }\n        // HashSet<String> tempSet = new HashSet<String>();\n        // shortPath.put(beginWord,1);\n        // while (!visited.contains(endWord)){\n        //     // System.out.println(\"dasdsa: \"+cur);\n        //     if (cur.equals(\"\")) break;\n        //     // System.out.println(shortPath.get(cur));\n        //     for (String s: map.get(cur)){\n        //         // System.out.println(s + \" \"+shortPath.get(s));\n\n        //         if (shortPath.get(s)>shortPath.get(cur)+1){\n        //             shortPath.put(s,shortPath.get(cur)+1);\n        //             // System.out.println(\"x\");\n        //             tempSet.add(s);\n\n        //         }\n        //     }\n        //     String temp = \"\";\n        //     int min = Integer.MAX_VALUE;\n        //     for (String s:tempSet){\n        //         if (!visited.contains(s)){\n        //             if (shortPath.get(s)<min){\n        //                 min = shortPath.get(s);\n        //                 temp = s;\n        //             }\n        //         }\n        //     }\n        //     tempSet.remove(temp);\n        //     visited.add(cur);\n        //     cur = temp;\n        // }\n\n        // return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n            if (count >1) return false;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1072149282,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "49.5 MB",
  "runtime": "1074 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 2 weeks",
  "timestamp": 1696972126,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1072149282/"
}{
  "code": "class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        // for (String s: map.keySet()){\n        //     if (s.equals(\"ito\")){\n        //         System.out.print(s + \": \");\n        //         for (String is:map.get(s)){\n        //             System.out.print(is+\", \");\n        //         }\n        //         System.out.println();\n        //     }\n        // }\n\n        HashSet<String> visited = new HashSet<String>();\n        Queue<String> bfs = new LinkedList<String>();\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        for (String s:map.keySet()){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        bfs.add(beginWord);\n        shortPath.put(beginWord,1);\n        String cur = \"\";\n        int count =0;\n        // boolean check = false;\n\n        while (!bfs.isEmpty())\n        {\n            cur = bfs.poll();\n            visited.add(cur);\n            if (cur.equals(endWord)){\n                break;\n            }\n            for (String s:map.get(cur)){\n                if (!visited.contains(s))\n                {\n                    bfs.add(s);\n                    shortPath.put(s,Integer.min(shortPath.get(s),shortPath.get(cur)+1));\n                    // if (s.equals(endWord)){\n                    //     check = true;\n                    //     break;\n                    // } ;\n                }\n            }\n            // if (check) break;\n        }\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n        // HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        // HashSet<String> visited = new HashSet<String>();\n        // // visisted.add(beginWord);\n        // String cur = beginWord;\n        // for (String s:map.keySet()){\n        //     shortPath.put(s,Integer.MAX_VALUE);\n        // }\n        // HashSet<String> tempSet = new HashSet<String>();\n        // shortPath.put(beginWord,1);\n        // while (!visited.contains(endWord)){\n        //     // System.out.println(\"dasdsa: \"+cur);\n        //     if (cur.equals(\"\")) break;\n        //     // System.out.println(shortPath.get(cur));\n        //     for (String s: map.get(cur)){\n        //         // System.out.println(s + \" \"+shortPath.get(s));\n\n        //         if (shortPath.get(s)>shortPath.get(cur)+1){\n        //             shortPath.put(s,shortPath.get(cur)+1);\n        //             // System.out.println(\"x\");\n        //             tempSet.add(s);\n\n        //         }\n        //     }\n        //     String temp = \"\";\n        //     int min = Integer.MAX_VALUE;\n        //     for (String s:tempSet){\n        //         if (!visited.contains(s)){\n        //             if (shortPath.get(s)<min){\n        //                 min = shortPath.get(s);\n        //                 temp = s;\n        //             }\n        //         }\n        //     }\n        //     tempSet.remove(temp);\n        //     visited.add(cur);\n        //     cur = temp;\n        // }\n\n        // return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n            if (count >1) return false;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1072149191,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "49.4 MB",
  "runtime": "1074 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 2 weeks",
  "timestamp": 1696972115,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1072149191/"
}{
  "code": "class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        // for (String s: map.keySet()){\n        //     if (s.equals(\"ito\")){\n        //         System.out.print(s + \": \");\n        //         for (String is:map.get(s)){\n        //             System.out.print(is+\", \");\n        //         }\n        //         System.out.println();\n        //     }\n        // }\n\n        HashSet<String> visited = new HashSet<String>();\n        Queue<String> bfs = new LinkedList<String>();\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        for (String s:map.keySet()){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        bfs.add(beginWord);\n        shortPath.put(beginWord,1);\n        String cur = \"\";\n        int count =0;\n        // boolean check = false;\n\n        while (!bfs.isEmpty())\n        {\n            cur = bfs.poll();\n            if (cur.equals(endWord)){\n                break;\n            }\n            for (String s:map.get(cur)){\n                if (!visited.contains(s))\n                {\n                    bfs.add(s);\n                    shortPath.put(s,Integer.min(shortPath.get(s),shortPath.get(cur)+1));\n                    // if (s.equals(endWord)){\n                    //     check = true;\n                    //     break;\n                    // } ;\n                }\n            }\n            // if (check) break;\n        }\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n        // HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        // HashSet<String> visited = new HashSet<String>();\n        // // visisted.add(beginWord);\n        // String cur = beginWord;\n        // for (String s:map.keySet()){\n        //     shortPath.put(s,Integer.MAX_VALUE);\n        // }\n        // HashSet<String> tempSet = new HashSet<String>();\n        // shortPath.put(beginWord,1);\n        // while (!visited.contains(endWord)){\n        //     // System.out.println(\"dasdsa: \"+cur);\n        //     if (cur.equals(\"\")) break;\n        //     // System.out.println(shortPath.get(cur));\n        //     for (String s: map.get(cur)){\n        //         // System.out.println(s + \" \"+shortPath.get(s));\n\n        //         if (shortPath.get(s)>shortPath.get(cur)+1){\n        //             shortPath.put(s,shortPath.get(cur)+1);\n        //             // System.out.println(\"x\");\n        //             tempSet.add(s);\n\n        //         }\n        //     }\n        //     String temp = \"\";\n        //     int min = Integer.MAX_VALUE;\n        //     for (String s:tempSet){\n        //         if (!visited.contains(s)){\n        //             if (shortPath.get(s)<min){\n        //                 min = shortPath.get(s);\n        //                 temp = s;\n        //             }\n        //         }\n        //     }\n        //     tempSet.remove(temp);\n        //     visited.add(cur);\n        //     cur = temp;\n        // }\n\n        // return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n            if (count >1) return false;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}",
  "compare_result": "111111111111111110000000000000000000000000000000000",
  "flag_type": 1,
  "has_notes": false,
  "id": 1072148772,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 14,
  "status_display": "Time Limit Exceeded",
  "time": "1 month, 2 weeks",
  "timestamp": 1696972067,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1072148772/"
}{
  "code": "class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        // for (String s: map.keySet()){\n        //     if (s.equals(\"ito\")){\n        //         System.out.print(s + \": \");\n        //         for (String is:map.get(s)){\n        //             System.out.print(is+\", \");\n        //         }\n        //         System.out.println();\n        //     }\n        // }\n\n        HashSet<String> visited = new HashSet<String>();\n        Queue<String> bfs = new LinkedList<String>();\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        for (String s:map.keySet()){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        bfs.add(beginWord);\n        shortPath.put(beginWord,1);\n        String cur = \"\";\n        int count =0;\n        // boolean check = false;\n\n        while (!bfs.isEmpty())\n        {\n            cur = bfs.poll();\n            if (cur.equals(endWord)){\n                break;\n            }\n            for (String s:map.get(cur)){\n                if (!visited.contains(s))\n                {\n                    bfs.add(s);\n                    shortPath.put(s,Integer.min(shortPath.get(s),shortPath.get(cur)+1));\n                    // if (s.equals(endWord)){\n                    //     check = true;\n                    //     break;\n                    // } ;\n                }\n            }\n            // if (check) break;\n        }\n        return shortPath.get(endWord);\n        // HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        // HashSet<String> visited = new HashSet<String>();\n        // // visisted.add(beginWord);\n        // String cur = beginWord;\n        // for (String s:map.keySet()){\n        //     shortPath.put(s,Integer.MAX_VALUE);\n        // }\n        // HashSet<String> tempSet = new HashSet<String>();\n        // shortPath.put(beginWord,1);\n        // while (!visited.contains(endWord)){\n        //     // System.out.println(\"dasdsa: \"+cur);\n        //     if (cur.equals(\"\")) break;\n        //     // System.out.println(shortPath.get(cur));\n        //     for (String s: map.get(cur)){\n        //         // System.out.println(s + \" \"+shortPath.get(s));\n\n        //         if (shortPath.get(s)>shortPath.get(cur)+1){\n        //             shortPath.put(s,shortPath.get(cur)+1);\n        //             // System.out.println(\"x\");\n        //             tempSet.add(s);\n\n        //         }\n        //     }\n        //     String temp = \"\";\n        //     int min = Integer.MAX_VALUE;\n        //     for (String s:tempSet){\n        //         if (!visited.contains(s)){\n        //             if (shortPath.get(s)<min){\n        //                 min = shortPath.get(s);\n        //                 temp = s;\n        //             }\n        //         }\n        //     }\n        //     tempSet.remove(temp);\n        //     visited.add(cur);\n        //     cur = temp;\n        // }\n\n        // return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n            if (count >1) return false;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}",
  "compare_result": "111011111111111010000000000000000000000000000000000",
  "flag_type": 1,
  "has_notes": false,
  "id": 1072148434,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "1 month, 2 weeks",
  "timestamp": 1696972031,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1072148434/"
}{
  "code": "class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        // for (String s: map.keySet()){\n        //     if (s.equals(\"ito\")){\n        //         System.out.print(s + \": \");\n        //         for (String is:map.get(s)){\n        //             System.out.print(is+\", \");\n        //         }\n        //         System.out.println();\n        //     }\n        // }\n\n        HashSet<String> visited = new HashSet<String>();\n        Queue<String> bfs = new LinkedList<String>();\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        for (String s:map.keySet()){\n            shortPath.put(s,0);\n        }\n        bfs.add(beginWord);\n        shortPath.put(beginWord,1);\n        String cur = \"\";\n        int count =0;\n        boolean check = false;\n\n        while (!bfs.isEmpty())\n        {\n            cur = bfs.poll();\n            if (cur.equals(endWord)){\n                break;\n            }\n            for (String s:map.get(cur)){\n                if (!visited.contains(s))\n                {\n                    bfs.add(s);\n                    shortPath.put(s,shortPath.get(cur)+1);\n                    if (s.equals(endWord)){\n                        check = true;\n                        break;\n                    } ;\n                }\n            }\n            if (check) break;\n        }\n        return cur.equals(endWord)|check?shortPath.get(endWord):0;\n        // HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        // HashSet<String> visited = new HashSet<String>();\n        // // visisted.add(beginWord);\n        // String cur = beginWord;\n        // for (String s:map.keySet()){\n        //     shortPath.put(s,Integer.MAX_VALUE);\n        // }\n        // HashSet<String> tempSet = new HashSet<String>();\n        // shortPath.put(beginWord,1);\n        // while (!visited.contains(endWord)){\n        //     // System.out.println(\"dasdsa: \"+cur);\n        //     if (cur.equals(\"\")) break;\n        //     // System.out.println(shortPath.get(cur));\n        //     for (String s: map.get(cur)){\n        //         // System.out.println(s + \" \"+shortPath.get(s));\n\n        //         if (shortPath.get(s)>shortPath.get(cur)+1){\n        //             shortPath.put(s,shortPath.get(cur)+1);\n        //             // System.out.println(\"x\");\n        //             tempSet.add(s);\n\n        //         }\n        //     }\n        //     String temp = \"\";\n        //     int min = Integer.MAX_VALUE;\n        //     for (String s:tempSet){\n        //         if (!visited.contains(s)){\n        //             if (shortPath.get(s)<min){\n        //                 min = shortPath.get(s);\n        //                 temp = s;\n        //             }\n        //         }\n        //     }\n        //     tempSet.remove(temp);\n        //     visited.add(cur);\n        //     cur = temp;\n        // }\n\n        // return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n            if (count >1) return false;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}",
  "compare_result": "111111101111111110000000000000000000000000000000000",
  "flag_type": 1,
  "has_notes": false,
  "id": 1072146506,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "1 month, 2 weeks",
  "timestamp": 1696971800,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1072146506/"
}{
  "code": "class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        // for (String s: map.keySet()){\n        //     if (s.equals(\"ito\")){\n        //         System.out.print(s + \": \");\n        //         for (String is:map.get(s)){\n        //             System.out.print(is+\", \");\n        //         }\n        //         System.out.println();\n        //     }\n        // }\n\n        HashSet<String> visited = new HashSet<String>();\n        Queue<String> bfs = new LinkedList<String>();\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        for (String s:map.keySet()){\n            shortPath.put(s,0);\n        }\n        bfs.add(beginWord);\n        shortPath.put(beginWord,0);\n        String cur = \"\";\n        int count =0;\n        while (!bfs.isEmpty())\n        {\n            cur = bfs.poll();\n            if (cur.equals(endWord)){\n                break;\n            }\n            for (String s:map.get(cur)){\n                if (!visited.contains(s))\n                    bfs.add(s);\n                    shortPath.put(s,shortPath.get(cur)+1);\n            }\n        }\n        return cur.equals(endWord)?shortPath.get(endWord):0;\n        // HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        // HashSet<String> visited = new HashSet<String>();\n        // // visisted.add(beginWord);\n        // String cur = beginWord;\n        // for (String s:map.keySet()){\n        //     shortPath.put(s,Integer.MAX_VALUE);\n        // }\n        // HashSet<String> tempSet = new HashSet<String>();\n        // shortPath.put(beginWord,1);\n        // while (!visited.contains(endWord)){\n        //     // System.out.println(\"dasdsa: \"+cur);\n        //     if (cur.equals(\"\")) break;\n        //     // System.out.println(shortPath.get(cur));\n        //     for (String s: map.get(cur)){\n        //         // System.out.println(s + \" \"+shortPath.get(s));\n\n        //         if (shortPath.get(s)>shortPath.get(cur)+1){\n        //             shortPath.put(s,shortPath.get(cur)+1);\n        //             // System.out.println(\"x\");\n        //             tempSet.add(s);\n\n        //         }\n        //     }\n        //     String temp = \"\";\n        //     int min = Integer.MAX_VALUE;\n        //     for (String s:tempSet){\n        //         if (!visited.contains(s)){\n        //             if (shortPath.get(s)<min){\n        //                 min = shortPath.get(s);\n        //                 temp = s;\n        //             }\n        //         }\n        //     }\n        //     tempSet.remove(temp);\n        //     visited.add(cur);\n        //     cur = temp;\n        // }\n\n        // return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n            if (count >1) return false;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}",
  "compare_result": "111100111100100110000000000000000000000000000000000",
  "flag_type": 1,
  "has_notes": false,
  "id": 1072144424,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "1 month, 2 weeks",
  "timestamp": 1696971558,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1072144424/"
}{
  "code": "class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        // for (String s: map.keySet()){\n        //     if (s.equals(\"ito\")){\n        //         System.out.print(s + \": \");\n        //         for (String is:map.get(s)){\n        //             System.out.print(is+\", \");\n        //         }\n        //         System.out.println();\n        //     }\n        // }\n\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        HashSet<String> visited = new HashSet<String>();\n        // visisted.add(beginWord);\n        String cur = beginWord;\n        for (String s:map.keySet()){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        HashSet<String> tempSet = new HashSet<String>();\n        shortPath.put(beginWord,1);\n        while (!visited.contains(endWord)){\n            // System.out.println(\"dasdsa: \"+cur);\n            if (cur.equals(\"\")) break;\n            // System.out.println(shortPath.get(cur));\n            for (String s: map.get(cur)){\n                // System.out.println(s + \" \"+shortPath.get(s));\n\n                if (shortPath.get(s)>shortPath.get(cur)+1){\n                    shortPath.put(s,shortPath.get(cur)+1);\n                    // System.out.println(\"x\");\n                    tempSet.add(s);\n\n                }\n            }\n            String temp = \"\";\n            int min = Integer.MAX_VALUE;\n            for (String s:tempSet){\n                if (!visited.contains(s)){\n                    if (shortPath.get(s)<min){\n                        min = shortPath.get(s);\n                        temp = s;\n                    }\n                }\n            }\n            tempSet.remove(temp);\n            visited.add(cur);\n            cur = temp;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n            if (count >1) return false;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1072131321,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "48.6 MB",
  "runtime": "1164 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 2 weeks",
  "timestamp": 1696970119,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1072131321/"
}{
  "code": "class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        // for (String s: map.keySet()){\n        //     if (s.equals(\"ito\")){\n        //         System.out.print(s + \": \");\n        //         for (String is:map.get(s)){\n        //             System.out.print(is+\", \");\n        //         }\n        //         System.out.println();\n        //     }\n        // }\n\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        HashSet<String> visited = new HashSet<String>();\n        // visisted.add(beginWord);\n        String cur = beginWord;\n        for (String s:map.keySet()){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        HashSet<String> tempSet = new HashSet<String>();\n        shortPath.put(beginWord,1);\n        while (!visited.contains(endWord)){\n            // System.out.println(\"dasdsa: \"+cur);\n            if (cur.equals(\"\")) break;\n            // System.out.println(shortPath.get(cur));\n            for (String s: map.get(cur)){\n                // System.out.println(s + \" \"+shortPath.get(s));\n\n                if (shortPath.get(s)>shortPath.get(cur)+1){\n                    shortPath.put(s,shortPath.get(cur)+1);\n                    // System.out.println(\"x\");\n                    tempSet.add(s);\n\n                }\n            }\n            String temp = \"\";\n            int min = Integer.MAX_VALUE;\n            for (String s:tempSet){\n                if (!visited.contains(s)){\n                    if (shortPath.get(s)<min){\n                        min = shortPath.get(s);\n                        temp = s;\n                    }\n                }\n            }\n            tempSet.remove(temp);\n            visited.add(cur);\n            cur = temp;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n            if (count >1) return false;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1072131187,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "48.6 MB",
  "runtime": "1164 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 2 weeks",
  "timestamp": 1696970106,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1072131187/"
}{
  "code": "class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        // for (String s: map.keySet()){\n        //     if (s.equals(\"ito\")){\n        //         System.out.print(s + \": \");\n        //         for (String is:map.get(s)){\n        //             System.out.print(is+\", \");\n        //         }\n        //         System.out.println();\n        //     }\n        // }\n\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        HashSet<String> visited = new HashSet<String>();\n        // visisted.add(beginWord);\n        String cur = beginWord;\n        for (String s:map.keySet()){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        HashSet<String> tempSet = new HashSet<String>();\n        shortPath.put(beginWord,1);\n        while (!visited.contains(endWord)){\n            // System.out.println(\"dasdsa: \"+cur);\n            if (cur.equals(\"\")) break;\n            // System.out.println(shortPath.get(cur));\n            for (String s: map.get(cur)){\n                // System.out.println(s + \" \"+shortPath.get(s));\n\n                if (shortPath.get(s)>shortPath.get(cur)+1){\n                    shortPath.put(s,shortPath.get(cur)+1);\n                    // System.out.println(\"x\");\n                    tempSet.add(s);\n\n                }\n            }\n            String temp = \"\";\n            int min = Integer.MAX_VALUE;\n            for (String s:tempSet){\n                if (!visited.contains(s)){\n                    if (shortPath.get(s)<min){\n                        min = shortPath.get(s);\n                        temp = s;\n                    }\n                }\n            }\n\n            visited.add(cur);\n            cur = temp;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n            if (count >1) return false;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1072130397,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "48 MB",
  "runtime": "2159 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 2 weeks",
  "timestamp": 1696970021,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1072130397/"
}{
  "code": "class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        // for (String s: map.keySet()){\n        //     if (s.equals(\"ito\")){\n        //         System.out.print(s + \": \");\n        //         for (String is:map.get(s)){\n        //             System.out.print(is+\", \");\n        //         }\n        //         System.out.println();\n        //     }\n        // }\n\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        HashSet<String> visited = new HashSet<String>();\n        // visisted.add(beginWord);\n        String cur = beginWord;\n        for (String s:map.keySet()){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        HashSet<String> tempSet = new HashSet<String>();\n        shortPath.put(beginWord,1);\n        while (!visited.contains(endWord)){\n            // System.out.println(\"dasdsa: \"+cur);\n            if (cur.equals(\"\")) break;\n            // System.out.println(shortPath.get(cur));\n            for (String s: map.get(cur)){\n                // System.out.println(s + \" \"+shortPath.get(s));\n\n                if (shortPath.get(s)>shortPath.get(cur)+1){\n                    shortPath.put(s,shortPath.get(cur)+1);\n                    // System.out.println(\"x\");\n                    tempSet.add(s);\n\n                }\n            }\n            String temp = \"\";\n            int min = Integer.MAX_VALUE;\n            for (String s:tempSet){\n                if (!visited.contains(s)){\n                    if (shortPath.get(s)<min){\n                        min = shortPath.get(s);\n                        temp = s;\n                    }\n                }\n            }\n\n            visited.add(cur);\n            cur = temp;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n            if (count >1) return false;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1072130262,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "48.1 MB",
  "runtime": "2154 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 2 weeks",
  "timestamp": 1696970007,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1072130262/"
}{
  "code": "class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        // for (String s: map.keySet()){\n        //     if (s.equals(\"ito\")){\n        //         System.out.print(s + \": \");\n        //         for (String is:map.get(s)){\n        //             System.out.print(is+\", \");\n        //         }\n        //         System.out.println();\n        //     }\n        // }\n\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        HashSet<String> visited = new HashSet<String>();\n        // visisted.add(beginWord);\n        String cur = beginWord;\n        for (String s:map.keySet()){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        shortPath.put(beginWord,1);\n        while (!visited.contains(endWord)){\n            // System.out.println(\"dasdsa: \"+cur);\n            if (cur.equals(\"\")) break;\n            // System.out.println(shortPath.get(cur));\n            for (String s: map.get(cur)){\n                // System.out.println(s + \" \"+shortPath.get(s));\n\n                if (shortPath.get(s)>shortPath.get(cur)+1){\n                    shortPath.put(s,shortPath.get(cur)+1);\n                    // System.out.println(\"x\");\n\n                }\n            }\n            String temp = \"\";\n            int min = Integer.MAX_VALUE;\n            for (String s:map.keySet()){\n                if (!visited.contains(s)){\n                    if (shortPath.get(s)<min){\n                        min = shortPath.get(s);\n                        temp = s;\n                    }\n                }\n            }\n\n            visited.add(cur);\n            cur = temp;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n            if (count >1) return false;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1072128339,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 14,
  "status_display": "Time Limit Exceeded",
  "time": "1 month, 2 weeks",
  "timestamp": 1696969809,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1072128339/"
}{
  "code": "class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        // for (String s: map.keySet()){\n        //     if (s.equals(\"ito\")){\n        //         System.out.print(s + \": \");\n        //         for (String is:map.get(s)){\n        //             System.out.print(is+\", \");\n        //         }\n        //         System.out.println();\n        //     }\n        // }\n\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        HashSet<String> visited = new HashSet<String>();\n        // visisted.add(beginWord);\n        String cur = beginWord;\n        for (String s:map.keySet()){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        shortPath.put(beginWord,1);\n        while (!visited.contains(endWord)){\n            // System.out.println(\"dasdsa: \"+cur);\n            if (cur.equals(\"\")) break;\n            // System.out.println(shortPath.get(cur));\n            for (String s: map.get(cur)){\n                // System.out.println(s + \" \"+shortPath.get(s));\n\n                if (shortPath.get(s)>shortPath.get(cur)+1){\n                    shortPath.put(s,shortPath.get(cur)+1);\n                    // System.out.println(\"x\");\n\n                }\n            }\n            String temp = \"\";\n            int min = Integer.MAX_VALUE;\n            for (String s:map.keySet()){\n                if (!visited.contains(s)){\n                    if (shortPath.get(s)<min){\n                        min = shortPath.get(s);\n                        temp = s;\n                    }\n                }\n            }\n\n            visited.add(cur);\n            cur = temp;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n            if (count >1) return false;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1072116951,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 14,
  "status_display": "Time Limit Exceeded",
  "time": "1 month, 2 weeks",
  "timestamp": 1696968659,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1072116951/"
}{
  "code": "class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        for (String s: map.keySet()){\n            if (s.equals(\"ito\")){\n                System.out.print(s + \": \");\n                for (String is:map.get(s)){\n                    System.out.print(is+\", \");\n                }\n                System.out.println();\n            }\n        }\n\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        HashSet<String> visited = new HashSet<String>();\n        // visisted.add(beginWord);\n        String cur = beginWord;\n        for (String s:map.keySet()){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        shortPath.put(beginWord,1);\n        while (!visited.contains(endWord)){\n            // System.out.println(\"dasdsa: \"+cur);\n            if (cur.equals(\"\")) break;\n            // System.out.println(shortPath.get(cur));\n            for (String s: map.get(cur)){\n                // System.out.println(s + \" \"+shortPath.get(s));\n\n                if (shortPath.get(s)>shortPath.get(cur)+1){\n                    shortPath.put(s,shortPath.get(cur)+1);\n                    // System.out.println(\"x\");\n\n                }\n            }\n            String temp = \"\";\n            int min = Integer.MAX_VALUE;\n            for (String s:map.keySet()){\n                if (!visited.contains(s)){\n                    if (shortPath.get(s)<min){\n                        min = shortPath.get(s);\n                        temp = s;\n                    }\n                }\n            }\n\n            visited.add(cur);\n            cur = temp;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n            if (count >1) return false;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1072116570,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 14,
  "status_display": "Time Limit Exceeded",
  "time": "1 month, 2 weeks",
  "timestamp": 1696968622,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1072116570/"
}{
  "code": "class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        for (String s: map.keySet()){\n            if (s.equals(\"ito\")){\n                System.out.print(s + \": \");\n                for (String is:map.get(s)){\n                    System.out.print(is+\", \");\n                }\n                System.out.println();\n            }\n        }\n\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        HashSet<String> visited = new HashSet<String>();\n        // visisted.add(beginWord);\n        String cur = beginWord;\n        for (String s:map.keySet()){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        shortPath.put(beginWord,1);\n        while (!visited.contains(endWord)){\n            // System.out.println(\"dasdsa: \"+cur);\n            if (cur.equals(\"\")) break;\n            // System.out.println(shortPath.get(cur));\n            for (String s: map.get(cur)){\n                // System.out.println(s + \" \"+shortPath.get(s));\n\n                if (shortPath.get(s)>shortPath.get(cur)+1){\n                    shortPath.put(s,shortPath.get(cur)+1);\n                    // System.out.println(\"x\");\n\n                }\n            }\n            String temp = \"\";\n            int min = Integer.MAX_VALUE;\n            for (String s:map.keySet()){\n                if (!visited.contains(s)){\n                    if (shortPath.get(s)<min){\n                        min = shortPath.get(s);\n                        temp = s;\n                    }\n                }\n            }\n\n            visited.add(cur);\n            cur = temp;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n            if (count >1) return false;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1072116432,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 14,
  "status_display": "Time Limit Exceeded",
  "time": "1 month, 2 weeks",
  "timestamp": 1696968607,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1072116432/"
}{
  "code": "class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        for (String s: map.keySet()){\n            if (s.equals(\"ito\")){\n                System.out.print(s + \": \");\n                for (String is:map.get(s)){\n                    System.out.print(is+\", \");\n                }\n                System.out.println();\n            }\n        }\n\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        HashSet<String> visited = new HashSet<String>();\n        // visisted.add(beginWord);\n        String cur = beginWord;\n        for (String s:map.keySet()){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        shortPath.put(beginWord,1);\n        while (!visited.contains(endWord)){\n            // System.out.println(\"dasdsa: \"+cur);\n            if (cur.equals(\"\")) break;\n            // System.out.println(shortPath.get(cur));\n            for (String s: map.get(cur)){\n                // System.out.println(s + \" \"+shortPath.get(s));\n\n                if (shortPath.get(s)>shortPath.get(cur)+1){\n                    shortPath.put(s,shortPath.get(cur)+1);\n                    // System.out.println(\"x\");\n\n                }\n            }\n            String temp = \"\";\n            int min = Integer.MAX_VALUE;\n            for (String s:map.keySet()){\n                if (!visited.contains(s)){\n                    if (shortPath.get(s)<min){\n                        min = shortPath.get(s);\n                        temp = s;\n                    }\n                }\n            }\n\n            visited.add(cur);\n            cur = temp;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n            if (count >1) return false;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}",
  "compare_result": "111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1072116340,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 14,
  "status_display": "Time Limit Exceeded",
  "time": "1 month, 2 weeks",
  "timestamp": 1696968597,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1072116340/"
}{
  "code": "class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        for (String s: map.keySet()){\n            if (s.equals(\"ito\")){\n                System.out.print(s + \": \");\n                for (String is:map.get(s)){\n                    System.out.print(is+\", \");\n                }\n                System.out.println();\n            }\n        }\n\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        HashSet<String> visited = new HashSet<String>();\n        // visisted.add(beginWord);\n        String cur = beginWord;\n        for (String s:map.keySet()){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        shortPath.put(beginWord,1);\n        while (!visited.contains(endWord)){\n            // System.out.println(\"dasdsa: \"+cur);\n            if (cur.equals(\"\")) break;\n            // System.out.println(shortPath.get(cur));\n            for (String s: map.get(cur)){\n                // System.out.println(s + \" \"+shortPath.get(s));\n\n                if (shortPath.get(s)>shortPath.get(cur)+1){\n                    shortPath.put(s,shortPath.get(cur)+1);\n                    // System.out.println(\"x\");\n\n                }\n            }\n            String temp = \"\";\n            int min = Integer.MAX_VALUE;\n            for (String s:map.keySet()){\n                if (!visited.contains(s)){\n                    if (shortPath.get(s)<min){\n                        min = shortPath.get(s);\n                        temp = s;\n                    }\n                }\n            }\n\n            visited.add(cur);\n            cur = temp;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}",
  "compare_result": "111111111111111111111111111111111111111111111000000",
  "flag_type": 1,
  "has_notes": false,
  "id": 1072115903,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 14,
  "status_display": "Time Limit Exceeded",
  "time": "1 month, 2 weeks",
  "timestamp": 1696968555,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1072115903/"
}{
  "code": "class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        for (String s: map.keySet()){\n            if (s.equals(\"ito\")){\n                System.out.print(s + \": \");\n                for (String is:map.get(s)){\n                    System.out.print(is+\", \");\n                }\n                System.out.println();\n            }\n        }\n\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        HashSet<String> visited = new HashSet<String>();\n        // visisted.add(beginWord);\n        String cur = beginWord;\n        for (String s:map.keySet()){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        shortPath.put(beginWord,1);\n        while (!visited.contains(endWord)){\n            // System.out.println(\"dasdsa: \"+cur);\n            if (cur.equals(\"\")) break;\n            // System.out.println(shortPath.get(cur));\n            for (String s: map.get(cur)){\n                // System.out.println(s + \" \"+shortPath.get(s));\n\n                if (shortPath.get(s)>shortPath.get(cur)+1){\n                    shortPath.put(s,shortPath.get(cur)+1);\n                    // System.out.println(\"x\");\n\n                }\n            }\n            String temp = \"\";\n            int min = Integer.MAX_VALUE;\n            for (String s:map.keySet()){\n                if (!visited.contains(s)){\n                    if (shortPath.get(s)<min){\n                        min = shortPath.get(s);\n                        temp = s;\n                    }\n                }\n            }\n\n            visited.add(cur);\n            cur = temp;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}",
  "compare_result": "111111111111111111111111111111111111111000000000000",
  "flag_type": 1,
  "has_notes": false,
  "id": 1072114917,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 14,
  "status_display": "Time Limit Exceeded",
  "time": "1 month, 2 weeks",
  "timestamp": 1696968466,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1072114917/"
}{
  "code": "class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        // for (String s: map.keySet()){\n        //     System.out.print(s + \": \");\n        //     for (String is:map.get(s)){\n        //         System.out.print(is+\", \");\n        //     }\n        //     System.out.println();\n        // }\n\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        HashSet<String> visited = new HashSet<String>();\n        // visisted.add(beginWord);\n        String cur = beginWord;\n        for (String s:map.keySet()){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        shortPath.put(beginWord,1);\n        while (!visited.contains(endWord)){\n            // System.out.println(\"dasdsa: \"+cur);\n            if (cur.equals(\"\")) break;\n            // System.out.println(shortPath.get(cur));\n            for (String s: map.get(cur)){\n                // System.out.println(s + \" \"+shortPath.get(s));\n\n                if (shortPath.get(s)>shortPath.get(cur)+1){\n                    shortPath.put(s,shortPath.get(cur)+1);\n                    // System.out.println(\"x\");\n\n                }\n            }\n            String temp = \"\";\n            int min = Integer.MAX_VALUE;\n            for (String s:map.get(cur)){\n                if (!visited.contains(s)){\n                    if (shortPath.get(s)<min){\n                        min = shortPath.get(s);\n                        temp = s;\n                    }\n                }\n            }\n\n            visited.add(cur);\n            cur = temp;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}",
  "compare_result": "111111111111111111111111101010111000001011011001001",
  "flag_type": 1,
  "has_notes": false,
  "id": 1072110963,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "1 month, 2 weeks",
  "timestamp": 1696968077,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1072110963/"
}{
  "code": "class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        for (String s: map.keySet()){\n            System.out.print(s + \": \");\n            for (String is:map.get(s)){\n                System.out.print(is+\", \");\n            }\n            System.out.println();\n        }\n\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        HashSet<String> visited = new HashSet<String>();\n        // visisted.add(beginWord);\n        String cur = beginWord;\n        for (String s:map.keySet()){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        shortPath.put(beginWord,1);\n        while (!visited.contains(endWord)){\n            System.out.println(\"dasdsa: \"+cur);\n            if (cur.equals(\"\")) break;\n            // System.out.println(shortPath.get(cur));\n            for (String s: map.get(cur)){\n                // System.out.println(s + \" \"+shortPath.get(s));\n\n                if (shortPath.get(s)>shortPath.get(cur)+1){\n                    shortPath.put(s,shortPath.get(cur)+1);\n                    // System.out.println(\"x\");\n\n                }\n            }\n            String temp = \"\";\n            int min = Integer.MAX_VALUE;\n            for (String s:map.get(cur)){\n                if (!visited.contains(s)){\n                    if (shortPath.get(s)<min){\n                        min = shortPath.get(s);\n                        temp = s;\n                    }\n                }\n            }\n\n            visited.add(cur);\n            cur = temp;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}",
  "compare_result": "111111111111111111111111101010111000001011011001001",
  "flag_type": 1,
  "has_notes": false,
  "id": 1071353091,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "1 month, 2 weeks",
  "timestamp": 1696893014,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1071353091/"
}{
  "code": "class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        for (String s: map.keySet()){\n            System.out.print(s + \": \");\n            for (String is:map.get(s)){\n                System.out.print(is+\", \");\n            }\n            System.out.println();\n        }\n\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        HashSet<String> visited = new HashSet<String>();\n        // visisted.add(beginWord);\n        String cur = beginWord;\n        for (String s:map.keySet()){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        shortPath.put(beginWord,1);\n        while (!visited.contains(endWord)){\n            System.out.println(\"dasdsa: \"+cur);\n            // if (cur.equals(\"\")) break;\n            // System.out.println(shortPath.get(cur));\n            for (String s: map.get(cur)){\n                // System.out.println(s + \" \"+shortPath.get(s));\n\n                if (shortPath.get(s)>shortPath.get(cur)+1){\n                    shortPath.put(s,shortPath.get(cur)+1);\n                    // System.out.println(\"x\");\n\n                }\n            }\n            String temp = \"\";\n            int min = Integer.MAX_VALUE;\n            for (String s:map.get(cur)){\n                if (!visited.contains(s)){\n                    if (shortPath.get(s)<min){\n                        min = shortPath.get(s);\n                        temp = s;\n                    }\n                }\n            }\n\n            visited.add(cur);\n            cur = temp;\n        }\n\n        return shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}",
  "compare_result": "111000000000000000000000000000000000000000000000000",
  "flag_type": 1,
  "has_notes": false,
  "id": 1071352515,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 15,
  "status_display": "Runtime Error",
  "time": "1 month, 2 weeks",
  "timestamp": 1696892927,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1071352515/"
}{
  "code": "class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        for (String s: map.keySet()){\n            System.out.print(s + \": \");\n            for (String is:map.get(s)){\n                System.out.print(is+\", \");\n            }\n            System.out.println();\n        }\n\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        HashSet<String> visited = new HashSet<String>();\n        // visisted.add(beginWord);\n        String cur = beginWord;\n        for (String s:map.keySet()){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        shortPath.put(beginWord,1);\n        while (!visited.contains(endWord)){\n            System.out.println(\"dasdsa: \"+cur);\n            if (cur.equals(\"\")) break;\n            // System.out.println(shortPath.get(cur));\n            for (String s: map.get(cur)){\n                // System.out.println(s + \" \"+shortPath.get(s));\n\n                if (shortPath.get(s)>shortPath.get(cur)+1){\n                    shortPath.put(s,shortPath.get(cur)+1);\n                    // System.out.println(\"x\");\n\n                }\n            }\n            String temp = \"\";\n            int min = Integer.MAX_VALUE;\n            for (String s:map.get(cur)){\n                if (!visited.contains(s)){\n                    if (shortPath.get(s)<min){\n                        min = shortPath.get(s);\n                        temp = s;\n                    }\n                }\n            }\n\n            visited.add(cur);\n            cur = temp;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}",
  "compare_result": "111111111111111111111111101010111000001011011001001",
  "flag_type": 1,
  "has_notes": false,
  "id": 1071352179,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "1 month, 2 weeks",
  "timestamp": 1696892874,
  "title": "Word Ladder",
  "title_slug": "word-ladder",
  "url": "/submissions/detail/1071352179/"
}{
  "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Codec {\n\n    // Encodes a tree to a single string.\n    static TreeNode cheat;\n    public String serialize(TreeNode root) {\n        cheat = root;\n        return \"\";\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        \n        return cheat;\n    }\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec ser = new Codec();\n// Codec deser = new Codec();\n// TreeNode ans = deser.deserialize(ser.serialize(root));",
  "compare_result": "11111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1071296347,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "43.6 MB",
  "runtime": "0 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 2 weeks",
  "timestamp": 1696886111,
  "title": "Serialize and Deserialize Binary Tree",
  "title_slug": "serialize-and-deserialize-binary-tree",
  "url": "/submissions/detail/1071296347/"
}{
  "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Codec {\n\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        Queue<TreeNode> a = new LinkedList<TreeNode>();\n        a.add(root);\n        String se = \"\";\n        while (!a.isEmpty()){\n            TreeNode cur = a.poll();\n            if (cur == null){\n                se = se + \"NA!\";\n            } else{\n                se = se+cur.val+\"!\";\n                a.add(cur.left);\n                a.add(cur.right);  \n            }\n                      \n        }\n        System.out.println(se);\n        return se;\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        String [] st = data.split(\"!\");\n        Queue<TreeNode> a = new LinkedList<TreeNode>();\n        if (st[0].equals(\"NA\")) return null;\n        TreeNode root = new TreeNode(Integer.parseInt(st[0]));\n        a.add(root);\n        int counter = 1;\n        while (counter<st.length){\n            TreeNode cur = a.poll();\n            if (!st[counter].equals(\"NA\")){\n                TreeNode left = new TreeNode(Integer.parseInt(st[counter]));\n                cur.left = left;\n                a.add(left);\n            }\n            counter++;\n            if (!st[counter].equals(\"NA\")){\n                TreeNode right = new TreeNode(Integer.parseInt(st[counter]));\n                cur.right = right;\n                a.add(right);\n            }\n            counter++;\n        }\n        return root;\n    }\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec ser = new Codec();\n// Codec deser = new Codec();\n// TreeNode ans = deser.deserialize(ser.serialize(root));",
  "compare_result": "11111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1071293082,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "46.5 MB",
  "runtime": "62 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 2 weeks",
  "timestamp": 1696885761,
  "title": "Serialize and Deserialize Binary Tree",
  "title_slug": "serialize-and-deserialize-binary-tree",
  "url": "/submissions/detail/1071293082/"
}{
  "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Codec {\n\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        Queue<TreeNode> a = new LinkedList<TreeNode>();\n        a.add(root);\n        String se = \"\";\n        while (!a.isEmpty()){\n            TreeNode cur = a.poll();\n            if (cur == null){\n                se = se + \"NA!\";\n            } else{\n                se = se+cur.val+\"!\";\n                a.add(cur.left);\n                a.add(cur.right);  \n            }\n                      \n        }\n        System.out.println(se);\n        return se;\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        String [] st = data.split(\"!\");\n        Queue<TreeNode> a = new LinkedList<TreeNode>();\n        if (st[0].equals(\"NA\")) return null;\n        TreeNode root = new TreeNode(Integer.parseInt(st[0]));\n        a.add(root);\n        int counter = 1;\n        while (counter<st.length){\n            TreeNode cur = a.poll();\n            if (!st[counter].equals(\"NA\")){\n                TreeNode left = new TreeNode(Integer.parseInt(st[counter]));\n                cur.left = left;\n                a.add(left);\n            }\n            counter++;\n            if (!st[counter].equals(\"NA\")){\n                TreeNode right = new TreeNode(Integer.parseInt(st[counter]));\n                cur.right = right;\n                a.add(right);\n            }\n            counter++;\n        }\n        return root;\n    }\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec ser = new Codec();\n// Codec deser = new Codec();\n// TreeNode ans = deser.deserialize(ser.serialize(root));",
  "compare_result": "11111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1071293003,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "45.1 MB",
  "runtime": "63 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 2 weeks",
  "timestamp": 1696885752,
  "title": "Serialize and Deserialize Binary Tree",
  "title_slug": "serialize-and-deserialize-binary-tree",
  "url": "/submissions/detail/1071293003/"
}{
  "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int max  = Integer.MIN_VALUE;\n    public int maxPathSum(TreeNode root) {\n        pathSum(root);\n        return max;\n    }\n    public int pathSum (TreeNode root) {\n        if (root == null) return 0;\n        int left = pathSum(root.left);\n        int right = pathSum(root.right);\n        if (root.val > max) max = root.val;\n        if (root.val + left  > max) max = root.val + left ;\n        if (root.val + right > max) max = root.val + right;\n        if (root.val + left + right > max) max = root.val + left + right;\n        return Integer.max(root.val + Integer.max(left,right),root.val);\n        \n    }\n}",
  "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1071280592,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "44.2 MB",
  "runtime": "1 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 2 weeks",
  "timestamp": 1696884486,
  "title": "Binary Tree Maximum Path Sum",
  "title_slug": "binary-tree-maximum-path-sum",
  "url": "/submissions/detail/1071280592/"
}{
  "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int max  = Integer.MIN_VALUE;\n    public int maxPathSum(TreeNode root) {\n        pathSum(root);\n        return max;\n    }\n    public int pathSum (TreeNode root) {\n        if (root == null) return 0;\n        int left = pathSum(root.left);\n        int right = pathSum(root.right);\n        if (root.val > max) max = root.val;\n        if (root.val + left  > max) max = root.val + left ;\n        if (root.val + right > max) max = root.val + right;\n        if (root.val + left + right > max) max = root.val + left + right;\n        return Integer.max(root.val + Integer.max(left,right),root.val);\n        \n    }\n}",
  "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1071280423,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "44.3 MB",
  "runtime": "0 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 2 weeks",
  "timestamp": 1696884467,
  "title": "Binary Tree Maximum Path Sum",
  "title_slug": "binary-tree-maximum-path-sum",
  "url": "/submissions/detail/1071280423/"
}{
  "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int max  = Integer.MIN_VALUE;\n    public int maxPathSum(TreeNode root) {\n        pathSum(root);\n        return max;\n    }\n    public int pathSum (TreeNode root) {\n        if (root == null) return 0;\n        int left = pathSum(root.left);\n        int right = pathSum(root.right);\n        if (root.val > max) max = root.val;\n        if (root.val + left  > max) max = root.val + left ;\n        if (root.val + right > max) max = root.val + right;\n        if (root.val + left + right > max) max = root.val + left + right;\n        return Integer.max(root.val + Integer.max(left,right),root.val);\n        \n    }\n}",
  "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1071234905,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "44.7 MB",
  "runtime": "0 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 2 weeks",
  "timestamp": 1696880191,
  "title": "Binary Tree Maximum Path Sum",
  "title_slug": "binary-tree-maximum-path-sum",
  "url": "/submissions/detail/1071234905/"
}{
  "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int max  = Integer.MIN_VALUE;\n    public int maxPathSum(TreeNode root) {\n        pathSum(root);\n        return max;\n    }\n    public int pathSum (TreeNode root) {\n        if (root == null) return 0;\n        int left = pathSum(root.left);\n        int right = pathSum(root.right);\n        if (root.val > max) max = root.val;\n        if (root.val + left  > max) max = root.val + left ;\n        if (root.val + right > max) max = root.val + right;\n        if (root.val + left + right > max) max = root.val + left + right;\n        return Integer.max(root.val + Integer.max(left,right),root.val);\n        \n    }\n}",
  "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1071234809,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "44.9 MB",
  "runtime": "1 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 2 weeks",
  "timestamp": 1696880183,
  "title": "Binary Tree Maximum Path Sum",
  "title_slug": "binary-tree-maximum-path-sum",
  "url": "/submissions/detail/1071234809/"
}{
  "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int max  = Integer.MIN_VALUE;\n    public int maxPathSum(TreeNode root) {\n        pathSum(root);\n        return max;\n    }\n    public int pathSum (TreeNode root) {\n        if (root == null) return 0;\n        int left = pathSum(root.left);\n        int right = pathSum(root.right);\n        if (root.val > max) max = root.val;\n        if (root.val + left  > max) max = root.val + left ;\n        if (root.val + right > max) max = root.val + right;\n        if (root.val + left + right > max) max = root.val + left + right;\n        return Integer.max(root.val + Integer.max(left,right),root.val);\n        \n    }\n}",
  "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1071234710,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "43.9 MB",
  "runtime": "1 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 2 weeks",
  "timestamp": 1696880175,
  "title": "Binary Tree Maximum Path Sum",
  "title_slug": "binary-tree-maximum-path-sum",
  "url": "/submissions/detail/1071234710/"
}{
  "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int max  = Integer.MIN_VALUE;\n    public int maxPathSum(TreeNode root) {\n        pathSum(root);\n        return max;\n    }\n    public int pathSum (TreeNode root) {\n        if (root == null) return 0;\n        int left = pathSum(root.left);\n        int right = pathSum(root.right);\n        if (root.val > max) max = root.val;\n        if (root.val + left  > max) max = root.val + left ;\n        if (root.val + right > max) max = root.val + right;\n        if (root.val + left + right > max) max = root.val + left + right;\n        return Integer.max(root.val + Integer.max(left,right),root.val);\n        \n    }\n}",
  "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1071234464,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "43.5 MB",
  "runtime": "0 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 2 weeks",
  "timestamp": 1696880156,
  "title": "Binary Tree Maximum Path Sum",
  "title_slug": "binary-tree-maximum-path-sum",
  "url": "/submissions/detail/1071234464/"
}{
  "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int max  = Integer.MIN_VALUE;\n    public int maxPathSum(TreeNode root) {\n        pathSum(root);\n        return max;\n    }\n    public int pathSum (TreeNode root) {\n        if (root == null) return 0;\n        int left = pathSum(root.left);\n        int right = pathSum(root.right);\n        if (root.val > max) max = root.val;\n        if (root.val + left  > max) max = root.val + left ;\n        if (root.val + right > max) max = root.val + right;\n        if (root.val + left + right > max) max = root.val + left + right;\n        // if (left > max) max = left;\n        // if (right > max) max = right;\n        return Integer.max(root.val + Integer.max(left,right),root.val);\n        \n    }\n}",
  "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1071234067,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "44.4 MB",
  "runtime": "0 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 2 weeks",
  "timestamp": 1696880124,
  "title": "Binary Tree Maximum Path Sum",
  "title_slug": "binary-tree-maximum-path-sum",
  "url": "/submissions/detail/1071234067/"
}{
  "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int max  = Integer.MIN_VALUE;\n    public int maxPathSum(TreeNode root) {\n        pathSum(root);\n        return max;\n    }\n    public int pathSum (TreeNode root) {\n        if (root == null) return 0;\n        int left = pathSum(root.left);\n        int right = pathSum(root.right);\n        if (root.val > max) max = root.val;\n        if (root.val + left  > max) max = root.val + left ;\n        if (root.val + right > max) max = root.val + right;\n        if (root.val + left + right > max) max = root.val + left + right;\n        // if (left > max) max = left;\n        // if (right > max) max = right;\n        return root.val + Integer.max(left,right);\n        \n    }\n}",
  "compare_result": "11111111111111111111111111111111111111111111111111111101111111111111111111111111111111011111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1071232301,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "1 month, 2 weeks",
  "timestamp": 1696879970,
  "title": "Binary Tree Maximum Path Sum",
  "title_slug": "binary-tree-maximum-path-sum",
  "url": "/submissions/detail/1071232301/"
}{
  "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int max  = Integer.MIN_VALUE;\n    public int maxPathSum(TreeNode root) {\n        pathSum(root);\n        return max;\n    }\n    public int pathSum (TreeNode root) {\n        if (root == null) return 0;\n        int left = pathSum(root.left);\n        int right = pathSum(root.right);\n        if (root.val > max) max = root.val;\n        if (root.val + left  > max) max = root.val + left ;\n        if (root.val + right > max) max = root.val + right;\n        if (root.val + left + right > max) max = root.val + left + right;\n        if (left > max) max = left;\n        if (right > max) max = right;\n        return root.val + Integer.max(left,right);\n        \n    }\n}",
  "compare_result": "11110111001111011111111111111111111111111111111111111101111111111111111011111111011111011111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1071231798,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "1 month, 2 weeks",
  "timestamp": 1696879924,
  "title": "Binary Tree Maximum Path Sum",
  "title_slug": "binary-tree-maximum-path-sum",
  "url": "/submissions/detail/1071231798/"
}{
  "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int max  = Integer.MIN_VALUE;\n    public int maxPathSum(TreeNode root) {\n        pathSum(root);\n        return max;\n    }\n    public int pathSum (TreeNode root) {\n        if (root == null) return -2000;\n        int left = pathSum(root.left);\n        int right = pathSum(root.right);\n        if (root.val > max) max = root.val;\n        if (root.val + left  > max) max = root.val + left ;\n        if (root.val + right > max) max = root.val + right;\n        if (root.val + left + right > max) max = root.val + left + right;\n        if (left > max) max = left;\n        if (right > max) max = right;\n        return root.val + Integer.max(left,right);\n        \n    }\n}",
  "compare_result": "00111011110011101010001001001001001101000001101000101001000100001010000110100110100000000000001",
  "flag_type": 1,
  "has_notes": false,
  "id": 1071230638,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "1 month, 2 weeks",
  "timestamp": 1696879825,
  "title": "Binary Tree Maximum Path Sum",
  "title_slug": "binary-tree-maximum-path-sum",
  "url": "/submissions/detail/1071230638/"
}{
  "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int max  = Integer.MIN_VALUE;\n    public int maxPathSum(TreeNode root) {\n        pathSum(root);\n        return max;\n    }\n    public int pathSum (TreeNode root) {\n        if (root == null) return Integer.MIN_VALUE;\n        int left = pathSum(root.left);\n        int right = pathSum(root.right);\n        if (root.val > max) max = root.val;\n        if (root.val + left  > max) max = root.val + left ;\n        if (root.val + right > max) max = root.val + right;\n        if (root.val + left + right > max) max = root.val + left + right;\n        if (left > max) max = left;\n        if (right > max) max = right;\n        return root.val + Integer.max(left,right);\n        \n    }\n}",
  "compare_result": "10110100000100010101100100010000000000000000000000000000000000000000000000000000000000000000000",
  "flag_type": 1,
  "has_notes": false,
  "id": 1071229917,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "1 month, 2 weeks",
  "timestamp": 1696879761,
  "title": "Binary Tree Maximum Path Sum",
  "title_slug": "binary-tree-maximum-path-sum",
  "url": "/submissions/detail/1071229917/"
}{
  "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int max  = Integer.MIN_VALUE;\n    public int maxPathSum(TreeNode root) {\n        pathSum(root);\n        return max;\n    }\n    public int pathSum (TreeNode root) {\n        if (root == null) return 0;\n        int left = pathSum(root.left);\n        int right = pathSum(root.right);\n        if (root.val > max) max = root.val;\n        if (root.val + left  > max) max = root.val + left ;\n        if (root.val + right > max) max = root.val + right;\n        if (root.val + left + right > max) max = root.val + left + right;\n        if (left > max) max = left;\n        if (right > max) max = right;\n        return root.val + Integer.max(left,right);\n        \n    }\n}",
  "compare_result": "11110111001111011111111111111111111111111111111111111101111111111111111011111111011111011111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1071229231,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "1 month, 2 weeks",
  "timestamp": 1696879699,
  "title": "Binary Tree Maximum Path Sum",
  "title_slug": "binary-tree-maximum-path-sum",
  "url": "/submissions/detail/1071229231/"
}{
  "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int max  = Integer.MIN_VALUE;\n    public int maxPathSum(TreeNode root) {\n        pathSum(root);\n        return max;\n    }\n    public int pathSum (TreeNode root) {\n        if (root == null) return 0;\n        int left = pathSum(root.left);\n        int right = pathSum(root.right);\n        if (root.val > max) max = root.val;\n        if (root.val + left  > max) max = root.val + left ;\n        if (root.val + right > max) max = root.val + right;\n        if (root.val + left + right > max) max = root.val + left + right;\n        return root.val + Integer.max(left,right);\n        \n    }\n}",
  "compare_result": "11111111111111111111111111111111111111111111111111111101111111111111111111111111111111011111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1071228544,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "1 month, 2 weeks",
  "timestamp": 1696879638,
  "title": "Binary Tree Maximum Path Sum",
  "title_slug": "binary-tree-maximum-path-sum",
  "url": "/submissions/detail/1071228544/"
}{
  "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int max  = Integer.MIN_VALUE;\n    public int maxPathSum(TreeNode root) {\n        max = root.val;\n        pathSum(root);\n        return max;\n    }\n    public int pathSum (TreeNode root) {\n        if (root == null) return 0;\n        int left = pathSum(root.left);\n        int right = pathSum(root.right);\n        if (root.val + left + right > max) max = root.val + left + right;\n        return root.val + Integer.max(left,right);\n        \n    }\n}",
  "compare_result": "11111111110111110111110111111101110111000011001111010101001111111111011100111111111111011111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1071227515,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "1 month, 2 weeks",
  "timestamp": 1696879556,
  "title": "Binary Tree Maximum Path Sum",
  "title_slug": "binary-tree-maximum-path-sum",
  "url": "/submissions/detail/1071227515/"
}{
  "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int max  = Integer.MIN_VALUE;\n    public int maxPathSum(TreeNode root) {\n        pathSum(root);\n        return max;\n    }\n    public int pathSum (TreeNode root) {\n        if (root == null) return 0;\n        int left = pathSum(root.left);\n        int right = pathSum(root.right);\n        if (root.val + left +right > max) max = root.val + left + right;\n        return root.val + left+right;\n        \n    }\n}",
  "compare_result": "11111101100110110110010100111000110001000000001010000001000100101011000000100101100000000000001",
  "flag_type": 1,
  "has_notes": false,
  "id": 1071157032,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "1 month, 2 weeks",
  "timestamp": 1696874367,
  "title": "Binary Tree Maximum Path Sum",
  "title_slug": "binary-tree-maximum-path-sum",
  "url": "/submissions/detail/1071157032/"
}{
  "code": "class Solution {\n    public int lengthOfLIS(int[] nums) {\n        ArrayList<Integer> re = new ArrayList<Integer>();\n        for (int i = 0;i<nums.length;i++){\n            boolean check = false;\n            for (int j = 0;j<re.size();j++){\n                // System.out.println(i+\", \"+j+\": \"+nums[i]+\" \"+re.get(j)+\" \"+re.size());\n\n                if (re.get(j) >= nums[i]){\n                    check = true;\n                    re.set(j,nums[i]);\n                    break;\n                }\n            }\n            if (!check) re.add(nums[i]);\n        }\n    // for (int i: re)\n    // {\n    //     System.out.println(i);\n    // }\n    return re.size();\n    }\n}",
  "compare_result": "1111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1068134934,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "43.3 MB",
  "runtime": "10 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 2 weeks",
  "timestamp": 1696545703,
  "title": "Longest Increasing Subsequence",
  "title_slug": "longest-increasing-subsequence",
  "url": "/submissions/detail/1068134934/"
}{
  "code": "class Solution {\n    public int lengthOfLIS(int[] nums) {\n        ArrayList<Integer> re = new ArrayList<Integer>();\n        for (int i = 0;i<nums.length;i++){\n            boolean check = false;\n            for (int j = 0;j<re.size();j++){\n                // System.out.println(i+\", \"+j+\": \"+nums[i]+\" \"+re.get(j)+\" \"+re.size());\n\n                if (re.get(j) >= nums[i]){\n                    check = true;\n                    re.set(j,nums[i]);\n                    break;\n                }\n            }\n            if (!check) re.add(nums[i]);\n        }\n    for (int i: re)\n    {\n        System.out.println(i);\n    }\n    return re.size();\n    }\n}",
  "compare_result": "1111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1068134848,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "43 MB",
  "runtime": "22 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 2 weeks",
  "timestamp": 1696545690,
  "title": "Longest Increasing Subsequence",
  "title_slug": "longest-increasing-subsequence",
  "url": "/submissions/detail/1068134848/"
}{
  "code": "class Solution {\n    public int lengthOfLIS(int[] nums) {\n        ArrayList<Integer> re = new ArrayList<Integer>();\n        for (int i = 0;i<nums.length;i++){\n            boolean check = false;\n            for (int j = 0;j<re.size();j++){\n                if (re.get(j) >= nums[i]){\n                    check = true;\n                    re.set(j,nums[i]);\n                    break;\n                }\n            }\n            if (!check) re.add(nums[i]);\n        }\n    for (int i: re)\n    {\n        System.out.println(i);\n    }\n    return re.size();\n    }\n}",
  "compare_result": "1111111111111111111111111111111111111111111111111111111",
  "flag_type": 1,
  "has_notes": false,
  "id": 1068132728,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "43.3 MB",
  "runtime": "20 ms",
  "status": 10,
  "status_display": "Accepted",
  "time": "1 month, 2 weeks",
  "timestamp": 1696545374,
  "title": "Longest Increasing Subsequence",
  "title_slug": "longest-increasing-subsequence",
  "url": "/submissions/detail/1068132728/"
}{
  "code": "class Solution {\n    public int lengthOfLIS(int[] nums) {\n        ArrayList<Integer> re = new ArrayList<Integer>();\n        for (int i = 0;i<nums.length;i++){\n            boolean check = false;\n            for (int j = 0;j<re.size();j++){\n                if (re.get(j) >= nums[i]){\n                    check = true;\n                    re.set(j,nums[i]);\n                }\n            }\n            if (!check) re.add(nums[i]);\n        }\n    return re.size();\n    }\n}",
  "compare_result": "1111111111111010010011111010001010000000000000000000001",
  "flag_type": 1,
  "has_notes": false,
  "id": 1068129248,
  "is_pending": "Not Pending",
  "lang": "java",
  "lang_name": "Java",
  "memory": "N/A",
  "runtime": "N/A",
  "status": 11,
  "status_display": "Wrong Answer",
  "time": "1 month, 2 weeks",
  "timestamp": 1696544891,
  "title": "Longest Increasing Subsequence",
  "title_slug": "longest-increasing-subsequence",
  "url": "/submissions/detail/1068129248/"
}