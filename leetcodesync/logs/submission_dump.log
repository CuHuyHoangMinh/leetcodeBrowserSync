2024-01-26 22:56:23.166 [main] DEBUG test_dump - test test
2024-01-26 23:01:09.795 [main] DEBUG submission_dump - {"submissions_dump":[{"status_display":"Wrong Answer","memory":"N/A","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<Integer> rightSideView(TreeNode root) {\n        // if (root == null) return null;\n        List<Integer> ans = new ArrayList<>();\n        TreeNode pointer = root;\n        \n        while(pointer != null){\n            ans.add(pointer.val);\n            pointer = pointer.right;\n        }\n        return ans;\n    }\n}","runtime":"N/A","title":"Binary Tree Right Side View","url":"/submissions/detail/1155118137/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1155118137,"time":"3 days, 2 hours","lang":"java","title_slug":"binary-tree-right-side-view","timestamp":1706061436,"status":11,"is_pending":"Not Pending","compare_result":"111101000100100010000000000011001100000100000000000010000000010000001100000001000000010000000000000000000100000010000000000000000000000000001000000110010110100001001000000011000100010000010000010000000000000000000001"},{"status_display":"Accepted","memory":"48.5 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass BSTIterator {\n    ArrayList<TreeNode> list;\n    int index;\n    public BSTIterator(TreeNode root) {\n        list = new ArrayList<>();\n        inOrder(root);\n        index = -1;\n    }\n    \n    public int next() {\n        index++;\n        return list.get(index).val;\n    }\n    \n    public boolean hasNext() {\n        // System.out.println(index +\" \" + list.size());\n        return index+1<list.size();\n    }\n    public void inOrder(TreeNode root){\n        if (root == null) return;\n        inOrder(root.left);\n        list.add(root);\n        inOrder(root.right);\n        return;\n    }\n}\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * BSTIterator obj = new BSTIterator(root);\n * int param_1 = obj.next();\n * boolean param_2 = obj.hasNext();\n */","runtime":"16 ms","title":"Binary Search Tree Iterator","url":"/submissions/detail/1155110222/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1155110222,"time":"3 days, 2 hours","lang":"java","title_slug":"binary-search-tree-iterator","timestamp":1706060502,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"48.1 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass BSTIterator {\n    ArrayList<TreeNode> list;\n    int index;\n    public BSTIterator(TreeNode root) {\n        list = new ArrayList<>();\n        inOrder(root);\n        index = -1;\n    }\n    \n    public int next() {\n        index++;\n        return list.get(index).val;\n    }\n    \n    public boolean hasNext() {\n        // System.out.println(index +\" \" + list.size());\n        return index+1<list.size();\n    }\n    public void inOrder(TreeNode root){\n        if (root == null) return;\n        inOrder(root.left);\n        list.add(root);\n        inOrder(root.right);\n        return;\n    }\n}\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * BSTIterator obj = new BSTIterator(root);\n * int param_1 = obj.next();\n * boolean param_2 = obj.hasNext();\n */","runtime":"16 ms","title":"Binary Search Tree Iterator","url":"/submissions/detail/1155109987/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1155109987,"time":"3 days, 2 hours","lang":"java","title_slug":"binary-search-tree-iterator","timestamp":1706060472,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"41.7 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int s = 0;\n\n    public int sumNumbers(TreeNode root) {\n        findNum(root, 0);\n        return s;\n    }\n\n    public void findNum(TreeNode root, int cur){\n        if (root == null) return;\n        if (root.left ==null && root.right == null){\n            s = s + cur*10 + root.val;\n            // System.out.println(cur*10 + root.val);\n\n            return;\n        }\n        findNum(root.left, cur*10 + root.val);\n        findNum(root.right, cur*10 + root.val);\n    }\n}","runtime":"0 ms","title":"Sum Root to Leaf Numbers","url":"/submissions/detail/1155065697/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1155065697,"time":"3 days, 3 hours","lang":"java","title_slug":"sum-root-to-leaf-numbers","timestamp":1706054765,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int s = 0;\n\n    public int sumNumbers(TreeNode root) {\n        findNum(root, 0);\n        return s/2;\n    }\n\n    public void findNum(TreeNode root, int cur){\n        if (root == null){\n            System.out.println(cur);\n            s = s + cur;\n            return;\n        }\n        findNum(root.left, cur*10 + root.val);\n        findNum(root.right, cur*10 + root.val);\n    }\n}","runtime":"N/A","title":"Sum Root to Leaf Numbers","url":"/submissions/detail/1155064160/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1155064160,"time":"3 days, 3 hours","lang":"java","title_slug":"sum-root-to-leaf-numbers","timestamp":1706054547,"status":11,"is_pending":"Not Pending","compare_result":"111111111000001000010000000011000010000000000100100000000000000000100000100000000000000000000000000000000000"},{"status_display":"Accepted","memory":"42.4 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public void flatten(TreeNode root) {\n        ArrayList<TreeNode> list = new ArrayList<>();\n        preOrder(root,list);\n        for (int i = 0;i<list.size()-1;i++){\n            list.get(i).left = null;\n            list.get(i).right = list.get(i+1);\n        }\n        \n    }\n\n    public void preOrder(TreeNode root, ArrayList list){\n        if (root == null) return;\n        list.add(root);\n        preOrder(root.left, list);\n        preOrder(root.right, list);\n        return;\n    }\n}","runtime":"1 ms","title":"Flatten Binary Tree to Linked List","url":"/submissions/detail/1155057866/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1155057866,"time":"3 days, 4 hours","lang":"java","title_slug":"flatten-binary-tree-to-linked-list","timestamp":1706053678,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"44.2 MB","code":"/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public Node left;\n    public Node right;\n    public Node next;\n\n    public Node() {}\n    \n    public Node(int _val) {\n        val = _val;\n    }\n\n    public Node(int _val, Node _left, Node _right, Node _next) {\n        val = _val;\n        left = _left;\n        right = _right;\n        next = _next;\n    }\n};\n*/\n\nclass Solution {\n    public Node connect(Node root) {\n        Queue<Node> q = new LinkedList<>();\n        int count  =  1;\n        if (root == null) return null;\n        q.add(root);\n        int nextLayer = 0;\n        \n        while (! q.isEmpty()) {\n                Node cur = q.poll();\n                count --;\n                if (cur.left != null) {\n                    nextLayer++;\n                    q.add(cur.left);\n                }\n                if (cur.right != null) {\n                    nextLayer++;\n                    q.add(cur.right);\n                }\n                if (count == 0){\n                    count = nextLayer;\n                    nextLayer = 0;\n                } else{\n                    cur.next = q.peek();\n                }\n        }\n\n        return root;\n    }\n}","runtime":"2 ms","title":"Populating Next Right Pointers in Each Node II","url":"/submissions/detail/1153077000/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1153077000,"time":"5 days, 3 hours","lang":"java","title_slug":"populating-next-right-pointers-in-each-node-ii","timestamp":1705884564,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"44.3 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        return build(postorder, inorder, 0, postorder.length-1, 0 , inorder.length-1);\n    }\n\n    public TreeNode build(int[] postorder, int[] inorder, int post_x, int post_y, int in_x, int in_y){\n        if (post_x > post_y) return null;\n        if (in_x > in_y) return null;\n        if (post_x <0) return null;\n        if (post_y <0) return null;\n        TreeNode root = new TreeNode(postorder[post_y]);\n        int left_in = -1;\n        int right_in = -1;\n        int size = -1;\n        for (int i = in_x; i<=in_y;i++){\n            if (inorder[i] == postorder[post_y]) {\n                left_in = i -1;\n                right_in = i+1;\n                break;\n            }\n        }\n        int size_left = left_in - in_x +1; // dont add 1 because i have to subjact it again, \n                                        //  or add 1 and subject it again whatever less confusing\n        int size_right = in_y - right_in+1;\n        // System.out.println(post_x + \" \"+ post_y + \" \"+ in_x +\" \"+ in_y);\n        int temp_post_left_x = post_x;\n        int temp_post_left_y = post_x + size_left - 1;\n        int temp_in_left_x = in_x;\n        int temp_in_left_y = left_in;\n\n        int temp_post_right_x = post_x + size_left ;\n        int temp_post_right_y = post_x + size_left + size_right - 1;\n        int temp_in_right_x = right_in;\n        int temp_in_right_y = in_y;\n        // System.out.println(\"Left: \"+ temp_pre_left_x +\" \" +temp_pre_left_y+ \" \" + temp_in_left_x + \" \" + temp_in_left_y);\n        // System.out.println(\"Right: \"+ temp_pre_right_x + \" \" +temp_pre_right_y + \" \" + temp_in_right_x +\" \"+ temp_in_right_y);\n        root.left = build(postorder, inorder, temp_post_left_x, temp_post_left_y, temp_in_left_x, temp_in_left_y );\n        root.right = build(postorder, inorder, temp_post_right_x, temp_post_right_y, temp_in_right_x, temp_in_right_y);\n\n        return root;\n    }\n}","runtime":"3 ms","title":"Construct Binary Tree from Inorder and Postorder Traversal","url":"/submissions/detail/1153064874/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1153064874,"time":"5 days, 3 hours","lang":"java","title_slug":"construct-binary-tree-from-inorder-and-postorder-traversal","timestamp":1705883188,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"43.8 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        return build(preorder, inorder, 0, preorder.length -1, 0, inorder.length-1);\n    }\n\n    public TreeNode build(int[] preorder, int[] inorder, int pre_x, int pre_y, int in_x, int in_y){\n        if (pre_x > pre_y) return null;\n        if (in_x > in_y) return null;\n        if (pre_x <0) return null;\n        if (pre_y <0) return null;\n        TreeNode root = new TreeNode(preorder[pre_x]);\n        int left_in = -1;\n        int right_in = -1;\n        int size = -1;\n        for (int i = in_x; i<=in_y;i++){\n            if (inorder[i] == preorder[pre_x]) {\n                left_in = i -1;\n                right_in = i+1;\n                break;\n            }\n        }\n        int size_left = left_in - in_x +1; // dont add 1 because i have to subjact it again, \n                                        //  or add 1 and subject it again whatever less confusing\n        int size_right = in_y - right_in+1;\n        // System.out.println(pre_x + \" \"+ pre_y + \" \"+ in_x +\" \"+ in_y);\n        int temp_pre_left_x = pre_x+1;\n        int temp_pre_left_y = pre_x + size_left;\n        int temp_in_left_x = in_x;\n        int temp_in_left_y = left_in;\n\n        int temp_pre_right_x = pre_x + size_left + 1;\n        int temp_pre_right_y = pre_x + size_left + size_right;\n        int temp_in_right_x = right_in;\n        int temp_in_right_y = in_y;\n        // System.out.println(\"Left: \"+ temp_pre_left_x +\" \" +temp_pre_left_y+ \" \" + temp_in_left_x + \" \" + temp_in_left_y);\n        // System.out.println(\"Right: \"+ temp_pre_right_x + \" \" +temp_pre_right_y + \" \" + temp_in_right_x +\" \"+ temp_in_right_y);\n        root.left = build(preorder, inorder, temp_pre_left_x, temp_pre_left_y, temp_in_left_x, temp_in_left_y );\n        root.right = build(preorder, inorder, temp_pre_right_x, temp_pre_right_y, temp_in_right_x, temp_in_right_y);\n\n        return root;\n    }\n}","runtime":"3 ms","title":"Construct Binary Tree from Preorder and Inorder Traversal","url":"/submissions/detail/1152982225/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1152982225,"time":"5 days, 6 hours","lang":"java","title_slug":"construct-binary-tree-from-preorder-and-inorder-traversal","timestamp":1705873028,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"46.1 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        return build(preorder, inorder, 0, preorder.length -1, 0, inorder.length-1);\n    }\n\n    public TreeNode build(int[] preorder, int[] inorder, int pre_x, int pre_y, int in_x, int in_y){\n        if (pre_x > pre_y) return null;\n        if (in_x > in_y) return null;\n        if (pre_x <0) return null;\n        if (pre_y <0) return null;\n        TreeNode root = new TreeNode(preorder[pre_x]);\n        int left_in = -1;\n        int right_in = -1;\n        int size = -1;\n        for (int i = in_x; i<=in_y;i++){\n            if (inorder[i] == preorder[pre_x]) {\n                left_in = i -1;\n                right_in = i+1;\n                break;\n            }\n        }\n        int size_left = left_in - in_x +1; // dont add 1 because i have to subjact it again, \n                                        //  or add 1 and subject it again whatever less confusing\n        int size_right = in_y - right_in+1;\n        System.out.println(pre_x + \" \"+ pre_y + \" \"+ in_x +\" \"+ in_y);\n        int temp_pre_left_x = pre_x+1;\n        int temp_pre_left_y = pre_x + size_left;\n        int temp_in_left_x = in_x;\n        int temp_in_left_y = left_in;\n\n        int temp_pre_right_x = pre_x + size_left + 1;\n        int temp_pre_right_y = pre_x + size_left + size_right;\n        int temp_in_right_x = right_in;\n        int temp_in_right_y = in_y;\n        System.out.println(\"Left: \"+ temp_pre_left_x +\" \" +temp_pre_left_y+ \" \" + temp_in_left_x + \" \" + temp_in_left_y);\n        System.out.println(\"Right: \"+ temp_pre_right_x + \" \" +temp_pre_right_y + \" \" + temp_in_right_x +\" \"+ temp_in_right_y);\n        root.left = build(preorder, inorder, temp_pre_left_x, temp_pre_left_y, temp_in_left_x, temp_in_left_y );\n        root.right = build(preorder, inorder, temp_pre_right_x, temp_pre_right_y, temp_in_right_x, temp_in_right_y);\n\n        return root;\n    }\n}","runtime":"48 ms","title":"Construct Binary Tree from Preorder and Inorder Traversal","url":"/submissions/detail/1152981992/","lang_name":"Java","has_notes":true,"flag_type":1,"id":1152981992,"time":"5 days, 6 hours","lang":"java","title_slug":"construct-binary-tree-from-preorder-and-inorder-traversal","timestamp":1705873000,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"44.1 MB","code":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode reverseKGroup(ListNode head, int k) {\n        ArrayList<ListNode> array = new ArrayList<>();\n        ListNode cur = head;\n        while (cur != null){\n            array.add(cur);\n            cur = cur.next;\n        }\n        int size = k-1;\n        int max= array.size() - (array.size() % k );\n        for (int i = 0;i<max;i++){\n            // System.out.println(i+\" \"+size);\n            if (size == 1-k) {\n                size = k-1;\n                continue;\n            }\n            if (size <= 0) {\n                size = size - 2;\n                continue; \n            }\n            int temp = array.get(i).val;\n            array.get(i).val = array.get(i+size).val;\n            array.get(i+size).val = temp;\n            size = size - 2;\n        }\n        return head;\n\n    }\n}","runtime":"2 ms","title":"Reverse Nodes in k-Group","url":"/submissions/detail/1152895777/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1152895777,"time":"5 days, 8 hours","lang":"java","title_slug":"reverse-nodes-in-k-group","timestamp":1705864662,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"44.4 MB","code":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode reverseKGroup(ListNode head, int k) {\n        ArrayList<ListNode> array = new ArrayList<>();\n        ListNode cur = head;\n        while (cur != null){\n            array.add(cur);\n            cur = cur.next;\n        }\n        int size = k-1;\n        int max= array.size() - (array.size() % k );\n        for (int i = 0;i<max;i++){\n            System.out.println(i+\" \"+size);\n            if (size == 1-k) {\n                size = k-1;\n                continue;\n            }\n            if (size <= 0) {\n                size = size - 2;\n                continue; \n            }\n            int temp = array.get(i).val;\n            array.get(i).val = array.get(i+size).val;\n            array.get(i+size).val = temp;\n            size = size - 2;\n        }\n        return head;\n\n    }\n}","runtime":"43 ms","title":"Reverse Nodes in k-Group","url":"/submissions/detail/1152895510/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1152895510,"time":"5 days, 8 hours","lang":"java","title_slug":"reverse-nodes-in-k-group","timestamp":1705864641,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"44.1 MB","code":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode reverseKGroup(ListNode head, int k) {\n        ArrayList<ListNode> array = new ArrayList<>();\n        ListNode cur = head;\n        while (cur != null){\n            array.add(cur);\n            cur = cur.next;\n        }\n        int size = k-1;\n        int max= array.size() - (array.size() % k );\n        for (int i = 0;i<max;i++){\n            System.out.println(i+\" \"+size);\n            if (size == 1-k) {\n                size = k-1;\n                continue;\n            }\n            if (size <= 0) {\n                size = size - 2;\n                continue; \n            }\n            int temp = array.get(i).val;\n            array.get(i).val = array.get(i+size).val;\n            array.get(i+size).val = temp;\n            size = size - 2;\n        }\n        return head;\n\n    }\n}","runtime":"42 ms","title":"Reverse Nodes in k-Group","url":"/submissions/detail/1152895243/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1152895243,"time":"5 days, 8 hours","lang":"java","title_slug":"reverse-nodes-in-k-group","timestamp":1705864620,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode reverseKGroup(ListNode head, int k) {\n        ArrayList<ListNode> array = new ArrayList<>();\n        ListNode cur = head;\n        while (cur != null){\n            array.add(cur);\n            cur = cur.next;\n        }\n        int size = k-1;\n        for (int i = 0;i<=array.size()-k;i++){\n            if (size == 1-k) {\n                size = k-1;\n                continue;\n            }\n            if (size <= 0) {\n                size = size - 2;\n                continue; \n            }\n            int temp = array.get(i).val;\n            array.get(i).val = array.get(i+size).val;\n            array.get(i+size).val = temp;\n            size = size - 2;\n        }\n        return head;\n\n    }\n}","runtime":"N/A","title":"Reverse Nodes in k-Group","url":"/submissions/detail/1152890811/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1152890811,"time":"5 days, 8 hours","lang":"java","title_slug":"reverse-nodes-in-k-group","timestamp":1705864259,"status":11,"is_pending":"Not Pending","compare_result":"11111111111101011111010111101101111111111111111100000101110110"},{"status_display":"Wrong Answer","memory":"N/A","code":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode reverseKGroup(ListNode head, int k) {\n        ArrayList<ListNode> array = new ArrayList<>();\n        ListNode cur = head;\n        while (cur != null){\n            array.add(cur);\n            cur = cur.next;\n        }\n        int size = k-1;\n        for (int i = 0;i<=array.size()-k;i++){\n            if (size == 1-k) {\n                size = k-1;\n                continue;\n            }\n            if (size <= 0) continue; \n            int temp = array.get(i).val;\n            array.get(i).val = array.get(i+size).val;\n            array.get(i+size).val = temp;\n            size = size - 2;\n        }\n        return head;\n\n    }\n}","runtime":"N/A","title":"Reverse Nodes in k-Group","url":"/submissions/detail/1152889496/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1152889496,"time":"5 days, 8 hours","lang":"java","title_slug":"reverse-nodes-in-k-group","timestamp":1705864156,"status":11,"is_pending":"Not Pending","compare_result":"11111111111101011011000111101101111001010001001000000001010010"},{"status_display":"Wrong Answer","memory":"N/A","code":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode reverseKGroup(ListNode head, int k) {\n        ArrayList<ListNode> array = new ArrayList<>();\n        ListNode cur = head;\n        while (cur != null){\n            array.add(cur);\n            cur = cur.next;\n        }\n        int size = k-1;\n        for (int i = 0;i<=array.size()-k;i++){\n            if (size == 1-k) {\n                size = k-1;\n                continue;\n            }\n            if (size < 0) continue; \n            int temp = array.get(i).val;\n            array.get(i).val = array.get(i+size).val;\n            array.get(i+size).val = temp;\n            size = size - 2;\n        }\n        return head;\n\n    }\n}","runtime":"N/A","title":"Reverse Nodes in k-Group","url":"/submissions/detail/1152889022/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1152889022,"time":"5 days, 8 hours","lang":"java","title_slug":"reverse-nodes-in-k-group","timestamp":1705864116,"status":11,"is_pending":"Not Pending","compare_result":"11111111111101011111000111101101111111010101001000000001010010"},{"status_display":"Accepted","memory":"41.1 MB","code":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode reverseBetween(ListNode head, int left, int right) {\n        if (left == right ) return head;\n        ListNode begin = null;\n        ListNode end = null;\n\n        ListNode cur = head;\n        ListNode cur_beg = null;\n        ListNode cur_end = null;\n        ListNode prev = null;\n        int count = 1;\n        \n\n        while (cur != null ){\n            \n            if (count == left - 1) begin = cur;\n            if (count == right + 1) end = cur;\n            if (count >= left && count <= right){\n                ListNode temp = new ListNode(cur.val, prev);\n                prev = temp;\n                if (count == left) cur_end = temp;\n                if (count == right) cur_beg = temp;\n            }\n            count++;\n            cur = cur.next;\n        }\n        if (begin !=null){\n            begin.next = cur_beg;\n        } else{\n            head = cur_beg;\n        } \n        if (end != null ){\n            cur_end.next = end;\n        }\n\n        return head;\n    }\n}","runtime":"0 ms","title":"Reverse Linked List II","url":"/submissions/detail/1152858894/","lang_name":"Java","has_notes":true,"flag_type":1,"id":1152858894,"time":"5 days, 9 hours","lang":"java","title_slug":"reverse-linked-list-ii","timestamp":1705861807,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"0B","code":"-- Write your PostgreSQL query statement below\nselect name, population, area \nfrom World\nwhere area>=3000000 or population>=25000000;","runtime":"782 ms","title":"Big Countries","url":"/submissions/detail/1135029736/","lang_name":"PostgreSQL","has_notes":false,"flag_type":1,"id":1135029736,"time":"3 weeks, 3 days","lang":"postgresql","title_slug":"big-countries","timestamp":1704231310,"status":10,"is_pending":"Not Pending","compare_result":"111111"},{"status_display":"Accepted","memory":"0B","code":"-- Write your PostgreSQL query statement below\nselect name \nfrom Customer\nwhere referee_id !=2  or referee_id IS NULL","runtime":"609 ms","title":"Find Customer Referee","url":"/submissions/detail/1135026138/","lang_name":"PostgreSQL","has_notes":false,"flag_type":1,"id":1135026138,"time":"3 weeks, 3 days","lang":"postgresql","title_slug":"find-customer-referee","timestamp":1704230934,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111"},{"status_display":"Accepted","memory":"0B","code":"-- Write your PostgreSQL query statement below\nselect name \nfrom Customer\nwhere referee_id IS NULL OR referee_id !=2;","runtime":"676 ms","title":"Find Customer Referee","url":"/submissions/detail/1135025905/","lang_name":"PostgreSQL","has_notes":false,"flag_type":1,"id":1135025905,"time":"3 weeks, 3 days","lang":"postgresql","title_slug":"find-customer-referee","timestamp":1704230907,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111"}],"has_next":true,"last_key":"%7B%22pk%22%3A%20%7B%22N%22%3A%20%221135025905%22%7D%2C%20%22dt%22%3A%20%7B%22S%22%3A%20%222024-01-02T21%3A28%3A27.965396%2B0000%22%7D%2C%20%22sid%22%3A%20%7B%22N%22%3A%20%227573785%22%7D%7D"}
2024-01-26 23:01:20.530 [main] DEBUG submission_dump - {"submissions_dump":[{"status_display":"Accepted","memory":"0B","code":"-- Write your PostgreSQL query statement below\nselect name \nfrom Customer\nwhere referee_id IS NULL OR referee_id !=2;","runtime":"541 ms","title":"Find Customer Referee","url":"/submissions/detail/1135025610/","lang_name":"PostgreSQL","has_notes":false,"flag_type":1,"id":1135025610,"time":"3 weeks, 3 days","lang":"postgresql","title_slug":"find-customer-referee","timestamp":1704230873,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111"},{"status_display":"Accepted","memory":"0B","code":"-- Write your PostgreSQL query statement below\nSELECT product_id from Products where low_fats='Y' AND recyclable= 'Y'","runtime":"1275 ms","title":"Recyclable and Low Fat Products","url":"/submissions/detail/1135023400/","lang_name":"PostgreSQL","has_notes":false,"flag_type":1,"id":1135023400,"time":"3 weeks, 3 days","lang":"postgresql","title_slug":"recyclable-and-low-fat-products","timestamp":1704230643,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111"},{"status_display":"Accepted","memory":"44 MB","code":"/*\n// Definition for a Node.\nclass Node {\n    int val;\n    Node next;\n    Node random;\n\n    public Node(int val) {\n        this.val = val;\n        this.next = null;\n        this.random = null;\n    }\n}\n*/\n\nclass Solution {\n    public Node copyRandomList(Node head) {\n        if (head == null) return null;\n\n        HashMap<Node,Node> map = new HashMap<>();\n        Node temp = new Node(head.val);\n        map.put(head,temp);\n        Node p = head.next;\n        Node prev = temp;\n        while (p!=null){\n            Node t = new Node(p.val);\n            prev.next = t;\n            map.put(p,t);\n            prev = prev.next;\n            p = p.next;\n        }\n        for (Node i: map.keySet()){\n            Node t = map.get(i);\n            t.random = map.get(i.random);\n        }\n        \n\n        return temp;\n    }\n}","runtime":"1 ms","title":"Copy List with Random Pointer","url":"/submissions/detail/1130075199/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1130075199,"time":"1 month","lang":"java","title_slug":"copy-list-with-random-pointer","timestamp":1703718042,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111"},{"status_display":"Accepted","memory":"44.4 MB","code":"/*\n// Definition for a Node.\nclass Node {\n    int val;\n    Node next;\n    Node random;\n\n    public Node(int val) {\n        this.val = val;\n        this.next = null;\n        this.random = null;\n    }\n}\n*/\n\nclass Solution {\n    public Node copyRandomList(Node head) {\n        if (head == null) return null;\n\n        HashMap<Node,Node> map = new HashMap<>();\n        Node temp = new Node(head.val);\n        map.put(head,temp);\n        Node p = head.next;\n        Node prev = temp;\n        while (p!=null){\n            Node t = new Node(p.val);\n            prev.next = t;\n            map.put(p,t);\n            prev = prev.next;\n            p = p.next;\n        }\n        for (Node i: map.keySet()){\n            Node t = map.get(i);\n            t.random = map.get(i.random);\n        }\n        \n\n        return temp;\n    }\n}","runtime":"1 ms","title":"Copy List with Random Pointer","url":"/submissions/detail/1130074485/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1130074485,"time":"1 month","lang":"java","title_slug":"copy-list-with-random-pointer","timestamp":1703717948,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111"},{"status_display":"Runtime Error","memory":"N/A","code":"/*\n// Definition for a Node.\nclass Node {\n    int val;\n    Node next;\n    Node random;\n\n    public Node(int val) {\n        this.val = val;\n        this.next = null;\n        this.random = null;\n    }\n}\n*/\n\nclass Solution {\n    public Node copyRandomList(Node head) {\n        HashMap<Node,Node> map = new HashMap<>();\n        Node temp = new Node(head.val);\n        map.put(head,temp);\n        Node p = head.next;\n        Node prev = temp;\n        while (p!=null){\n            Node t = new Node(p.val);\n            prev.next = t;\n            map.put(p,t);\n            prev = prev.next;\n            p = p.next;\n        }\n        for (Node i: map.keySet()){\n            Node t = map.get(i);\n            t.random = map.get(i.random);\n        }\n        \n\n        return temp;\n    }\n}","runtime":"N/A","title":"Copy List with Random Pointer","url":"/submissions/detail/1130074216/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1130074216,"time":"1 month","lang":"java","title_slug":"copy-list-with-random-pointer","timestamp":1703717916,"status":15,"is_pending":"Not Pending","compare_result":"1110000000000000000"},{"status_display":"Accepted","memory":"44.1 MB","code":"class Solution {\n    public int calculate(String s) {\n        Stack<Integer> st= new Stack<>();\n        char [] ch = s.toCharArray();\n        int sign = 1;\n        int runSum = 0;\n        int runNum = 0;\n        for (int i = 0;i<ch.length;i++){\n            if (ch[i]<='9' && ch[i]>='0'){\n                runNum = runNum*10 + (ch[i] - '0');\n            }\n            if (ch[i] == '+'){\n                runSum = runSum + sign*runNum;\n                sign = 1;\n                runNum = 0;\n            }\n            if (ch[i] == '-') {\n                runSum = runSum + sign*runNum;\n                sign = -1;\n                runNum = 0;\n            }\n            if (ch[i] =='('){\n                st.add(runSum);\n                st.add(sign);\n                runNum = 0;\n                runSum=0;\n                sign = 1;\n            }\n            if (ch[i] == ')'){\n                runSum = runSum + sign*runNum;\n                int tempSign = st.pop();\n                int oldSum = st.pop();\n                runSum = tempSign*runSum + oldSum;\n                runNum = 0;\n            }\n            // System.out.println(runSum +\" \"+ runNum + \" \" +sign);\n        }\n         runSum = runSum + sign*runNum;\n        return runSum;\n\n    }\n        \n}","runtime":"5 ms","title":"Basic Calculator","url":"/submissions/detail/1123906417/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1123906417,"time":"1 month, 1 week","lang":"java","title_slug":"basic-calculator","timestamp":1703045772,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int calculate(String s) {\n        Stack<Integer> st= new Stack<>();\n        char [] ch = s.toCharArray();\n        int sign = 1;\n        int runSum = 0;\n        int runNum = 0;\n        for (int i = 0;i<ch.length;i++){\n            if (ch[i]<='9' && ch[i]>='0'){\n                runNum = runNum*10 + (ch[i] - '0');\n            }\n            if (ch[i] == '+'){\n                runSum = runSum + sign*runNum;\n                sign = 1;\n                runNum = 0;\n            }\n            if (ch[i] == '-') {\n                runSum = runSum + sign*runNum;\n                sign = -1;\n                runNum = 0;\n            }\n            if (ch[i] =='('){\n                st.add(runSum);\n                st.add(sign);\n                runNum = 0;\n                runSum=0;\n            }\n            if (ch[i] == ')'){\n                runSum = runSum + sign*runNum;\n                int tempSign = st.pop();\n                int oldSum = st.pop();\n                runSum = tempSign*runSum + oldSum;\n                runNum = 0;\n            }\n            System.out.println(runSum +\" \"+ runNum + \" \" +sign);\n        }\n         runSum = runSum + sign*runNum;\n        return runSum;\n\n    }\n        \n}","runtime":"N/A","title":"Basic Calculator","url":"/submissions/detail/1123904630/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1123904630,"time":"1 month, 1 week","lang":"java","title_slug":"basic-calculator","timestamp":1703045598,"status":11,"is_pending":"Not Pending","compare_result":"111111111111101110111111100100000000000100101"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int calculate(String s) {\n        Stack<Integer> st= new Stack<>();\n        char [] ch = s.toCharArray();\n        int sign = 1;\n        int runSum = 0;\n        int runNum = 0;\n        for (int i = 0;i<ch.length;i++){\n            if (ch[i]<='9' && ch[i]>='0'){\n                runNum = runNum*10 + (ch[i] - '0');\n            }\n            if (ch[i] == '+'){\n                runSum = runSum + sign*runNum;\n                sign = 1;\n                runNum = 0;\n            }\n            if (ch[i] == '-') {\n                runSum = runSum + sign*runNum;\n                sign = -1;\n                runNum = 0;\n            }\n            if (ch[i] =='('){\n                st.add(runSum);\n                st.add(sign);\n                runNum = 0;\n                runSum=0;\n            }\n            if (ch[i] == ')'){\n                runSum = runSum + sign*runNum;\n                int tempSign = st.pop();\n                int oldSum = st.pop();\n                runSum = tempSign*runSum + oldSum;\n                runNum = 0;\n            }\n        }\n         runSum = runSum + sign*runNum;\n        return runSum;\n\n    }\n        \n}","runtime":"N/A","title":"Basic Calculator","url":"/submissions/detail/1123904460/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1123904460,"time":"1 month, 1 week","lang":"java","title_slug":"basic-calculator","timestamp":1703045581,"status":11,"is_pending":"Not Pending","compare_result":"111111111111101110111111100100000000000100101"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int calculate(String s) {\n        Stack<Integer> st= new Stack<>();\n        char [] ch = s.toCharArray();\n        int sign = 1;\n        int runSum = 0;\n        int runNum = 0;\n        for (int i = 0;i<ch.length;i++){\n            if (ch[i]<='9' && ch[i]>='0'){\n                runNum = runNum*10 + (ch[i] - '0');\n            }\n            if (ch[i] == '+'){\n                runSum = runSum + sign*runNum;\n                sign = 1;\n                runNum = 0;\n            }\n            if (ch[i] == '-') {\n                runSum = runSum + sign*runNum;\n                sign = -1;\n                runNum = 0;\n            }\n            if (ch[i] =='('){\n                st.add(runSum);\n                st.add(sign);\n                runNum = 0;\n                runSum=0;\n            }\n            if (ch[i] == ')'){\n                runSum = runSum + sign*runNum;\n                int tempSign = st.pop();\n                int oldSum = st.pop();\n                runSum = runSum + tempSign*oldSum;\n                runNum = 0;\n            }\n            // System.out.println(runSum +\" \"+ runNum + \" \" +sign);\n        }\n         runSum = runSum + sign*runNum;\n        return runSum;\n\n    }\n        \n}","runtime":"N/A","title":"Basic Calculator","url":"/submissions/detail/1123903295/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1123903295,"time":"1 month, 1 week","lang":"java","title_slug":"basic-calculator","timestamp":1703045467,"status":11,"is_pending":"Not Pending","compare_result":"111111111110101110111111100010000000000000001"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int calculate(String s) {\n        Stack<Integer> st= new Stack<>();\n        char [] ch = s.toCharArray();\n        int sign = 1;\n        int runSum = 0;\n        int runNum = 0;\n        for (int i = 0;i<ch.length;i++){\n            if (ch[i]<'9' && ch[i]>'0'){\n                runNum = runNum*10 + (ch[i] - '0');\n            }\n            if (ch[i] == '+'){\n                runSum = runSum + sign*runNum;\n                sign = 1;\n                runNum = 0;\n            }\n            if (ch[i] == '-') {\n                runSum = runSum + sign*runNum;\n                sign = -1;\n                runNum = 0;\n            }\n            if (ch[i] =='('){\n                st.add(runSum);\n                st.add(sign);\n                runNum = 0;\n                runSum=0;\n            }\n            if (ch[i] == ')'){\n                runSum = runSum + sign*runNum;\n                int tempSign = st.pop();\n                int oldSum = st.pop();\n                runSum = runSum + tempSign*oldSum;\n                runNum = 0;\n            }\n            // System.out.println(runSum +\" \"+ runNum + \" \" +sign);\n        }\n         runSum = runSum + sign*runNum;\n        return runSum;\n\n    }\n        \n}","runtime":"N/A","title":"Basic Calculator","url":"/submissions/detail/1123902299/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1123902299,"time":"1 month, 1 week","lang":"java","title_slug":"basic-calculator","timestamp":1703045372,"status":11,"is_pending":"Not Pending","compare_result":"111111101010100110101111100010000000000000001"},{"status_display":"Accepted","memory":"40.8 MB","code":"class Solution {\n    public void gameOfLife(int[][] board) {\n        int n = board.length;\n        int m = board[0].length;\n        for (int i=0;i<n;i++){\n            for (int j=0;j<m;j++){\n                int count = countValid(board,i-1,j-1) + countValid(board,i-1,j) +  countValid(board,i-1,j+1)\n                            + countValid(board,i,j-1) + countValid(board,i,j+1)\n                            + countValid(board,i+1,j-1) + countValid(board,i+1,j) + countValid(board,i+1,j+1);\n                // System.out.println(i+\" \"+j+\" \"+board[i][j]+\" \"+count) ;\n                if (board[i][j] %2 == 0 && count == 3) board[i][j] = board[i][j]+2;\n                if (board[i][j] %2 == 1 && (count ==2 || count==3)) board[i][j] = board[i][j]+2;\n            }\n        }\n        for (int i = 0;i<n;i++){\n            for (int j = 0;j<m;j++){\n                board[i][j] = board[i][j]>>1;\n            }\n        }\n    }\n\n    public int countValid(int[][] board, int x, int y){\n        int n = board.length;\n        int m = board[0].length; \n        if (x<0) return 0;\n        if (y<0) return 0;\n        if (x>=n) return 0;\n        if (y>=m) return 0;\n        return board[x][y]%2 == 0?0:1 ;\n    }\n}","runtime":"0 ms","title":"Game of Life","url":"/submissions/detail/1123838000/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1123838000,"time":"1 month, 1 week","lang":"java","title_slug":"game-of-life","timestamp":1703037806,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111"},{"status_display":"Accepted","memory":"43.3 MB","code":"class Solution {\n    public int evalRPN(String[] tokens) {\n      Stack<Integer> stack = new Stack<>();\n      for(String s: tokens){\n        if (s.equals(\"+\")){\n          int a = stack.pop();\n          int b = stack.pop();\n          stack.add(b+a);\n        }\n        else if (s.equals(\"-\")){\n          int a = stack.pop();\n          int b = stack.pop();\n          stack.add(b-a);\n        }\n        else if (s.equals(\"*\")){\n          int a = stack.pop();\n          int b = stack.pop();\n          stack.add(b*a);\n        }\n        else if (s.equals(\"/\")){\n          int a = stack.pop();\n          int b = stack.pop();\n          stack.add(b/a);\n        }\n        else stack.add(Integer.parseInt(s));\n      }\n        \n        return stack.pop();\n    }\n\n    \n}","runtime":"7 ms","title":"Evaluate Reverse Polish Notation","url":"/submissions/detail/1113956236/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1113956236,"time":"1 month, 3 weeks","lang":"java","title_slug":"evaluate-reverse-polish-notation","timestamp":1701906130,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111"},{"status_display":"Accepted","memory":"46.9 MB","code":"class MinStack {\n    Stack<Integer> stack = new Stack<>();\n    Stack<Integer> min_stack = new Stack<>();\n    public MinStack() {\n        stack = new Stack<>();\n        min_stack = new Stack<>();\n    }\n    \n    public void push(int val) {\n        if (stack.empty()){\n          stack.add(val);\n          min_stack.add(val);\n        } else{\n          stack.add(val);\n          if (val<=min_stack.peek()){\n            min_stack.add(val);\n          }\n        }\n    }\n    \n    public void pop() {\n        int temp = stack.pop();\n        if (temp == min_stack.peek()) min_stack.pop();\n    }\n    \n    public int top() {\n        return stack.peek();\n    }\n    \n    public int getMin() {\n        return min_stack.peek();\n    }\n}\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack obj = new MinStack();\n * obj.push(val);\n * obj.pop();\n * int param_3 = obj.top();\n * int param_4 = obj.getMin();\n */","runtime":"4 ms","title":"Min Stack","url":"/submissions/detail/1113939690/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1113939690,"time":"1 month, 3 weeks","lang":"java","title_slug":"min-stack","timestamp":1701903046,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111"},{"status_display":"Accepted","memory":"43.6 MB","code":"class Solution {\n    public String simplifyPath(String path) {\n        String [] split = path.split(\"/+\");\n        // for (int i = 0;i<split.length;i++){\n        //   System.out.println(split[i]);\n        // }\n        Stack<String> s = new Stack<String>();\n        for (int i = 0 ; i<split.length;i++){\n          if (split[i].equals(\"..\")){\n            if (!s.empty()) s.pop();\n          } else if (!split[i].equals(\"\") && !split[i].equals(\".\")) s.add(split[i]);\n\n        }\n        String res = \"\";\n        for (String i:s){\n          // System.out.println(i);\n          res = res+ \"/\" +i;\n        }\n        if (res.equals(\"\")) return \"/\";\n        return res;\n    }\n}","runtime":"13 ms","title":"Simplify Path","url":"/submissions/detail/1113934197/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1113934197,"time":"1 month, 3 weeks","lang":"java","title_slug":"simplify-path","timestamp":1701902122,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public String simplifyPath(String path) {\n        String [] split = path.split(\"/+\");\n        for (int i = 0;i<split.length;i++){\n          System.out.println(split[i]);\n        }\n        Stack<String> s = new Stack<String>();\n        for (int i = 0 ; i<split.length;i++){\n          if (split[i].equals(\"..\")){\n            if (!s.empty()) s.pop();\n          } else if (!split[i].equals(\"\") && !split.equals(\".\")) s.add(split[i]);\n        }\n        String res = \"\";\n        for (String i:s){\n          res = res+ \"/\" +i;\n        }\n        if (res.equals(\"\")) return \"/\";\n        return res;\n    }\n}","runtime":"N/A","title":"Simplify Path","url":"/submissions/detail/1113933314/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1113933314,"time":"1 month, 3 weeks","lang":"java","title_slug":"simplify-path","timestamp":1701901967,"status":11,"is_pending":"Not Pending","compare_result":"111000110011111111111111111111101000101101111101110000010111001010100000010101101000011011000100001000000000000000000000000000000000000000000000000000000000000000000000000000000010010000000000000000000000000000000000000000000000000000000000000000000000000011"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public String simplifyPath(String path) {\n        String [] split = path.split(\"/+\");\n        for (int i = 0;i<split.length;i++){\n          System.out.println(split[i]);\n        }\n        Stack<String> s = new Stack<String>();\n        for (int i = 0 ; i<split.length;i++){\n          if (split[i].equals(\"..\")){\n            if (!s.empty()) s.pop();\n          } else if (!split[i].equals(\"\")) s.add(split[i]);\n        }\n        String res = \"\";\n        for (String i:s){\n          res = res+ \"/\" +i;\n        }\n        if (res.equals(\"\")) return \"/\";\n        return res;\n    }\n}","runtime":"N/A","title":"Simplify Path","url":"/submissions/detail/1113933042/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1113933042,"time":"1 month, 3 weeks","lang":"java","title_slug":"simplify-path","timestamp":1701901925,"status":11,"is_pending":"Not Pending","compare_result":"111000110011111111111111111111101000101101111101110000010111001010100000010101101000011011000100001000000000000000000000000000000000000000000000000000000000000000000000000000000010010000000000000000000000000000000000000000000000000000000000000000000000000011"},{"status_display":"Accepted","memory":"78 MB","code":"class Solution {\n    public int findMinArrowShots(int[][] points) {\n        Arrays.sort(points, Comparator.comparingInt(x -> x[0]));\n        int n = points.length;\n        int count = 1;\n        int[]temp = points[0];\n\n        for (int i = 1;i<n;i++){\n\n          temp = diff(temp,points[i]);\n\n          if (temp == null){\n            temp = points[i];\n            count++;\n          }\n        }\n        return count;\n    }\n    int[] diff(int[] a, int[] b) {\n      int temp [] = new int[2];\n      if (b[1]<a[0]) return null;\n      if (b[0]>a[1]) return null;\n      temp[0] = a[0]>b[0]?a[0]:b[0];\n      temp[1] = a[1]<b[1]?a[1]:b[1];\n      return temp;\n    }\n}","runtime":"59 ms","title":"Minimum Number of Arrows to Burst Balloons","url":"/submissions/detail/1113849006/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1113849006,"time":"1 month, 3 weeks","lang":"java","title_slug":"minimum-number-of-arrows-to-burst-balloons","timestamp":1701890411,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"74.8 MB","code":"class Solution {\n    public int findMinArrowShots(int[][] points) {\n        Arrays.sort(points, Comparator.comparingInt(x -> x[0]));\n        int n = points.length;\n        int count = 1;\n        int[]temp = points[0];\n        // for (int i = 0 ; i<n;i++){\n        //   System.out.println(points[i][0] +\" \" + points[i][1]);\n        // }\n        for (int i = 1;i<n;i++){\n          // System.out.println(temp[0] +\" \" + temp[1]);\n\n          temp = diff(temp,points[i]);\n\n          if (temp == null){\n            temp = points[i];\n            count++;\n          }\n        }\n        return count;\n    }\n    int[] diff(int[] a, int[] b) {\n      int temp [] = new int[2];\n      if (b[1]<a[0]) return null;\n      if (b[0]>a[1]) return null;\n      temp[0] = a[0]>b[0]?a[0]:b[0];\n      temp[1] = a[1]<b[1]?a[1]:b[1];\n      return temp;\n    }\n}","runtime":"57 ms","title":"Minimum Number of Arrows to Burst Balloons","url":"/submissions/detail/1113848308/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1113848308,"time":"1 month, 3 weeks","lang":"java","title_slug":"minimum-number-of-arrows-to-burst-balloons","timestamp":1701890333,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"43.9 MB","code":"class Solution {\n    public int[][] insert(int[][] a, int[] b) {\n        List<int[]> re = new ArrayList<>();\n        int pointer = 0;\n        int n  = a.length;\n        int [] temp = new int[2];\n        while (pointer<n && comp(a[pointer],b) == 1 ){     \n            re.add(a[pointer]);                                           \n            pointer++;\n        }\n        // System.out.println(pointer + \" \"+ comp(a[pointer],b));\n        if (pointer == n) {\n            re.add(b);\n            return toArray(re);\n        }\n        if (comp(a[pointer],b) == -1){\n            re.add(b);\n            for (int i = pointer;i<n;i++){\n                re.add(a[i]);\n            }\n            return toArray(re);\n        }\n        if (comp(a[pointer],b)==0){\n            if (b[1]<=a[pointer][1] && b[0]>=a[pointer][0]) {\n                for (int i = pointer;i<n;i++){\n                    re.add(a[i]);\n                }\n                return toArray(re);\n            } else{\n                temp[0] = a[pointer][0]<b[0]?a[pointer][0]:b[0];\n                temp[1] = b[1]>a[pointer][1]?b[1]:a[pointer][1];\n                // re.add(temp);\n                // System.out.println(temp[0]+\" \"+temp[1]);\n\n                pointer++;\n                while (pointer<n){\n                    if (comp(temp,a[pointer]) == 0){\n                        temp[1]= a[pointer][1]>temp[1]?a[pointer][1]:temp[1];\n                    } else{\n                        break;\n                    }\n                    pointer++;\n                }\n                re.add(temp);\n                for (int i = pointer;i<n;i++){\n                    re.add(a[i]);\n                }\n            }\n        }\n        return toArray(re);\n        \n    }\n    public int[][] toArray(List<int[]> re ){\n      int [][] a = new int[re.size()][2];\n      for (int i = 0; i< re.size();i++){\n        a[i][0] = re.get(i)[0];\n        a[i][1] = re.get(i)[1];\n      }\n      return a;\n    }\n    public int comp(int[] a, int[] x){\n        if (x[1]<a[0]) return -1;\n        if (x[0]>a[1]) return 1;\n        return 0;\n    }\n}","runtime":"1 ms","title":"Insert Interval","url":"/submissions/detail/1113831592/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1113831592,"time":"1 month, 3 weeks","lang":"java","title_slug":"insert-interval","timestamp":1701888553,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"44.2 MB","code":"class Solution {\n    public int[][] insert(int[][] a, int[] b) {\n        List<int[]> re = new ArrayList<>();\n        int pointer = 0;\n        int n  = a.length;\n        int [] temp = new int[2];\n        while (pointer<n && comp(a[pointer],b) == 1 ){     \n            re.add(a[pointer]);                                           \n            pointer++;\n        }\n        // System.out.println(pointer + \" \"+ comp(a[pointer],b));\n        if (pointer == n) {\n            re.add(b);\n            return toArray(re);\n        }\n        if (comp(a[pointer],b) == -1){\n            re.add(b);\n            for (int i = pointer;i<n;i++){\n                re.add(a[i]);\n            }\n            return toArray(re);\n        }\n        if (comp(a[pointer],b)==0){\n            if (b[1]<=a[pointer][1] && b[0]>=a[pointer][0]) {\n                for (int i = pointer;i<n;i++){\n                    re.add(a[i]);\n                }\n                return toArray(re);\n            } else{\n                temp[0] = a[pointer][0]<b[0]?a[pointer][0]:b[0];\n                temp[1] = b[1]>a[pointer][1]?b[1]:a[pointer][1];\n                // re.add(temp);\n                // System.out.println(temp[0]+\" \"+temp[1]);\n\n                pointer++;\n                while (pointer<n){\n                    if (comp(temp,a[pointer]) == 0){\n                        temp[1]= a[pointer][1]>temp[1]?a[pointer][1]:temp[1];\n                    } else{\n                        break;\n                    }\n                    pointer++;\n                }\n                re.add(temp);\n                for (int i = pointer;i<n;i++){\n                    re.add(a[i]);\n                }\n            }\n        }\n        return toArray(re);\n        \n    }\n    public int[][] toArray(List<int[]> re ){\n      int [][] a = new int[re.size()][2];\n      for (int i = 0; i< re.size();i++){\n        a[i][0] = re.get(i)[0];\n        a[i][1] = re.get(i)[1];\n      }\n      return a;\n    }\n    public int comp(int[] a, int[] x){\n        if (x[1]<a[0]) return -1;\n        if (x[0]>a[1]) return 1;\n        return 0;\n    }\n}","runtime":"1 ms","title":"Insert Interval","url":"/submissions/detail/1113830608/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1113830608,"time":"1 month, 3 weeks","lang":"java","title_slug":"insert-interval","timestamp":1701888456,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}],"has_next":true,"last_key":"%7B%22pk%22%3A%20%7B%22N%22%3A%20%221113830608%22%7D%2C%20%22dt%22%3A%20%7B%22S%22%3A%20%222023-12-06T18%3A47%3A36.916840%2B0000%22%7D%2C%20%22sid%22%3A%20%7B%22N%22%3A%20%227573785%22%7D%7D"}
2024-01-26 23:01:31.080 [main] DEBUG submission_dump - {"submissions_dump":[{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int[][] insert(int[][] a, int[] b) {\n        List<int[]> re = new ArrayList<>();\n        int pointer = 0;\n        int n  = a.length;\n        int [] temp = new int[2];\n        while (pointer<n && comp(a[pointer],b) == 1 ){     \n            re.add(a[pointer]);                                           \n            pointer++;\n        }\n        // System.out.println(pointer);\n        if (pointer == n) {\n            re.add(b);\n            return toArray(re);\n        }\n        if (comp(a[pointer],b) == -1){\n            re.add(b);\n            for (int i = pointer;i<n;i++){\n                re.add(a[i]);\n            }\n            return toArray(re);\n        }\n        if (comp(a[pointer],b)==0){\n            if (b[1]<=a[pointer][1]) {\n                for (int i = pointer;i<n;i++){\n                    re.add(a[i]);\n                }\n                return toArray(re);\n            } else{\n                temp[0] = a[pointer][0];\n                temp[1] = b[1];\n                // re.add(temp);\n                pointer++;\n                while (pointer<n){\n                    if (comp(temp,a[pointer]) == 0){\n                        temp[1]= a[pointer][1]>temp[1]?a[pointer][1]:temp[1];\n                    } else{\n                        break;\n                    }\n                    pointer++;\n                }\n                re.add(temp);\n                for (int i = pointer;i<n;i++){\n                    re.add(a[i]);\n                }\n            }\n        }\n        return toArray(re);\n        \n    }\n    public int[][] toArray(List<int[]> re ){\n      int [][] a = new int[re.size()][2];\n      for (int i = 0; i< re.size();i++){\n        a[i][0] = re.get(i)[0];\n        a[i][1] = re.get(i)[1];\n      }\n      return a;\n    }\n    public int comp(int[] a, int[] x){\n        if (x[0]<a[0]) return -1;\n        if (x[0]>a[1]) return 1;\n        return 0;\n    }\n}","runtime":"N/A","title":"Insert Interval","url":"/submissions/detail/1113825610/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1113825610,"time":"1 month, 3 weeks","lang":"java","title_slug":"insert-interval","timestamp":1701887947,"status":11,"is_pending":"Not Pending","compare_result":"111111110010011101011111111111111111111110111111101111110111111111111111111111111111111111110011111111111111111111011011111111111111111010011111111111110111"},{"status_display":"Accepted","memory":"43.3 MB","code":"\nclass Solution {\n    public int[] sortByBits(int[] arr) {\n        List<Integer> a = new ArrayList<Integer>();\n        for (int i :arr) a.add(i);\n        Collections.sort(a,new Comparator<Integer>() {\n            @Override\n            public int compare(Integer a, Integer b){\n                if (Integer.compare(Integer.bitCount(a),Integer.bitCount(b)) == 0) \n                    return Integer.compare(a,b);\n                return Integer.compare(Integer.bitCount(a),Integer.bitCount(b));\n            }\n        } );\n        int []re = new int[a.size()];\n        for (int i = 0; i< re.length;i++) re[i] = a.get(i);\n        return re;\n    }\n}","runtime":"9 ms","title":"Sort Integers by The Number of 1 Bits","url":"/submissions/detail/1095491223/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1095491223,"time":"2 months, 2 weeks","lang":"java","title_slug":"sort-integers-by-the-number-of-1-bits","timestamp":1699562417,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"53.7 MB","code":"class Solution {\n    public int equalPairs(int[][] grid) {\n        HashMap<String,Integer> map1 = new HashMap<>();\n        HashMap<String,Integer> map2 = new HashMap<>();\n\n        int n = grid.length;\n        int m = grid[0].length;\n        for (int i = 0 ; i<n;i++){\n            String k = \"\";\n            for (int j = 0; j<m;j++){\n                k = k+grid[i][j]+\",\";\n            }\n            map1.put(k,map1.getOrDefault(k,0)+1);\n        }\n        for (int i=0;i<m;i++){\n            String k = \"\";\n            for (int j = 0; j<n;j++){\n                k = k+grid[j][i]+\",\";\n            }\n            map2.put(k,map2.getOrDefault(k,0)+1);\n        }\n        int re = 0;\n        for (String s: map1.keySet()){\n            if (map2.containsKey(s)){\n                re = re + map1.get(s)*map2.get(s);\n            }\n        }\n        return re;\n    }\n}","runtime":"87 ms","title":"Equal Row and Column Pairs","url":"/submissions/detail/1095480296/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1095480296,"time":"2 months, 2 weeks","lang":"java","title_slug":"equal-row-and-column-pairs","timestamp":1699561122,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"44.4 MB","code":"class Solution {\n    public int countHomogenous(String s) {\n        long count = 0;\n        int pointer = 0;\n        char [] a = s.toCharArray();\n        int beg = 0;\n        while (pointer<a.length){\n            while (pointer < a.length-1 && a[pointer] == a[pointer +1]) pointer ++;\n            long len = pointer - beg +1;\n            count = (count + len*(len+1)/2) % 1000000007;\n            pointer++;\n            beg= pointer;\n        }\n        return Math.toIntExact(count);\n        \n    }\n}","runtime":"6 ms","title":"Count Number of Homogenous Substrings","url":"/submissions/detail/1095475180/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1095475180,"time":"2 months, 2 weeks","lang":"java","title_slug":"count-number-of-homogenous-substrings","timestamp":1699560549,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int countHomogenous(String s) {\n        int count = 0;\n        int pointer = 0;\n        char [] a = s.toCharArray();\n        int beg = 0;\n        while (pointer<a.length){\n            while (pointer < a.length-1 && a[pointer] == a[pointer +1]) pointer ++;\n            int len = pointer - beg +1;\n            count = (count + len*(len+1)/2) % 100000007;\n            pointer++;\n            beg= pointer;\n        }\n        return count;\n        \n    }\n}","runtime":"N/A","title":"Count Number of Homogenous Substrings","url":"/submissions/detail/1095471980/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1095471980,"time":"2 months, 2 weeks","lang":"java","title_slug":"count-number-of-homogenous-substrings","timestamp":1699560192,"status":11,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111110111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int countHomogenous(String s) {\n        int count = 0;\n        int pointer = 0;\n        char [] a = s.toCharArray();\n        int beg = 0;\n        while (pointer<a.length){\n            while (pointer < a.length-1 && a[pointer] == a[pointer +1]) pointer ++;\n            int len = pointer - beg +1;\n            count = (count + len*(len+1)/2) % 1000000007;\n            pointer++;\n            beg= pointer;\n        }\n        return count;\n        \n    }\n}","runtime":"N/A","title":"Count Number of Homogenous Substrings","url":"/submissions/detail/1095471629/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1095471629,"time":"2 months, 2 weeks","lang":"java","title_slug":"count-number-of-homogenous-substrings","timestamp":1699560151,"status":11,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111110111111"},{"status_display":"Accepted","memory":"57.9 MB","code":"class Solution {\n    public int longestConsecutive(int[] nums) {\n        HashMap<Integer,Integer> map = new HashMap<>();\n        int max = 0;\n        for (int i:nums){\n            if (map.containsKey(i)) continue;\n            if ( (map.containsKey(i-1) && map.containsKey(i+1)) ){\n                map.put(i,1+map.get(i-1)+map.get(i+1));\n                map.put(i-map.get(i-1),map.get(i));\n                map.put(i+map.get(i+1),map.get(i));\n            } else if (map.containsKey(i-1)){\n                map.put(i,map.get(i-1)+1);\n                map.put(i-map.get(i-1),map.get(i));\n            } else if (map.containsKey(i+1)){\n                map.put(i,map.get(i+1)+1);\n                map.put(i+map.get(i+1),map.get(i));\n            } else{\n                map.put(i,1);\n            }\n            if (max< map.get(i)) max = map.get(i);\n        }\n        return max; \n        \n    }\n}","runtime":"74 ms","title":"Longest Consecutive Sequence","url":"/submissions/detail/1090933513/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1090933513,"time":"2 months, 3 weeks","lang":"java","title_slug":"longest-consecutive-sequence","timestamp":1699053737,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int longestConsecutive(int[] nums) {\n        HashMap<Integer,Integer> map = new HashMap<>();\n        int max = 0;\n        for (int i:nums){\n            if ( (map.containsKey(i-1) && map.containsKey(i+1)) ){\n                map.put(i,1+map.get(i-1)+map.get(i+1));\n                map.put(i-map.get(i-1),map.get(i));\n                map.put(i+map.get(i+1),map.get(i));\n            } else if (map.containsKey(i-1)){\n                map.put(i,map.get(i-1)+1);\n                map.put(i-map.get(i-1),map.get(i));\n            } else if (map.containsKey(i+1)){\n                map.put(i,map.get(i+1)+1);\n                map.put(i+map.get(i+1),map.get(i));\n            } else{\n                map.put(i,1);\n            }\n            if (max< map.get(i)) max = map.get(i);\n        }\n        return max; \n        \n    }\n}","runtime":"N/A","title":"Longest Consecutive Sequence","url":"/submissions/detail/1090932821/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1090932821,"time":"2 months, 3 weeks","lang":"java","title_slug":"longest-consecutive-sequence","timestamp":1699053623,"status":11,"is_pending":"Not Pending","compare_result":"111111111011111011110001010000110101000000001100001010000000001011011111111"},{"status_display":"Accepted","memory":"40 MB","code":"class Solution {\n    public int uniquePathsWithObstacles(int[][] grid) {\n        int n = grid.length;\n        int m = grid[0].length;\n        int [][] dp = new int[n][m];\n        if (grid[0][0] == 1) return 0;\n        int val = 1;\n        for (int i = 0; i<n;i++){\n            if (grid[i][0] == 1) val = Integer.MAX_VALUE;\n            dp[i][0] = val;\n        }\n        val = 1;\n        for (int i = 0; i<m;i++){\n            if (grid[0][i] == 1) val = Integer.MAX_VALUE;\n            dp[0][i] = val;\n        }\n        for (int i=0;i<n;i++){\n            for (int j = 0;j<m;j++){\n                if (grid[i][j] == 1) dp[i][j] = Integer.MAX_VALUE;\n            }\n        }\n\n        // for (int i = 0;i<n;i++){\n        //     for (int j = 0; j<m ; j++){\n        //         System.out.print(dp[i][j] + \" \");\n        //     }\n        //     System.out.println();\n        // }\n        \n        for (int i = 1; i<n;i++){\n            for (int j = 1;j<m;j++){\n                if (grid[i][j] == 0) {\n                    if (valid(i-1,j,n,m,dp) == Integer.MAX_VALUE && valid(i,j-1,n,m,dp) == Integer.MAX_VALUE ) dp[i][j] = Integer.MAX_VALUE;\n                    else if (valid(i-1,j,n,m,dp)== Integer.MAX_VALUE ) dp[i][j] = valid(i,j-1,n,m,dp);\n                    else if ( valid(i,j-1,n,m,dp) == Integer.MAX_VALUE) dp[i][j] = valid(i-1,j,n,m,dp);\n                    else dp[i][j] = valid(i-1,j,n,m,dp) + valid(i,j-1,n,m,dp);\n                }\n            }\n        }\n        // for (int i = 0;i<n;i++){\n        //     for (int j = 0; j<m ; j++){\n        //         System.out.print(dp[i][j] + \" \");\n        //     }\n        //     System.out.println();\n        // }\n\n        // for (int )\n        return dp[n-1][m-1]==Integer.MAX_VALUE?0:dp[n-1][m-1];\n    }\n\n    public int valid(int x,int y,int n,int m, int [][]dp){\n        if (x>=n) return Integer.MAX_VALUE;\n        if (y>=m) return Integer.MAX_VALUE;\n        if (x<0) return Integer.MAX_VALUE;\n        if (y<0) return Integer.MAX_VALUE;\n        if (dp[x][y] == Integer.MAX_VALUE) return Integer.MAX_VALUE;\n        return dp[x][y];\n    }\n}","runtime":"1 ms","title":"Unique Paths II","url":"/submissions/detail/1089308951/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1089308951,"time":"2 months, 3 weeks","lang":"java","title_slug":"unique-paths-ii","timestamp":1698861103,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int uniquePathsWithObstacles(int[][] grid) {\n        int n = grid.length;\n        int m = grid[0].length;\n        int [][] dp = new int[n][m];\n        if (grid[0][0] == 1) return 0;\n        \n        for (int i = 0; i<n;i++){\n            dp[i][0] = 1;\n        }\n        for (int i = 0; i<m;i++){\n            dp[0][i] = 1;\n        }\n        for (int i=0;i<n;i++){\n            for (int j = 0;j<m;j++){\n                if (grid[i][j] == 1) dp[i][j] = Integer.MAX_VALUE;\n            }\n        }\n        for (int i = 1; i<n;i++){\n            for (int j = 1;j<m;j++){\n                if (grid[i][j] == 0) {\n                    if (valid(i-1,j,n,m,dp) == Integer.MAX_VALUE && valid(i,j-1,n,m,dp) == Integer.MAX_VALUE ) dp[i][j] = Integer.MAX_VALUE;\n                    else if (valid(i-1,j,n,m,dp)== Integer.MAX_VALUE ) dp[i][j] = valid(i,j-1,n,m,dp);\n                    else if ( valid(i,j-1,n,m,dp) == Integer.MAX_VALUE) dp[i][j] = valid(i-1,j,n,m,dp);\n                    else dp[i][j] = valid(i-1,j,n,m,dp) + valid(i,j-1,n,m,dp);\n                }\n            }\n        }\n\n        // for (int )\n        return dp[n-1][m-1]==Integer.MAX_VALUE?0:dp[n-1][m-1];\n    }\n\n    public int valid(int x,int y,int n,int m, int [][]dp){\n        if (x>=n) return Integer.MAX_VALUE;\n        if (y>=m) return Integer.MAX_VALUE;\n        if (x<0) return Integer.MAX_VALUE;\n        if (y<0) return Integer.MAX_VALUE;\n        if (dp[x][y] == Integer.MAX_VALUE) return Integer.MAX_VALUE;\n        return dp[x][y];\n    }\n}","runtime":"N/A","title":"Unique Paths II","url":"/submissions/detail/1089300284/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1089300284,"time":"2 months, 3 weeks","lang":"java","title_slug":"unique-paths-ii","timestamp":1698860454,"status":11,"is_pending":"Not Pending","compare_result":"11111111111111111101011110100000000111011"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int uniquePathsWithObstacles(int[][] grid) {\n        int n = grid.length;\n        int m = grid[0].length;\n        int [][] dp = new int[n][m];\n        if (grid[0][0] == 1) return 0;\n        \n        for (int i = 0; i<n;i++){\n            dp[i][0] = 1;\n        }\n        for (int i = 0; i<m;i++){\n            dp[0][i] = 1;\n        }\n        for (int i=0;i<n;i++){\n            for (int j = 0;j<m;j++){\n                if (grid[i][j] == 1) dp[i][j] = Integer.MAX_VALUE;\n            }\n        }\n        for (int i = 1; i<n;i++){\n            for (int j = 1;j<m;j++){\n                if (grid[i][j] == 0) {\n                    dp[i][j] = valid(i-1,j,n,m,dp) + valid(i,j-1,n,m,dp);\n                }\n            }\n        }\n\n        // for (int )\n        return dp[n-1][m-1]==Integer.MAX_VALUE?0:dp[n-1][m-1];\n    }\n\n    public int valid(int x,int y,int n,int m, int [][]dp){\n        if (x>=n) return 0;\n        if (y>=m) return 0;\n        if (x<0) return 0;\n        if (y<0) return 0;\n        if (dp[x][y] == Integer.MAX_VALUE) return 0;\n        return dp[x][y];\n    }\n}","runtime":"N/A","title":"Unique Paths II","url":"/submissions/detail/1088642751/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1088642751,"time":"2 months, 3 weeks","lang":"java","title_slug":"unique-paths-ii","timestamp":1698784147,"status":11,"is_pending":"Not Pending","compare_result":"11111111111111111101011110100000000111011"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int uniquePathsWithObstacles(int[][] grid) {\n        int n = grid.length;\n        int m = grid[0].length;\n        int [][] dp = new int[n][m];\n\n        \n        for (int i = 0; i<n;i++){\n            dp[i][0] = 1;\n        }\n        for (int i = 0; i<m;i++){\n            dp[0][i] = 1;\n        }\n        for (int i=0;i<n;i++){\n            for (int j = 0;j<m;j++){\n                if (grid[i][j] == 1) dp[i][j] = Integer.MAX_VALUE;\n            }\n        }\n        for (int i = 1; i<n;i++){\n            for (int j = 1;j<m;j++){\n                if (grid[i][j] == 0) {\n                    dp[i][j] = valid(i-1,j,n,m,dp) + valid(i,j-1,n,m,dp);\n                }\n            }\n        }\n\n        // for (int )\n        return dp[n-1][m-1]==Integer.MAX_VALUE?0:dp[n-1][m-1];\n    }\n\n    public int valid(int x,int y,int n,int m, int [][]dp){\n        if (x>=n) return 0;\n        if (y>=m) return 0;\n        if (x<0) return 0;\n        if (y<0) return 0;\n        if (dp[x][y] == Integer.MAX_VALUE) return 0;\n        return dp[x][y];\n    }\n}","runtime":"N/A","title":"Unique Paths II","url":"/submissions/detail/1088642393/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1088642393,"time":"2 months, 3 weeks","lang":"java","title_slug":"unique-paths-ii","timestamp":1698784106,"status":11,"is_pending":"Not Pending","compare_result":"11111110111011110101011110000000000111011"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int uniquePathsWithObstacles(int[][] grid) {\n        int n = grid.length;\n        int m = grid[0].length;\n        int [][] dp = new int[n][m];\n\n        \n        for (int i = 0; i<n;i++){\n            dp[i][0] = 1;\n        }\n        for (int i = 0; i<m;i++){\n            dp[0][i] = 1;\n        }\n        for (int i=0;i<n;i++){\n            for (int j = 0;j<m;j++){\n                if (grid[i][j] == 1) dp[i][j] = Integer.MAX_VALUE;\n            }\n        }\n        for (int i = 1; i<n;i++){\n            for (int j = 1;j<m;j++){\n                if (grid[i][j] == 0) {\n                    dp[i][j] = valid(i-1,j,n,m,dp) + valid(i,j-1,n,m,dp);\n                }\n            }\n        }\n\n        // for (int )\n        return dp[n-1][m-1];\n    }\n\n    public int valid(int x,int y,int n,int m, int [][]dp){\n        if (x>=n) return 0;\n        if (y>=m) return 0;\n        if (x<0) return 0;\n        if (y<0) return 0;\n        if (dp[x][y] == Integer.MAX_VALUE) return 0;\n        return dp[x][y];\n    }\n}","runtime":"N/A","title":"Unique Paths II","url":"/submissions/detail/1088642006/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1088642006,"time":"2 months, 3 weeks","lang":"java","title_slug":"unique-paths-ii","timestamp":1698784062,"status":11,"is_pending":"Not Pending","compare_result":"11010100010001110101011100000000000111011"},{"status_display":"Accepted","memory":"43.8 MB","code":"class Solution {\n    public int minPathSum(int[][] grid) {\n        int n = grid.length;\n        int m = grid[0].length;\n        int [][] dp = new int[n][m];\n        for (int i = 0;i<n;i++ )\n            Arrays.fill(dp[i],Integer.MAX_VALUE);\n        dp[0][0] = grid[0][0];\n        for (int i = 0; i<n;i++){\n            for (int j = 0;j<m;j++){\n                if (valid(i+1,j,n,m)){\n                    dp[i+1][j] = Integer.min(grid[i+1][j] + dp[i][j],dp[i+1][j]);\n                }\n                if (valid(i-1,j,n,m)){\n                    dp[i-1][j] = Integer.min(grid[i-1][j] + dp[i][j],dp[i-1][j]);\n                }\n                if (valid(i,j+1,n,m)){\n                    dp[i][j+1] = Integer.min(grid[i][j+1] + dp[i][j],dp[i][j+1]);\n                }\n                if (valid(i,j-1,n,m)){\n                    dp[i][j-1] = Integer.min(grid[i][j-1] + dp[i][j],dp[i][j-1]);\n                }\n            }\n        }\n\n        // for (int )\n        return dp[n-1][m-1];\n        \n    }\n    public boolean valid(int x,int y,int n,int m){\n        if (x>=n) return false;\n        if (y>=m) return false;\n        if (x<0) return false;\n        if (y<0) return false;\n        return true;\n    }\n}","runtime":"16 ms","title":"Minimum Path Sum","url":"/submissions/detail/1088621425/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1088621425,"time":"2 months, 3 weeks","lang":"java","title_slug":"minimum-path-sum","timestamp":1698781781,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"43.6 MB","code":"class Solution {\n    public int minimumTotal(List<List<Integer>> triangle) {\n\n        for (int i = 1;i<triangle.size();i++){\n            int m = triangle.get(i).size();\n            for (int j = 0; j< m;j++){\n                int l = j-1;\n                int r = j;\n                if (l<0) triangle.get(i).set(j,triangle.get(i).get(j) + triangle.get(i-1).get(r));\n                else if (r>=triangle.get(i-1).size() ) triangle.get(i).set(j,triangle.get(i).get(j) + triangle.get(i-1).get(l));\n                else triangle.get(i).set(j,Integer.min(triangle.get(i).get(j) + triangle.get(i-1).get(r), triangle.get(i).get(j) + triangle.get(i-1).get(l)));\n            }\n        }\n        int min = Integer.MAX_VALUE;\n        for (int i = 0;i<triangle.get(triangle.size()-1).size();i++){\n            if (min>triangle.get(triangle.size()-1).get(i)) min = triangle.get(triangle.size()-1).get(i);\n        }\n        return min;\n    }\n}","runtime":"10 ms","title":"Triangle","url":"/submissions/detail/1088575661/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1088575661,"time":"2 months, 3 weeks","lang":"java","title_slug":"triangle","timestamp":1698777427,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"43.9 MB","code":"class Solution {\n    public int minimumTotal(List<List<Integer>> triangle) {\n\n        for (int i = 1;i<triangle.size();i++){\n            int m = triangle.get(i).size();\n            for (int j = 0; j< m;j++){\n                int l = j-1;\n                int r = j;\n                if (l<0) triangle.get(i).set(j,triangle.get(i).get(j) + triangle.get(i-1).get(r));\n                else if (r>=triangle.get(i-1).size() ) triangle.get(i).set(j,triangle.get(i).get(j) + triangle.get(i-1).get(l));\n                else triangle.get(i).set(j,Integer.min(triangle.get(i).get(j) + triangle.get(i-1).get(r), triangle.get(i).get(j) + triangle.get(i-1).get(l)));\n            }\n        }\n        int min = Integer.MAX_VALUE;\n        for (int i = 0;i<triangle.get(triangle.size()-1).size();i++){\n            if (min>triangle.get(triangle.size()-1).get(i)) min = triangle.get(triangle.size()-1).get(i);\n        }\n        return min;\n    }\n}","runtime":"10 ms","title":"Triangle","url":"/submissions/detail/1088575551/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1088575551,"time":"2 months, 3 weeks","lang":"java","title_slug":"triangle","timestamp":1698777419,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"43.7 MB","code":"class Solution {\n    public int minimumTotal(List<List<Integer>> triangle) {\n        List<List<Integer>> dp = new ArrayList<>();\n        ArrayList<Integer> first = new ArrayList<>();\n        first.add(triangle.get(0).get(0));\n        dp.add(first);\n        for (int i = 1;i<triangle.size();i++){\n            int m = triangle.get(i).size();\n            ArrayList<Integer> temp = new ArrayList<>();\n            for (int j = 0; j< m;j++){\n                int l = j-1;\n                int r = j;\n                if (l<0) temp.add(triangle.get(i).get(j) + dp.get(i-1).get(r));\n                else if (r>=triangle.get(i-1).size() ) temp.add(triangle.get(i).get(j) + dp.get(i-1).get(l));\n                else temp.add(Integer.min(triangle.get(i).get(j) + dp.get(i-1).get(r), triangle.get(i).get(j) + dp.get(i-1).get(l)));\n            }\n            dp.add(temp);\n        }\n        int min = Integer.MAX_VALUE;\n        for (int i = 0;i<dp.get(dp.size()-1).size();i++){\n            if (min>dp.get(dp.size()-1).get(i)) min = dp.get(dp.size()-1).get(i);\n        }\n        return min;\n    }\n}","runtime":"9 ms","title":"Triangle","url":"/submissions/detail/1088573114/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1088573114,"time":"2 months, 3 weeks","lang":"java","title_slug":"triangle","timestamp":1698777213,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"56.8 MB","code":"class Solution {\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\n        HashMap<Integer,Integer> m = new HashMap<>();\n        for (int i = 0; i< nums.length;i++){\n            if (!m.containsKey(nums[i])){\n                m.put(nums[i],i);\n            } else{\n                if (i-m.get(nums[i])<= k) return true;\n                m.put(nums[i],i);\n            }\n        }\n        return false;\n    }\n}","runtime":"20 ms","title":"Contains Duplicate II","url":"/submissions/detail/1087892084/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1087892084,"time":"2 months, 4 weeks","lang":"java","title_slug":"contains-duplicate-ii","timestamp":1698702911,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"43.4 MB","code":"/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public boolean hasCycle(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        if (head == null) return false;\n        if (head.next == null ) return false;\n        if (head.next.next == null) return false;\n        while (slow!=null && fast!=null){\n            // if (slow.next == null) return false;\n            if (fast.next == null) return false;\n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast) return true;\n        }\n        return false;\n        \n    }\n}","runtime":"0 ms","title":"Linked List Cycle","url":"/submissions/detail/1087887961/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1087887961,"time":"2 months, 4 weeks","lang":"java","title_slug":"linked-list-cycle","timestamp":1698702360,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111"},{"status_display":"Runtime Error","memory":"N/A","code":"/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public boolean hasCycle(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        if (head == null) return false;\n        if (head.next == null ) return false;\n        if (head.next.next == null) return false;\n        while (slow!=null && fast!=null){\n            \n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast) return true;\n        }\n        return false;\n        \n    }\n}","runtime":"N/A","title":"Linked List Cycle","url":"/submissions/detail/1087887197/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1087887197,"time":"2 months, 4 weeks","lang":"java","title_slug":"linked-list-cycle","timestamp":1698702252,"status":15,"is_pending":"Not Pending","compare_result":"11111111111111000000000"}],"has_next":true,"last_key":"%7B%22pk%22%3A%20%7B%22N%22%3A%20%221087887197%22%7D%2C%20%22dt%22%3A%20%7B%22S%22%3A%20%222023-10-30T21%3A44%3A12.659887%2B0000%22%7D%2C%20%22sid%22%3A%20%7B%22N%22%3A%20%227573785%22%7D%7D"}
2024-01-26 23:01:41.649 [main] DEBUG submission_dump - {"submissions_dump":[{"status_display":"Accepted","memory":"42.9 MB","code":"/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public boolean hasCycle(ListNode head) {\n        HashSet<ListNode> set = new HashSet<>();\n        while (head!=null){\n            if (set.contains(head)) return true;\n            set.add(head);\n            head = head.next;\n        }\n        return false;\n        \n    }\n}","runtime":"4 ms","title":"Linked List Cycle","url":"/submissions/detail/1087885291/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1087885291,"time":"2 months, 4 weeks","lang":"java","title_slug":"linked-list-cycle","timestamp":1698701992,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111"},{"status_display":"Accepted","memory":"40.8 MB","code":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {\n        ListNode re = null;\n        if (list2 == null) return list1;\n        if (list1 == null) return list2;\n        if (list1.val >= list2.val){\n            re = list2;\n            list2 = list2.next;\n        }  else{\n            re = list1;\n            list1 = list1.next;\n        }\n        ListNode cur = re;\n        while (list1!=null && list2!=null){\n            if (list1.val>=list2.val){\n                cur.next = list2;\n                list2 = list2.next;\n            } else{\n                cur.next = list1;\n                list1 = list1.next;\n            }\n            cur = cur.next;\n        }\n        if (list1 == null) cur.next = list2;\n        if (list2 == null) cur.next = list1;\n        return re;\n        \n    }\n}","runtime":"0 ms","title":"Merge Two Sorted Lists","url":"/submissions/detail/1087883993/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1087883993,"time":"2 months, 4 weeks","lang":"java","title_slug":"merge-two-sorted-lists","timestamp":1698701815,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"41.5 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null ) return 0;\n        return Integer.max(maxDepth(root.left)+1,maxDepth(root.right)+1);\n    }\n}","runtime":"0 ms","title":"Maximum Depth of Binary Tree","url":"/submissions/detail/1087879511/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1087879511,"time":"2 months, 4 weeks","lang":"java","title_slug":"maximum-depth-of-binary-tree","timestamp":1698701217,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"39.9 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null) return false;\n        if ( p.val!=q.val ) return false;\n        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n        \n    }\n}","runtime":"0 ms","title":"Same Tree","url":"/submissions/detail/1087878932/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1087878932,"time":"2 months, 4 weeks","lang":"java","title_slug":"same-tree","timestamp":1698701138,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"39.6 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode invertTree(TreeNode root) {\n        iTree(root);\n        return root;\n    }\n    public void iTree(TreeNode root){\n        if (root == null) return;\n        TreeNode temp = root.left;\n        root.left = root.right;\n        root.right = temp;\n        iTree(root.left);\n        iTree(root.right);\n    }\n}","runtime":"0 ms","title":"Invert Binary Tree","url":"/submissions/detail/1087877829/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1087877829,"time":"2 months, 4 weeks","lang":"java","title_slug":"invert-binary-tree","timestamp":1698701002,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"40.1 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean isSymmetric(TreeNode root) {\n        return isS(root.left,root.right);\n    }\n\n    public boolean isS(TreeNode l, TreeNode r){\n        if (l == null && r == null) return true;\n        if (l==null) return false;\n        if (r == null) return false;\n        if (l.val != r.val) return false;\n        return isS(l.left,r.right) && isS(l.right,r.left);\n    }\n}","runtime":"0 ms","title":"Symmetric Tree","url":"/submissions/detail/1087874307/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1087874307,"time":"2 months, 4 weeks","lang":"java","title_slug":"symmetric-tree","timestamp":1698700548,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"45.8 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int countNodes(TreeNode root) {\n        return root==null?0:1 + countNodes(root.left) + countNodes(root.right);\n    }\n}","runtime":"0 ms","title":"Count Complete Tree Nodes","url":"/submissions/detail/1087869562/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1087869562,"time":"2 months, 4 weeks","lang":"java","title_slug":"count-complete-tree-nodes","timestamp":1698699925,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111"},{"status_display":"Accepted","memory":"45.4 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int countNodes(TreeNode root) {\n        if (root == null) return 0;\n        return 1 + countNodes(root.left) + countNodes(root.right);\n        \n    }\n}","runtime":"0 ms","title":"Count Complete Tree Nodes","url":"/submissions/detail/1087869174/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1087869174,"time":"2 months, 4 weeks","lang":"java","title_slug":"count-complete-tree-nodes","timestamp":1698699877,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111"},{"status_display":"Accepted","memory":"44.5 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<Double> averageOfLevels(TreeNode root) {\n        List<TreeNode> layer = new ArrayList<>();\n        layer.add(root);\n        List<Double> re = new ArrayList<>();\n        while (layer.size()!=0){\n            re.add(avgList(layer));\n            layer = getChildList(layer);\n        }\n        return re;\n    }\n\n    public double avgList(List<TreeNode> layer){\n        double re = 0;\n        int count = 0;\n        for (TreeNode i: layer){\n            if (i!=null){\n                re = re + i.val;\n                count++;\n            }\n        }\n        re = (double) re / (double) count;\n        return re;\n    }\n    public List<TreeNode> getChildList(List<TreeNode> layer){\n        List<TreeNode> re= new ArrayList<>();\n        for (TreeNode i: layer){\n            if (i.left != null) re.add(i.left);\n            if (i.right != null) re.add(i.right);\n        }\n        return re;\n    }\n}","runtime":"1 ms","title":"Average of Levels in Binary Tree","url":"/submissions/detail/1087867840/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1087867840,"time":"2 months, 4 weeks","lang":"java","title_slug":"average-of-levels-in-binary-tree","timestamp":1698699700,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"44.5 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<Double> averageOfLevels(TreeNode root) {\n        List<TreeNode> layer = new ArrayList<>();\n        layer.add(root);\n        List<Double> re = new ArrayList<>();\n        while (layer.size()!=0){\n            re.add(avgList(layer));\n            layer = getChildList(layer);\n        }\n        return re;\n    }\n\n    public double avgList(List<TreeNode> layer){\n        double re = 0;\n        int count = 0;\n        for (TreeNode i: layer){\n            if (i!=null){\n                re = re + i.val;\n                count++;\n            }\n        }\n        re = (double) re / (double) count;\n        return re;\n    }\n    public List<TreeNode> getChildList(List<TreeNode> layer){\n        List<TreeNode> re= new ArrayList<>();\n        for (TreeNode i: layer){\n            if (i.left != null) re.add(i.left);\n            if (i.right != null) re.add(i.right);\n        }\n        return re;\n    }\n}","runtime":"1 ms","title":"Average of Levels in Binary Tree","url":"/submissions/detail/1087867142/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1087867142,"time":"2 months, 4 weeks","lang":"java","title_slug":"average-of-levels-in-binary-tree","timestamp":1698699611,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"40.6 MB","code":"class Solution {\n    public boolean isValid(String s) {\n        Stack<Character> open = new Stack<>();\n        \n        for (char i:s.toCharArray()){\n            if (i=='(' || i == '[' || i == '{') open.add(i);\n            if ((i==')' || i == ']' || i == '}') && (open.size() == 0)) return false;\n            if (i == ')' && open.peek()!='(') return false;\n            if (i == ']' && open.peek()!='[') return false;\n            if (i == '}' && open.peek()!='{') return false;\n            if (i==')' || i == ']' || i == '}') open.pop();\n        }\n        if (open.size() == 0) return true;\n        return false;\n    }\n}","runtime":"2 ms","title":"Valid Parentheses","url":"/submissions/detail/1087766779/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1087766779,"time":"2 months, 4 weeks","lang":"java","title_slug":"valid-parentheses","timestamp":1698689692,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"40.5 MB","code":"class Solution {\n    public boolean isValid(String s) {\n        Stack<Character> open = new Stack<>();\n        Stack<Character> close = new Stack<>();\n        \n        for (char i:s.toCharArray()){\n            if (i=='(' || i == '[' || i == '{') open.add(i);\n            if ((i==')' || i == ']' || i == '}') && (open.size() == 0)) return false;\n            if (i == ')' && open.peek()!='(') return false;\n            if (i == ']' && open.peek()!='[') return false;\n            if (i == '}' && open.peek()!='{') return false;\n            if (i==')' || i == ']' || i == '}') open.pop();\n        }\n        if (open.size() == 0) return true;\n        return false;\n    }\n}","runtime":"2 ms","title":"Valid Parentheses","url":"/submissions/detail/1087766603/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1087766603,"time":"2 months, 4 weeks","lang":"java","title_slug":"valid-parentheses","timestamp":1698689680,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Runtime Error","memory":"N/A","code":"class Solution {\n    public boolean isValid(String s) {\n        Stack<Character> open = new Stack<>();\n        Stack<Character> close = new Stack<>();\n        \n        for (char i:s.toCharArray()){\n            if (i=='(' || i == '[' || i == '{') open.add(i);\n            if (i == ')' && open.peek()!='(') return false;\n            if (i == ']' && open.peek()!='[') return false;\n            if (i == '}' && open.peek()!='{') return false;\n            if (i==')' || i == ']' || i == '}') open.pop();\n        }\n        if (open.size() == 0) return true;\n        return false;\n    }\n}","runtime":"N/A","title":"Valid Parentheses","url":"/submissions/detail/1087765175/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1087765175,"time":"2 months, 4 weeks","lang":"java","title_slug":"valid-parentheses","timestamp":1698689579,"status":15,"is_pending":"Not Pending","compare_result":"11111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public long minIncrementOperations(int[] nums, int k) {\n        int ind = 0;\n        int n = nums.length;\n        long re = 0;\n        while (ind+2<n){\n            long max = nums[ind];\n            int pos = ind;\n            for (int i = 1; i<=2;i++){\n                if (max<=nums[ind+i]){\n                    max= nums[ind+i];\n                    pos = ind + i ;\n                }\n            }\n            System.out.println(max);\n            if (max<k){\n                re = re + k - nums[pos];\n                nums[pos] = k;\n            }\n            ind++;\n        }\n        return re;\n    }\n}","runtime":"N/A","title":"Minimum Increment Operations to Make Array Beautiful","url":"/submissions/detail/1086524199/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1086524199,"time":"3 months","lang":"java","title_slug":"minimum-increment-operations-to-make-array-beautiful","timestamp":1698550697,"status":11,"is_pending":"Not Pending","compare_result":"111111111111111111111111110111111100000101111111111111111111110101011001111111111101110111111101111010111101111111001101010001000011111101000100101000001100001000010100100100100011101100001001110000101101100010100110010010000110100001000000000010001000010000000101000000000000001101110100000000000000001000000100001000000000010010000001001010011011100010101010001000010011000000000000111000000010000101001000010001000011001011010011000000001001000100001000001000100000000000100000000000000000000010000000000000000000000000000000000000000000001000010000111001111111100000"},{"status_display":"Accepted","memory":"43.4 MB","code":"class Solution {\n    public int findKOr(int[] nums, int k) {\n        int pow2 = 1;\n        if (k == nums.length) {\n            int re = nums[0];\n            for (int i :nums) re = re & i;\n            return re;\n        }\n        if (k == 1){\n            int re = nums[0];\n            for (int i :nums) re = re | i;\n            return re;\n        }\n        \n        int re = 0;\n        int exit = 0;\n        int n = nums.length;\n        while (exit<n){\n            int count = 0;\n            exit = 0;\n            for (int i = 0; i<nums.length; i++){\n                // System.out.print(nums[i] +\" \");\n                if (nums[i] == 0 ) exit++;\n\n                if (nums[i] != 0 && nums[i] %2 == 1 ){\n                    count++;\n                }\n                nums[i] = nums[i] / 2;\n                // if (count >= k) break;\n            }\n            // System.out.println();\n            // System.out.println(count);\n            if (count >= k) re = re+ pow2;\n            pow2 = pow2 * 2;\n        }\n        \n        return re;\n        \n    }\n}","runtime":"3 ms","title":"Find the K-or of an Array","url":"/submissions/detail/1086516435/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1086516435,"time":"3 months","lang":"java","title_slug":"find-the-k-or-of-an-array","timestamp":1698550187,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int findKOr(int[] nums, int k) {\n        int pow2 = 1;\n        if (k == nums.length) {\n            int re = nums[0];\n            for (int i :nums) re = re & i;\n            return re;\n        }\n        if (k == 1){\n            int re = nums[0];\n            for (int i :nums) re = re | i;\n            return re;\n        }\n        \n        int re = 0;\n        int exit = 0;\n        int n = nums.length;\n        while (exit<n){\n            int count = 0;\n            for (int i = 0; i<nums.length; i++){\n                // System.out.print(nums[i] +\" \");\n                if (nums[i] == 0 ) exit++;\n\n                if (nums[i] != 0 && nums[i] %2 == 1 ){\n                    count++;\n                }\n                nums[i] = nums[i] / 2;\n                // if (count >= k) break;\n            }\n            // System.out.println();\n            // System.out.println(count);\n            if (count >= k) re = re+ pow2;\n            pow2 = pow2 * 2;\n        }\n        \n        return re;\n        \n    }\n}","runtime":"N/A","title":"Find the K-or of an Array","url":"/submissions/detail/1086515061/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1086515061,"time":"3 months","lang":"java","title_slug":"find-the-k-or-of-an-array","timestamp":1698550098,"status":11,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111101111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110111111110111101111111111111111111111111111111111111111101111111111111111111111111111111110111111111110111111111111111111111111111111111111111111111111111111111111111111111111110111111111111111111111111111111111111111111111111111111111111111011110111111111111111111011111111111111111111111111111110111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110111111111111111111111111111111111111111111111111111111111111111010111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int findKOr(int[] nums, int k) {\n        int pow2 = 1;\n        if (k == nums.length) {\n            int re = nums[0];\n            for (int i :nums) re = re & i;\n            return re;\n        }\n        if (k == 1){\n            int re = nums[0];\n            for (int i :nums) re = re | i;\n            return re;\n        }\n        \n        int re = 0;\n        int exit = 0;\n        int n = nums.length;\n        while (exit<n){\n            int count = 0;\n            for (int i = 0; i<nums.length; i++){\n                if (nums[i] == 0 ) exit++;\n\n                if (nums[i] != 0 && nums[i] %2 == 1 ){\n                    count++;\n                }\n                nums[i] = nums[i] / 2;\n                if (count >= k) break;\n            }\n            // System.out.println(count);\n            if (count >= k) re = re+ pow2;\n            pow2 = pow2 * 2;\n        }\n        \n        return re;\n        \n    }\n}","runtime":"N/A","title":"Find the K-or of an Array","url":"/submissions/detail/1086512878/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1086512878,"time":"3 months","lang":"java","title_slug":"find-the-k-or-of-an-array","timestamp":1698549962,"status":11,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111101111010010101111010111111111111111111011111010111111101100011110111111101110010111111111111101111111010011111011110100010111111111110011101011101000101110111111111111111110110111011111011111001111110001000111111010111111111111111110001111110101110111111100111001111111001111111010111110110101100100000101111111001111000111111011110110110111011110110101101111110110111110101111101101111001111111011111011111000001110011101110111111011110101111010101001111011111101111010101101110111111111010110111101011000010111011010000010010000000000110100100111000100110100001000010001110111000100001101010011001111010101001000011110100001000010000001001010000101000010010010011100101010001110000010101010010100011101000000001011001000011001101100111011010000001111010100101001110101101010101000000000010011000001110010101101101100100100010010111000001101000101101011001101110010010000100010100010100000010101100111101100110"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int findKOr(int[] nums, int k) {\n        int pow2 = 1;\n        if (k == nums.length) {\n            int re = nums[0];\n            for (int i :nums) re = re & i;\n            return re;\n        }\n        if (k == 1){\n            int re = nums[0];\n            for (int i :nums) re = re | i;\n            return re;\n        }\n        \n        int re = 0;\n        int exit = 0;\n        int n = nums.length;\n        while (exit<n){\n            int count = 0;\n            for (int i = 0; i<nums.length; i++){\n                if (nums[i] == 0 ) exit++;\n\n                if (nums[i] %2 == 1){\n                    count++;\n                }\n                nums[i] = nums[i] / 2;\n                if (count >= k) break;\n            }\n            System.out.println(count);\n            if (count >= k) re = re+ pow2;\n            pow2 = pow2 * 2;\n        }\n        \n        return re;\n        \n    }\n}","runtime":"N/A","title":"Find the K-or of an Array","url":"/submissions/detail/1086509421/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1086509421,"time":"3 months","lang":"java","title_slug":"find-the-k-or-of-an-array","timestamp":1698549750,"status":11,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111101111010010101111010111111111111111111011111010111111101100011110111111101110010111111111111101111111010011111011110100010111111111110011101011101000101110111111111111111110110111011111011111001111110001000111111010111111111111111110001111110101110111111100111001111111001111111010111110110101100100000101111111001111000111111011110110110111011110110101101111110110111110101111101101111001111111011111011111000001110011101110111111011110101111010101001111011111101111010101101110111111111010110111101011000010111011010000010010000000000110100100111000100110100001000010001110111000100001101010011001111010101001000011110100001000010000001001010000101000010010010011100101010001110000010101010010100011101000000001011001000011001101100111011010000001111010100101001110101101010101000000000010011000001110010101101101100100100010010111000001101000101101011001101110010010000100010100010100000010101100111101100110"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int findKOr(int[] nums, int k) {\n        int pow2 = 1;\n        if (k == nums.length) {\n            int re = nums[0];\n            for (int i :nums) re = re & i;\n            return re;\n        }\n        if (k == 1){\n            int re = nums[0];\n            for (int i :nums) re = re | i;\n            return re;\n        }\n        \n        int re = 0;\n        int exit = 0;\n        int n = nums.length;\n        while (exit<n){\n            int count = 0;\n            for (int i = 0; i<nums.length; i++){\n                if (nums[i] %2 == 1){\n                    count++;\n                }\n                nums[i] = nums[i] /2;\n                if (nums[i] == 0 ) exit++;\n                if (count >= k) break;\n            } \n            if (count >= k) re = re+ pow2;\n            pow2 = pow2 * 2;\n        }\n        \n        return re;\n        \n    }\n}","runtime":"N/A","title":"Find the K-or of an Array","url":"/submissions/detail/1086505200/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1086505200,"time":"3 months","lang":"java","title_slug":"find-the-k-or-of-an-array","timestamp":1698549503,"status":11,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111010010111111010111111111111111111011111010111111101100011110111111101110010111111111111101111111010001111011110100010111111111110011101011101001101100111111111111111111110111011111011111001111110101000111111110111111111111111110001111110101110111111100101001111111011111111010111110110101100100000101011111101111010111111011111110110111011110110101101111110110111110101111101101111001111111011111111111010001110011101110111111011110101111010101011111011111101111010111101110111011111010110111101011000010111011010000010010000000000110100100111000100110100001000010001110111000100001111010011001111010101001000011110100001000010000001001010000101000010010010011100101010001110000011101010010100011101000000001011001000011001101100111011010000001111010100101001110101101010101000000000010011000001110010101101101100100100010010111000001101000101101011001101110010010000100010100010100000010101100111101100110"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public long minIncrementOperations(int[] nums, int k) {\n        int ind = 0;\n        int n = nums.length;\n        long re = 0;\n        while (ind+2<n){\n            long max = nums[ind];\n            int pos = ind;\n            for (int i = 1; i<=2;i++){\n                if (max<=nums[ind+i]){\n                    max= nums[ind+i];\n                    pos = ind + i ;\n                }\n            }\n            // System.out.println(max);\n            if (max<k){\n                re = re + k - nums[pos];\n                nums[pos] = k;\n            }\n            ind++;\n        }\n        return re;\n    }\n}","runtime":"N/A","title":"Minimum Increment Operations to Make Array Beautiful","url":"/submissions/detail/1086492941/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1086492941,"time":"3 months","lang":"java","title_slug":"minimum-increment-operations-to-make-array-beautiful","timestamp":1698548803,"status":11,"is_pending":"Not Pending","compare_result":"111111111111111111111111110111111100000101111111111111111111110101011001111111111101110111111101111010111101111111001101010001000011111101000100101000001100001000010100100100100011101100001001110000101101100010100110010010000110100001000000000010001000010000000101000000000000001101110100000000000000001000000100001000000000010010000001001010011011100010101010001000010011000000000000111000000010000101001000010001000011001011010011000000001001000100001000001000100000000000100000000000000000000010000000000000000000000000000000000000000000001000010000111001111111100000"}],"has_next":true,"last_key":"%7B%22pk%22%3A%20%7B%22N%22%3A%20%221086492941%22%7D%2C%20%22dt%22%3A%20%7B%22S%22%3A%20%222023-10-29T03%3A06%3A43.174541%2B0000%22%7D%2C%20%22sid%22%3A%20%7B%22N%22%3A%20%227573785%22%7D%7D"}
2024-01-26 23:01:52.095 [main] DEBUG submission_dump - {"submissions_dump":[{"status_display":"Accepted","memory":"59.1 MB","code":"class Solution {\n    public long minSum(int[] nums1, int[] nums2) {\n        long count1 = 0;\n        long count2 = 0;\n        long sum1 = 0;\n        long sum2 = 0;\n        for (int i: nums1){\n            sum1 = sum1+i;\n            if (i == 0 ) count1++;\n        }\n        for (int i: nums2){\n            sum2 = sum2+i;\n            if (i == 0 ) count2++;\n        }\n        if (count1 == 0 && count2 == 0 ){\n            if (sum1 == sum2) return sum1;\n            else return -1;\n        }\n        // System.out.println(sum1 + \" \"+ sum2 + \" \"+ count1+ \" \"+ count2);\n        if (sum1 > sum2 && count2 == 0 ) return -1;\n        if (sum1 < sum2 && count1 == 0 ) return -1;\n        if (sum1 + count1 > sum2 && count2 == 0 ) return -1;\n        if (sum1 < sum2 + count2 && count1 == 0 ) return -1;\n        return Long.max(sum1+count1,sum2+count2);\n        \n    }\n}","runtime":"3 ms","title":"Minimum Equal Sum of Two Arrays After Replacing Zeros","url":"/submissions/detail/1086478614/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1086478614,"time":"3 months","lang":"java","title_slug":"minimum-equal-sum-of-two-arrays-after-replacing-zeros","timestamp":1698548034,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public long minSum(int[] nums1, int[] nums2) {\n        int count1 = 0;\n        int count2 = 0;\n        int sum1 = 0;\n        int sum2 = 0;\n        for (int i: nums1){\n            sum1 = sum1+i;\n            if (i == 0 ) count1++;\n        }\n        for (int i: nums2){\n            sum2 = sum2+i;\n            if (i == 0 ) count2++;\n        }\n        if (count1 == 0 && count2 == 0 ){\n            if (sum1 == sum2) return sum1;\n            else return -1;\n        }\n        if (sum1 > sum2 && count2 == 0 ) return -1;\n        if (sum1 < sum2 && count1 == 0 ) return -1;\n        if (sum1 + count1 >= sum2 && count2 == 0 ) return -1;\n        if (sum1 <= sum2 + count2 && count1 == 0 ) return -1;\n        return Integer.max(sum1+count1,sum2+count2);\n        \n    }\n}","runtime":"N/A","title":"Minimum Equal Sum of Two Arrays After Replacing Zeros","url":"/submissions/detail/1086476316/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1086476316,"time":"3 months","lang":"java","title_slug":"minimum-equal-sum-of-two-arrays-after-replacing-zeros","timestamp":1698547909,"status":11,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public long minSum(int[] nums1, int[] nums2) {\n        int count1 = 0;\n        int count2 = 0;\n        int sum1 = 0;\n        int sum2 = 0;\n        for (int i: nums1){\n            sum1 = sum1+i;\n            if (i == 0 ) count1++;\n        }\n        for (int i: nums2){\n            sum2 = sum2+i;\n            if (i == 0 ) count2++;\n        }\n        if (count1 == 0 && count2 == 0 ){\n            if (sum1 == sum2) return sum1;\n            else return -1;\n        }\n        if (sum1 > sum2 && count2 == 0 ) return -1;\n        if (sum1 < sum2 && count1 == 0 ) return -1;\n        if (sum1 + count1 > sum2 && count2 == 0 ) return -1;\n        if (sum1 < sum2 + count2 && count1 == 0 ) return -1;\n        return Integer.max(sum1+count1,sum2+count2);\n        \n    }\n}","runtime":"N/A","title":"Minimum Equal Sum of Two Arrays After Replacing Zeros","url":"/submissions/detail/1086475884/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1086475884,"time":"3 months","lang":"java","title_slug":"minimum-equal-sum-of-two-arrays-after-replacing-zeros","timestamp":1698547884,"status":11,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public long minSum(int[] nums1, int[] nums2) {\n        int count1 = 0;\n        int count2 = 0;\n        int sum1 = 0;\n        int sum2 = 0;\n        for (int i: nums1){\n            sum1 = sum1+i;\n            if (i == 0 ) count1++;\n        }\n        for (int i: nums2){\n            sum2 = sum2+i;\n            if (i == 0 ) count2++;\n        }\n        if (count1 == 0 && count2 == 0 ){\n            if (sum1 == sum2) return sum1;\n            else return -1;\n        }\n        if (sum1 + count1 > sum2 && count2 == 0 ) return -1;\n        if (sum1 < sum2 + count2 && count1 == 0 ) return -1;\n        return Integer.max(sum1+count1,sum2+count2);\n        \n    }\n}","runtime":"N/A","title":"Minimum Equal Sum of Two Arrays After Replacing Zeros","url":"/submissions/detail/1086475421/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1086475421,"time":"3 months","lang":"java","title_slug":"minimum-equal-sum-of-two-arrays-after-replacing-zeros","timestamp":1698547860,"status":11,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000"},{"status_display":"Time Limit Exceeded","memory":"N/A","code":"class Solution {\n    public int findKOr(int[] nums, int k) {\n        int pow2 = 1;\n        if (k == nums.length) {\n            int re = nums[0];\n            for (int i :nums) re = re & i;\n            return re;\n        }\n        if (k == 1){\n            int re = nums[0];\n            for (int i :nums) re = re | i;\n            return re;\n        }\n        \n        int max = 0;\n        int re = 0;\n        for (int i : nums){\n            if (i>max) max = i;\n        }\n        while (pow2 < max){\n            int count = 0;\n            for (int i = 0; i<nums.length; i++){\n                if ( (pow2 & nums[i]) == pow2 ) count++;\n            } \n            if (count >= k) re = re+ pow2;\n            pow2 = pow2 * 2;\n        }\n        \n        return re;\n        \n    }\n}","runtime":"N/A","title":"Find the K-or of an Array","url":"/submissions/detail/1086466386/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1086466386,"time":"3 months","lang":"java","title_slug":"find-the-k-or-of-an-array","timestamp":1698547338,"status":14,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"},{"status_display":"Accepted","memory":"44.5 MB","code":"class Solution {\n    public int minChanges(String s) {\n        char [] ac = s.toCharArray();\n        int n = s.length();\n        int st = 0;\n        int count = 0;\n        while (st<n){\n            if (ac[st]!=ac[st+1]) count ++;\n            st+=2;\n        }\n        return count;\n        \n    }\n}","runtime":"3 ms","title":"Minimum Number of Changes to Make Binary String Beautiful","url":"/submissions/detail/1086107640/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1086107640,"time":"3 months","lang":"java","title_slug":"minimum-number-of-changes-to-make-binary-string-beautiful","timestamp":1698505320,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"44.1 MB","code":"class Solution {\n    public int sumCounts(List<Integer> nums) {\n        int n = nums.size();\n        List<Integer> dist = new ArrayList<>();\n        int sum = 0;\n        for (int i = 0 ; i<n;i++){\n\n            for (int j = 0;j<n;j++) {\n                HashSet<Integer> set = new HashSet<>();\n                if (i+j<n){\n                    for (int k =0;k<=i && j+k<n;k++){\n                    set.add(nums.get(j+k));\n                    }    \n                }\n                \n                // System.out.println(j +\" \"+i + \" \" + set.size());\n                sum = sum + set.size()*set.size();\n\n            }\n        }\n        return sum;\n        \n    }\n}","runtime":"105 ms","title":"Subarrays Distinct Element Sum of Squares I","url":"/submissions/detail/1086098064/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1086098064,"time":"3 months","lang":"java","title_slug":"subarrays-distinct-element-sum-of-squares-i","timestamp":1698504898,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"40.3 MB","code":"class Solution {\n    public boolean isHappy(int n) {\n        HashSet<Integer> set = new HashSet<>();\n        int temp = n;\n        set.add(temp);\n        if (n == 1) return true;\n        while (temp != 1){\n            // System.out.println(temp);\n            int h = happy(temp);\n            if (h == 1) return true;\n            if (set.contains(h)) return false;\n            set.add(h);\n            temp = h;\n        }\n        return true;\n\n        \n    }\n\n    public int happy(int n){\n        int temp = n;\n        int sum = 0;\n        while (temp>0){\n            int d = temp % 10;\n            sum = sum + d*d;\n            temp =temp / 10;\n        }\n        return sum;\n    }\n}","runtime":"1 ms","title":"Happy Number","url":"/submissions/detail/1085731173/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1085731173,"time":"3 months","lang":"java","title_slug":"happy-number","timestamp":1698456367,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"41.7 MB","code":"class Solution {\n    public String fractionToDecimal(long numerator, long denominator) {\n        String re = \"\";\n\n        if (numerator * denominator < 0) {\n            re = \"-\";\n            \n        }\n        numerator = Math.abs(numerator);\n        denominator = Math.abs(denominator);\n        long dec = numerator / denominator;\n        re = re+dec;\n\n        long remainder = numerator % denominator;\n        if (remainder < 0) remainder = -remainder;\n        List<Long> remains = new ArrayList<>();\n        List<Long> left = new ArrayList<>();\n        HashSet<Long> set = new HashSet<>();\n        set.add(remainder);\n        while (remainder != 0 || !set.contains(remainder)){\n            remains.add(remainder);\n            remainder = remainder * 10;\n            left.add(remainder/denominator);\n            remainder = remainder % denominator;\n            if (set.contains(remainder)) break;\n            set.add(remainder);\n        }\n        // System.out.println(remainder);\n        // for (int i  = 0;i<left.size();i++){\n        //     System.out.println(remains.get(i) + \" \" + left.get(i));\n        // }\n        if (remainder != 0){\n            if (remains.size()>0){\n                re = re+ \".\";\n                for (int i=0;i<remains.size();i++){\n                    if (remains.get(i).equals( remainder ) ){\n                        re = re+ \"(\" + left.get(i); \n                    }else{\n                        re = re+ left.get(i);\n                    }\n                }\n                re= re+\")\";\n            }\n        } else{\n            if (remains.size()>0) {\n                re = re+ \".\";\n                for (int i = 0;i<left.size();i++){\n                    re = re + left.get(i);\n                }\n            }\n        }\n        \n        return re;\n    }\n}","runtime":"13 ms","title":"Fraction to Recurring Decimal","url":"/submissions/detail/1085557251/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1085557251,"time":"3 months","lang":"java","title_slug":"fraction-to-recurring-decimal","timestamp":1698430554,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public String fractionToDecimal(int numerator, int denominator) {\n        String re = \"\";\n\n        if (numerator * denominator < 0) {\n            re = \"-\";\n            numerator = Math.abs(numerator);\n            denominator = Math.abs(denominator);\n        }\n        int dec = numerator / denominator;\n        re = re+dec;\n\n        int remainder = numerator % denominator;\n        if (remainder < 0) remainder = -remainder;\n        List<Integer> remains = new ArrayList<>();\n        List<Integer> left = new ArrayList<>();\n        HashSet<Integer> set = new HashSet<>();\n        set.add(remainder);\n        while (remainder != 0 || !set.contains(remainder)){\n            remains.add(remainder);\n            remainder = remainder * 10;\n            left.add(remainder/denominator);\n            remainder = remainder % denominator;\n            if (set.contains(remainder)) break;\n            set.add(remainder);\n        }\n        // System.out.println(remainder);\n        // for (int i  = 0;i<left.size();i++){\n        //     System.out.println(remains.get(i) + \" \" + left.get(i));\n        // }\n        if (remainder != 0){\n            if (remains.size()>0){\n                re = re+ \".\";\n                for (int i=0;i<remains.size();i++){\n                    if (remains.get(i).equals( remainder ) ){\n                        re = re+ \"(\" + left.get(i); \n                    }else{\n                        re = re+ left.get(i);\n                    }\n                }\n                re= re+\")\";\n            }\n        } else{\n            if (remains.size()>0) {\n                re = re+ \".\";\n                for (int i = 0;i<left.size();i++){\n                    re = re + left.get(i);\n                }\n            }\n        }\n        \n        return re;\n    }\n}","runtime":"N/A","title":"Fraction to Recurring Decimal","url":"/submissions/detail/1085555881/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1085555881,"time":"3 months","lang":"java","title_slug":"fraction-to-recurring-decimal","timestamp":1698430434,"status":11,"is_pending":"Not Pending","compare_result":"111111111111111111111111111110101000001"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public String fractionToDecimal(int numerator, int denominator) {\n        \n        int dec = numerator / denominator;\n        String re = \"\";\n        re = \"\"+dec;\n\n        int remainder = numerator % denominator;\n        if (remainder < 0) remainder = -remainder;\n        List<Integer> remains = new ArrayList<>();\n        List<Integer> left = new ArrayList<>();\n        HashSet<Integer> set = new HashSet<>();\n        set.add(remainder);\n        while (remainder != 0 || !set.contains(remainder)){\n            remains.add(remainder);\n            remainder = remainder * 10;\n            left.add(remainder/denominator);\n            remainder = remainder % denominator;\n            if (set.contains(remainder)) break;\n            set.add(remainder);\n        }\n        // System.out.println(remainder);\n        // for (int i  = 0;i<left.size();i++){\n        //     System.out.println(remains.get(i) + \" \" + left.get(i));\n        // }\n        if (remainder != 0){\n            if (remains.size()>0){\n                re = re+ \".\";\n                for (int i=0;i<remains.size();i++){\n                    if (remains.get(i).equals( remainder ) ){\n                        re = re+ \"(\" + left.get(i); \n                    }else{\n                        re = re+ left.get(i);\n                    }\n                }\n                re= re+\")\";\n            }\n        } else{\n            if (remains.size()>0) {\n                re = re+ \".\";\n                for (int i = 0;i<left.size();i++){\n                    re = re + left.get(i);\n                }\n            }\n        }\n        \n        return re;\n    }\n}","runtime":"N/A","title":"Fraction to Recurring Decimal","url":"/submissions/detail/1085553836/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1085553836,"time":"3 months","lang":"java","title_slug":"fraction-to-recurring-decimal","timestamp":1698430260,"status":11,"is_pending":"Not Pending","compare_result":"111111111111111111111111110110111100001"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public String fractionToDecimal(int numerator, int denominator) {\n        int dec = numerator / denominator;\n        int remainder = numerator % denominator;\n        List<Integer> remains = new ArrayList<>();\n        List<Integer> left = new ArrayList<>();\n        HashSet<Integer> set = new HashSet<>();\n        set.add(remainder);\n        while (remainder != 0 || !set.contains(remainder)){\n            remains.add(remainder);\n            remainder = remainder * 10;\n            left.add(remainder/denominator);\n            remainder = remainder % denominator;\n            if (set.contains(remainder)) break;\n            set.add(remainder);\n        }\n        System.out.println(remainder);\n        for (int i  = 0;i<left.size();i++){\n            System.out.println(remains.get(i) + \" \" + left.get(i));\n        }\n        String re = \"\"+dec;\n        if (remainder != 0){\n            if (remains.size()>0){\n                re = re+ \".\";\n                for (int i=0;i<remains.size();i++){\n                    if (remains.get(i).equals( remainder ) ){\n                        re = re+ \"(\" + left.get(i); \n                    }else{\n                        re = re+ left.get(i);\n                    }\n                }\n                re= re+\")\";\n            }\n        } else{\n            if (remains.size()>0) {\n                re = re+ \".\";\n                for (int i = 0;i<left.size();i++){\n                    re = re + left.get(i);\n                }\n            }\n        }\n        \n        return re;\n    }\n}","runtime":"N/A","title":"Fraction to Recurring Decimal","url":"/submissions/detail/1085552188/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1085552188,"time":"3 months","lang":"java","title_slug":"fraction-to-recurring-decimal","timestamp":1698430116,"status":11,"is_pending":"Not Pending","compare_result":"111111111111111111111111010110111101101"},{"status_display":"Accepted","memory":"44.5 MB","code":"class Solution {\n    public int[][] intervalIntersection(int[][] firstList, int[][] secondList) {\n        int n = firstList.length;\n        int m = secondList.length;\n        List<Integer> a = new ArrayList<>();\n        List<Integer> b = new ArrayList<>();\n        int c1 = 0;\n        int c2 = 0;\n        while (c1<n && c2<m){\n            if ( firstList[c1][0] <= secondList[c2][0] && secondList[c2][1] <= firstList[c1][1]) {\n                a.add(secondList[c2][0]);\n                b.add(secondList[c2][1]);\n                // c2++;\n            } else if ( secondList[c2][0] <= firstList[c1][0] && firstList[c1][1] <= secondList[c2][1] ){\n                a.add(firstList[c1][0]);\n                b.add(firstList[c1][1]);\n                // c1++;\n            } else if ( firstList[c1][0] <= secondList[c2][0] && secondList[c2][0] <= firstList[c1][1]) {\n                a.add(secondList[c2][0]);\n                b.add(firstList[c1][1]);\n                // c2++;\n            } else if ( secondList[c2][0] <= firstList[c1][0] && firstList[c1][0] <= secondList[c2][1] ){\n                a.add(firstList[c1][0]);\n                b.add(secondList[c2][1]);\n                // c1++;\n            }\n            \n            if (firstList[c1][1]<secondList[c2][1]){\n                c1++;\n            }\n            else{\n                c2++;\n            }\n                \n        }\n        int [][] re = new int[a.size()][2];\n        for (int i = 0;i<a.size();i++){\n            re[i][0] = a.get(i);\n            re[i][1] = b.get(i);\n        }\n        return re;\n        \n    }\n}","runtime":"6 ms","title":"Interval List Intersections","url":"/submissions/detail/1085524237/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1085524237,"time":"3 months","lang":"java","title_slug":"interval-list-intersections","timestamp":1698427769,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"44.9 MB","code":"class Solution {\n    public void setZeroes(int[][] matrix) {\n        int n = matrix.length;\n        int m = matrix[0].length;\n        boolean top = false;\n        boolean left = false;\n        for (int i = 0;i<n;i++){\n            for (int j = 0 ;j<m;j++){\n                if (matrix[i][j] == 0){\n                    if (i == 0) top = true;\n                    if (j == 0) left = true;\n                    matrix[i][0] = 0;\n                    matrix[0][j] = 0;\n                }\n            }\n        }\n        for (int i = 1;i<n;i++){\n            if (matrix[i][0] == 0)\n                for (int j = 0;j<m;j++) {\n                    matrix[i][j] = 0;\n                }\n        }\n        for (int i = 1;i<m;i++){\n            if (matrix[0][i] == 0)\n                for (int j = 0;j<n;j++) {\n                    matrix[j][i] = 0;\n                }\n        }\n        if (top){\n            // System.out.println(\"t\" + \" \"+m);\n            for (int i = 0;i<m;i++) matrix[0][i] = 0;\n        }\n        if (left){\n            // System.out.println(\"l\" );\n            for (int i = 0; i<n;i++) matrix[i][0] = 0;\n        }\n    }\n}","runtime":"1 ms","title":"Set Matrix Zeroes","url":"/submissions/detail/1085000221/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1085000221,"time":"3 months","lang":"java","title_slug":"set-matrix-zeroes","timestamp":1698368279,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public void setZeroes(int[][] matrix) {\n        int n = matrix.length;\n        int m = matrix[0].length;\n        boolean top = false;\n        boolean left = false;\n        for (int i = 0;i<n;i++){\n            for (int j = 0 ;j<m;j++){\n                if (matrix[i][j] == 0){\n                    if (i == 0) left = true;\n                    if (j == 0) top = true;\n                    matrix[i][0] = 0;\n                    matrix[0][j] = 0;\n                }\n            }\n        }\n        for (int i = 1;i<n;i++){\n            if (matrix[i][0] == 0)\n                for (int j = 0;j<m;j++) {\n                    matrix[i][j] = 0;\n                }\n        }\n        for (int i = 1;i<m;i++){\n            if (matrix[0][i] == 0)\n                for (int j = 0;j<n;j++) {\n                    matrix[j][i] = 0;\n                }\n        }\n        if (top){\n            for (int i = 0;i<m;i++) matrix[0][i] = 0;\n        }\n        if (left){\n            for (int i = 0; i<n;i++) matrix[i][0] = 0;\n        }\n    }\n}","runtime":"N/A","title":"Set Matrix Zeroes","url":"/submissions/detail/1084998746/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1084998746,"time":"3 months","lang":"java","title_slug":"set-matrix-zeroes","timestamp":1698368039,"status":11,"is_pending":"Not Pending","compare_result":"1111111100001111111010100111110000001000010011100000100011010010100111001000110101011111001010010110101101001010011000111001011101111111111111011111111010100100100111111101111"},{"status_display":"Accepted","memory":"38.9 MB","code":"class Solution {\n    public int fib(int n) {\n        if (n ==0 ) return 0;\n        if (n == 1) return 1;\n        if (n == 2) return 1;\n        int count = 2;\n        int a = 1;\n        int b = 1;\n        int c = 0;\n        while (count <n){\n            c = a+ b;\n            a= b;\n            b =c; \n            count ++;\n        }\n        return c;\n    }\n}","runtime":"0 ms","title":"Fibonacci Number","url":"/submissions/detail/1084979166/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1084979166,"time":"3 months","lang":"java","title_slug":"fibonacci-number","timestamp":1698364829,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111"},{"status_display":"Accepted","memory":"58.4 MB","code":"class Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n\t\tDeque<Integer> dNum = new ArrayDeque<Integer>();\n\t\tDeque<Integer> dInd = new ArrayDeque<Integer>();\n\t\tint n = nums.length;\n\t\tdNum.addLast(nums[0]);\n\t\tdInd.addLast(0);\n\t\tList<Integer> reL = new ArrayList<>();\n\n\t\tint count = 1;\n\t\tif (count >= k)\n\t\t\t\treL.add(dNum.getFirst());\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tint lowBound = i - (k - 1);\n\t\t\twhile (!dInd.isEmpty() && dInd.peekFirst() < lowBound) {\n\t\t\t\tdInd.removeFirst();\n\t\t\t\tdNum.removeFirst();\n\t\t\t}\n\t\t\tif (dNum.isEmpty()){\n\t\t\t\tdNum.addLast(nums[i]);\n\t\t\t\tdInd.addLast(i);\n\t\t\t}\n\t\t\telse {\n\t\t\t\twhile (!dNum.isEmpty() && dNum.getLast()<=nums[i]) {\n\t\t\t\t\tdNum.removeLast();\n\t\t\t\t\tdInd.removeLast();\n\t\t\t}\n\t\t\tdNum.addLast(nums[i]);\n\t\t\tdInd.addLast(i);\n\t\t\t}\n\t\t\t\n\t\t\tcount++;\n\t\t\tif (count >= k)\n\t\t\t\treL.add(dNum.getFirst());\n\t\t}\n\t\tint[] re = new int[reL.size()];\n\t\tfor (int i = 0; i < reL.size(); i++) {\n\t\t\tre[i] = reL.get(i);\n\t\t}\n\t\treturn re;\n\t}\n}","runtime":"48 ms","title":"Sliding Window Maximum","url":"/submissions/detail/1084946940/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1084946940,"time":"3 months","lang":"java","title_slug":"sliding-window-maximum","timestamp":1698359502,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n\t\tDeque<Integer> dNum = new ArrayDeque<Integer>();\n\t\tDeque<Integer> dInd = new ArrayDeque<Integer>();\n\t\tint n = nums.length;\n\t\tdNum.addLast(nums[0]);\n\t\tdInd.addLast(0);\n\t\tList<Integer> reL = new ArrayList<>();\n\n\t\tint count = 1;\n\t\tif (count >= k)\n\t\t\t\treL.add(dNum.getFirst());\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tint lowBound = i - (k - 1);\n\t\t\twhile (!dInd.isEmpty() && dInd.peekFirst() < lowBound) {\n\t\t\t\tdInd.removeFirst();\n\t\t\t\tdNum.removeFirst();\n\t\t\t}\n\t\t\tif (dNum.isEmpty()){\n\t\t\t\tdNum.addFirst(nums[i]);\n\t\t\t\tdInd.addFirst(i);\n\t\t\t} else if (nums[i] >= dNum.getFirst()) {\n\t\t\t\tdNum.addFirst(nums[i]);\n\t\t\t\tdInd.addFirst(i);\n\t\t\t} else {\n\t\t\t\tdNum.addLast(nums[i]);\n\t\t\t\tdInd.addLast(i);\n\t\t\t}\n\t\t\tcount++;\n\t\t\tif (count >= k)\n\t\t\t\treL.add(dNum.getFirst());\n\t\t}\n\t\tint[] re = new int[reL.size()];\n\t\tfor (int i = 0; i < reL.size(); i++) {\n\t\t\tre[i] = reL.get(i);\n\t\t}\n\t\treturn re;\n\t}\n}","runtime":"N/A","title":"Sliding Window Maximum","url":"/submissions/detail/1084922241/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1084922241,"time":"3 months","lang":"java","title_slug":"sliding-window-maximum","timestamp":1698355946,"status":11,"is_pending":"Not Pending","compare_result":"111111111101000010011000001101100010010101000111111"},{"status_display":"Runtime Error","memory":"N/A","code":"class Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n\t\tDeque<Integer> dNum = new ArrayDeque<Integer>();\n\t\tDeque<Integer> dInd = new ArrayDeque<Integer>();\n\t\tint n = nums.length;\n\t\tdNum.addLast(nums[0]);\n\t\tdInd.addLast(0);\n\t\tList<Integer> reL = new ArrayList<>();\n\n\t\tint count = 1;\n\t\tif (count >= k)\n\t\t\t\treL.add(dNum.getFirst());\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tint lowBound = i - (k - 1);\n\t\t\twhile (!dInd.isEmpty() && dInd.peekFirst() < lowBound) {\n\t\t\t\tdInd.removeFirst();\n\t\t\t\tdNum.removeFirst();\n\t\t\t}\n\t\t\tif (nums[i] >= dNum.getFirst()) {\n\t\t\t\tdNum.addFirst(nums[i]);\n\t\t\t\tdInd.addFirst(i);\n\t\t\t} else {\n\t\t\t\tdNum.addLast(nums[i]);\n\t\t\t\tdInd.addLast(i);\n\t\t\t}\n\t\t\tcount++;\n\t\t\tif (count >= k)\n\t\t\t\treL.add(dNum.getFirst());\n\t\t}\n\t\tint[] re = new int[reL.size()];\n\t\tfor (int i = 0; i < reL.size(); i++) {\n\t\t\tre[i] = reL.get(i);\n\t\t}\n\t\treturn re;\n\t}\n}","runtime":"N/A","title":"Sliding Window Maximum","url":"/submissions/detail/1084921574/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1084921574,"time":"3 months","lang":"java","title_slug":"sliding-window-maximum","timestamp":1698355852,"status":15,"is_pending":"Not Pending","compare_result":"110000000000000000000000000000000000000000000000000"},{"status_display":"Runtime Error","memory":"N/A","code":"class Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n\t\tDeque<Integer> dNum = new ArrayDeque<Integer>();\n\t\tDeque<Integer> dInd = new ArrayDeque<Integer>();\n\t\tint n = nums.length;\n\t\tdNum.addLast(nums[0]);\n\t\tdInd.addLast(0);\n\t\tList<Integer> reL = new ArrayList<>();\n\n\t\tint count = 1;\n\t\tif (count >= k)\n\t\t\t\treL.add(dNum.getFirst());\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tint lowBound = i - (k - 1);\n\t\t\twhile (dInd.peekFirst() < lowBound) {\n\t\t\t\tdInd.removeFirst();\n\t\t\t\tdNum.removeFirst();\n\t\t\t}\n\t\t\tif (nums[i] >= dNum.getFirst()) {\n\t\t\t\tdNum.addFirst(nums[i]);\n\t\t\t\tdInd.addFirst(i);\n\t\t\t} else {\n\t\t\t\tdNum.addLast(nums[i]);\n\t\t\t\tdInd.addLast(i);\n\t\t\t}\n\t\t\tcount++;\n\t\t\tif (count >= k)\n\t\t\t\treL.add(dNum.getFirst());\n\t\t}\n\t\tint[] re = new int[reL.size()];\n\t\tfor (int i = 0; i < reL.size(); i++) {\n\t\t\tre[i] = reL.get(i);\n\t\t}\n\t\treturn re;\n\t}\n}","runtime":"N/A","title":"Sliding Window Maximum","url":"/submissions/detail/1084921213/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1084921213,"time":"3 months","lang":"java","title_slug":"sliding-window-maximum","timestamp":1698355804,"status":15,"is_pending":"Not Pending","compare_result":"110000000000000000000000000000000000000000000000000"}],"has_next":true,"last_key":"%7B%22pk%22%3A%20%7B%22N%22%3A%20%221084921213%22%7D%2C%20%22dt%22%3A%20%7B%22S%22%3A%20%222023-10-26T21%3A30%3A04.267464%2B0000%22%7D%2C%20%22sid%22%3A%20%7B%22N%22%3A%20%227573785%22%7D%7D"}
2024-01-26 23:02:03.113 [main] DEBUG submission_dump - {"submissions_dump":[{"status_display":"Accepted","memory":"48.6 MB","code":"class Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        ArrayList<List<String>> re = new ArrayList<>();\n        HashMap<String,List<String>> m = new HashMap<>();\n        for (String s: strs){\n            char [] ca = s.toCharArray();\n            Arrays.sort(ca);\n            String k = new String(ca);\n            if (m.containsKey(k)){\n                m.get(k).add(s);\n            } else{\n                m.put(k,new ArrayList<>());\n                m.get(k).add(s);\n            }\n        }\n        for (String s: m.keySet()){\n            ArrayList<String> temp = new ArrayList<>();\n\n            for (String si:m.get(s)){\n                temp.add(si);\n            }\n            re.add(temp);\n        }\n\n        return re;\n        \n    }\n}","runtime":"7 ms","title":"Group Anagrams","url":"/submissions/detail/1084798338/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1084798338,"time":"3 months","lang":"java","title_slug":"group-anagrams","timestamp":1698343457,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"43.9 MB","code":"class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        HashMap<Integer,Integer> m = new HashMap<>();\n        int [] re = new int [2];\n        for (int i=0;i<nums.length;i++){\n            if (m.containsKey(target-nums[i])){\n                re[0] = i;\n                re[1] = m.get(target-nums[i]);\n            } else{\n                m.put(nums[i],i);\n            }\n        }\n        return re;\n        \n    }\n}","runtime":"4 ms","title":"Two Sum","url":"/submissions/detail/1084749903/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1084749903,"time":"3 months","lang":"java","title_slug":"two-sum","timestamp":1698339743,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public boolean isAnagram(String s, String t) {\n        HashMap<Character,Integer> as = new HashMap<>();\n        for (Character c:s.toCharArray()){\n            as.put(c,as.getOrDefault(c,0)+1);\n        }\n\n        HashMap<Character,Integer> at = new HashMap<>();\n        for (Character c:t.toCharArray()){\n            at.put(c,at.getOrDefault(c,0)+1);\n        }\n\n        for (Character c:as.keySet()){\n            if (!at.containsKey(c)) return false;\n            if (as.get(c)!=at.get(c)) return false;\n        }\n        for (Character c:at.keySet()){\n            if (!as.containsKey(c)) return false;\n            // if (as.get(c)!=at.get(c)) return false;\n        }\n        return true;\n        \n    }\n}","runtime":"N/A","title":"Valid Anagram","url":"/submissions/detail/1084298057/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1084298057,"time":"3 months","lang":"java","title_slug":"valid-anagram","timestamp":1698291395,"status":11,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111110111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public boolean isAnagram(String s, String t) {\n        HashMap<Character,Integer> as = new HashMap<>();\n        for (Character c:s.toCharArray()){\n            as.put(c,as.getOrDefault(c,0)+1);\n        }\n\n        HashMap<Character,Integer> at = new HashMap<>();\n        for (Character c:t.toCharArray()){\n            at.put(c,at.getOrDefault(c,0)+1);\n        }\n\n        for (Character c:as.keySet()){\n            if (!at.containsKey(c)) return false;\n            // if (as.get(c)!=at.get(c)) return false;\n        }\n        for (Character c:at.keySet()){\n            if (!as.containsKey(c)) return false;\n            // if (as.get(c)!=at.get(c)) return false;\n        }\n        return true;\n        \n    }\n}","runtime":"N/A","title":"Valid Anagram","url":"/submissions/detail/1084297942/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1084297942,"time":"3 months","lang":"java","title_slug":"valid-anagram","timestamp":1698291384,"status":11,"is_pending":"Not Pending","compare_result":"111111110111101110111110111111101010011111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public boolean isAnagram(String s, String t) {\n        HashMap<Character,Integer> as = new HashMap<>();\n        for (Character c:s.toCharArray()){\n            as.put(c,as.getOrDefault(c,0)+1);\n        }\n\n        HashMap<Character,Integer> at = new HashMap<>();\n        for (Character c:t.toCharArray()){\n            at.put(c,at.getOrDefault(c,0)+1);\n        }\n\n        for (Character c:as.keySet()){\n            if (!at.containsKey(c)) return false;\n            if (as.get(c)!=at.get(c)) return false;\n        }\n        for (Character c:at.keySet()){\n            if (!as.containsKey(c)) return false;\n            if (as.get(c)!=at.get(c)) return false;\n        }\n        return true;\n        \n    }\n}","runtime":"N/A","title":"Valid Anagram","url":"/submissions/detail/1084297176/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1084297176,"time":"3 months","lang":"java","title_slug":"valid-anagram","timestamp":1698291295,"status":11,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111110111111111"},{"status_display":"Accepted","memory":"40.6 MB","code":"class Solution {\n    public boolean wordPattern(String pattern, String s) {\n        HashMap<Character,String> m = new HashMap<>();\n        HashMap<String,Character> m2 = new HashMap<>();\n\n        String[] a = s.split(\"\\\\s+\");\n        char [] c = pattern.toCharArray();\n        int n = pattern.length();\n        if (n!=a.length) return false;\n        for (int i=0;i<n;i++){\n            if (m.containsKey(c[i])){\n                if (!m.get(c[i]).equals(a[i])) return false;\n            } else{\n                m.put(c[i],a[i]);\n            }\n\n            if (m2.containsKey(a[i])){\n                if (!m2.get(a[i]).equals(c[i])) return false;\n            } else{\n                m2.put(a[i],c[i]);\n            }\n        }        \n        return true;\n    }\n}","runtime":"2 ms","title":"Word Pattern","url":"/submissions/detail/1084295700/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1084295700,"time":"3 months","lang":"java","title_slug":"word-pattern","timestamp":1698291127,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public boolean wordPattern(String pattern, String s) {\n        HashMap<Character,String> m = new HashMap<>();\n        String[] a = s.split(\"\\\\s+\");\n        char [] c = pattern.toCharArray();\n        int n = pattern.length();\n        if (n!=a.length) return false;\n        for (int i=0;i<n;i++){\n            if (m.containsKey(c[i])){\n                if (!m.get(c[i]).equals(a[i])) return false;\n            } else{\n                m.put(c[i],a[i]);\n            }\n        }        \n        return true;\n    }\n}","runtime":"N/A","title":"Word Pattern","url":"/submissions/detail/1084294936/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1084294936,"time":"3 months","lang":"java","title_slug":"word-pattern","timestamp":1698291044,"status":11,"is_pending":"Not Pending","compare_result":"111011110111110111111111111111111111111111"},{"status_display":"Accepted","memory":"42 MB","code":"class Solution {\n    public boolean isIsomorphic(String s, String t) {\n        if (s.length()!=t.length()) return false;\n        HashMap<Character,Character> m = new HashMap<>();\n        HashMap<Character,Character> m2 = new HashMap<>();\n\n        char[] cs = s.toCharArray();\n        char[] ct = t.toCharArray();\n        int n = s.length();\n        for (int i=0;i<n;i++){\n            if (m.containsKey(cs[i])){\n                if (!m.get(cs[i]).equals(ct[i])) return false;\n            }else{\n                m.put(cs[i],ct[i]);\n            }\n            if (m2.containsKey(ct[i])){\n                if (!m2.get(ct[i]).equals(cs[i])) return false;\n            }else{\n                m2.put(ct[i],cs[i]);\n            }\n\n        }\n        return true;\n    }\n}","runtime":"16 ms","title":"Isomorphic Strings","url":"/submissions/detail/1084292758/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1084292758,"time":"3 months","lang":"java","title_slug":"isomorphic-strings","timestamp":1698290786,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public boolean isIsomorphic(String s, String t) {\n        if (s.length()!=t.length()) return false;\n        HashMap<Character,Character> m = new HashMap<>();\n        char[] cs = s.toCharArray();\n        char[] ct = t.toCharArray();\n        int n = s.length();\n        for (int i=0;i<n;i++){\n            if (m.containsKey(cs[i])){\n                if (!m.get(cs[i]).equals(ct[i])) return false;\n            }else{\n                m.put(cs[i],ct[i]);\n            }\n\n        }\n        return true;\n    }\n}","runtime":"N/A","title":"Isomorphic Strings","url":"/submissions/detail/1084291482/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1084291482,"time":"3 months","lang":"java","title_slug":"isomorphic-strings","timestamp":1698290631,"status":11,"is_pending":"Not Pending","compare_result":"1111110111101101110111011111110110111111111100"},{"status_display":"Accepted","memory":"43.9 MB","code":"class Solution {\n    public boolean canConstruct(String ransomNote, String magazine) {\n        HashMap<Character,Integer> ra = new HashMap<>();\n        for (Character c:ransomNote.toCharArray()){\n            ra.put(c,ra.getOrDefault(c,0)+1);\n        }\n\n        HashMap<Character,Integer> ma = new HashMap<>();\n        for (Character c:magazine.toCharArray()){\n            ma.put(c,ma.getOrDefault(c,0)+1);\n        }\n\n        for (Character c:ra.keySet()){\n            if (!ma.containsKey(c)) return false;\n            if (ra.get(c)>ma.get(c)) return false;\n        }\n        return true;\n    }\n}","runtime":"14 ms","title":"Ransom Note","url":"/submissions/detail/1084289052/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1084289052,"time":"3 months","lang":"java","title_slug":"ransom-note","timestamp":1698290345,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"41.4 MB","code":"class Solution {\n    public void rotate(int[][] matrix) {\n        transpose(matrix);\n        for (int i = 0;i<matrix.length;i++){\n            inv(matrix[i]);\n        }\n        return ;\n    }\n    void inv(int [] a){\n        int s = 0;\n        int e = a.length-1;\n        while (s<e){\n            int temp = a[s];\n            a[s] = a[e];\n            a[e] = temp;\n            s++;\n            e--;\n        }\n    }\n\n    void transpose(int [][] a){\n        int n = a.length;\n        int m = a[0].length;\n        for (int i = 0; i<n;i++){\n            for (int j =i+1;j<m;j++){\n                int temp = a[i][j];\n                a[i][j] = a[j][i];\n                a[j][i] = temp;\n            }\n        }\n    }\n}","runtime":"0 ms","title":"Rotate Image","url":"/submissions/detail/1084147147/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1084147147,"time":"3 months","lang":"java","title_slug":"rotate-image","timestamp":1698269660,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111"},{"status_display":"Accepted","memory":"41.8 MB","code":"class Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        int n = matrix.length;\n        int m = matrix[0].length;\n\n        boolean [][] check = new boolean[n][m];\n        // Arrays.fill(check,false);\n        ArrayList<Integer> re = new ArrayList<>();\n        move(re,0,matrix,check,0,0,n*m);\n        System.gc();\n        return re;\n        \n    }\n\n    void move(List<Integer> re, int dir, int[][] matrix, boolean[][] check, int x, int y,int total){\n        if (re.size() == total ) return;\n        if (x>= matrix.length) return;\n        if (y>= matrix[0].length) return;\n        if (check[x][y]) return;\n        // System.out.println(x+\" \"+ y + \" \"+ dir);\n        re.add(matrix[x][y]);\n        check[x][y] = true;\n        if (dir == 0){\n            if ( y+1<matrix[0].length && !check[x][y+1]){\n                move(re,dir,matrix,check,x,y+1, total);\n            } else{\n                move(re,1,matrix,check,x+1,y,total);\n            }\n        } else if (dir == 1){\n            if (x+1<matrix.length && !check[x+1][y])\n                move(re,dir,matrix,check,x+1,y,total);\n            else\n                move(re,2,matrix,check,x,y-1,total);\n        } else if (dir == 2) {\n            if ( y-1 >=0 && !check[x][y-1])\n                move(re,dir,matrix,check,x,y-1,total);\n            else \n                move(re,3,matrix,check,x-1,y,total);\n        } else if (dir == 3){\n            if (x-1>=0 && !check[x-1][y])\n                move(re,dir,matrix,check,x-1,y,total);\n            else\n                move(re,0,matrix,check,x,y+1,total);\n        }\n        return;\n    }\n}","runtime":"0 ms","title":"Spiral Matrix","url":"/submissions/detail/1084143015/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1084143015,"time":"3 months","lang":"java","title_slug":"spiral-matrix","timestamp":1698269127,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111"},{"status_display":"Accepted","memory":"42 MB","code":"class Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        int n = matrix.length;\n        int m = matrix[0].length;\n\n        boolean [][] check = new boolean[n][m];\n        // Arrays.fill(check,false);\n        ArrayList<Integer> re = new ArrayList<>();\n        move(re,0,matrix,check,0,0,n*m);\n        System.gc();\n        return re;\n        \n    }\n\n    void move(List<Integer> re, int dir, int[][] matrix, boolean[][] check, int x, int y,int total){\n        if (re.size() == total ) return;\n        if (x>= matrix.length) return;\n        if (y>= matrix[0].length) return;\n        if (check[x][y]) return;\n        // System.out.println(x+\" \"+ y + \" \"+ dir);\n        re.add(matrix[x][y]);\n        check[x][y] = true;\n        if (dir == 0){\n            if ( y+1<matrix[0].length && !check[x][y+1]){\n                move(re,dir,matrix,check,x,y+1, total);\n            } else{\n                move(re,1,matrix,check,x+1,y,total);\n            }\n        } else if (dir == 1){\n            if (x+1<matrix.length && !check[x+1][y])\n                move(re,dir,matrix,check,x+1,y,total);\n            else\n                move(re,2,matrix,check,x,y-1,total);\n        } else if (dir == 2) {\n            if ( y-1 >=0 && !check[x][y-1])\n                move(re,dir,matrix,check,x,y-1,total);\n            else \n                move(re,3,matrix,check,x-1,y,total);\n        } else if (dir == 3){\n            if (x-1>=0 && !check[x-1][y])\n                move(re,dir,matrix,check,x-1,y,total);\n            else\n                move(re,0,matrix,check,x,y+1,total);\n        }\n        return;\n    }\n}","runtime":"0 ms","title":"Spiral Matrix","url":"/submissions/detail/1084142947/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1084142947,"time":"3 months","lang":"java","title_slug":"spiral-matrix","timestamp":1698269118,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111"},{"status_display":"Accepted","memory":"41.8 MB","code":"class Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        int n = matrix.length;\n        int m = matrix[0].length;\n\n        boolean [][] check = new boolean[n][m];\n        // Arrays.fill(check,false);\n        ArrayList<Integer> re = new ArrayList<>();\n        move(re,0,matrix,check,0,0,n*m);\n        System.gc();\n        return re;\n        \n    }\n\n    void move(List<Integer> re, int dir, int[][] matrix, boolean[][] check, int x, int y,int total){\n        if (re.size() == total ) return;\n        if (x>= matrix.length) return;\n        if (y>= matrix[0].length) return;\n        if (check[x][y]) return;\n        // System.out.println(x+\" \"+ y + \" \"+ dir);\n        re.add(matrix[x][y]);\n        check[x][y] = true;\n        if (dir == 0){\n            if ( y+1<matrix[0].length && !check[x][y+1]){\n                move(re,dir,matrix,check,x,y+1, total);\n            } else{\n                move(re,1,matrix,check,x+1,y,total);\n            }\n        } else if (dir == 1){\n            if (x+1<matrix.length && !check[x+1][y])\n                move(re,dir,matrix,check,x+1,y,total);\n            else\n                move(re,2,matrix,check,x,y-1,total);\n        } else if (dir == 2) {\n            if ( y-1 >=0 && !check[x][y-1])\n                move(re,dir,matrix,check,x,y-1,total);\n            else \n                move(re,3,matrix,check,x-1,y,total);\n        } else if (dir == 3){\n            if (x-1>=0 && !check[x-1][y])\n                move(re,dir,matrix,check,x-1,y,total);\n            else\n                move(re,0,matrix,check,x,y+1,total);\n        }\n        return;\n    }\n}","runtime":"0 ms","title":"Spiral Matrix","url":"/submissions/detail/1084142883/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1084142883,"time":"3 months","lang":"java","title_slug":"spiral-matrix","timestamp":1698269111,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111"},{"status_display":"Accepted","memory":"40.6 MB","code":"class Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        int n = matrix.length;\n        int m = matrix[0].length;\n\n        boolean [][] check = new boolean[n][m];\n        // Arrays.fill(check,false);\n        ArrayList<Integer> re = new ArrayList<>();\n        move(re,0,matrix,check,0,0,n*m);\n        return re;\n        \n    }\n\n    void move(List<Integer> re, int dir, int[][] matrix, boolean[][] check, int x, int y,int total){\n        if (re.size() == total ) return;\n        if (x>= matrix.length) return;\n        if (y>= matrix[0].length) return;\n        if (check[x][y]) return;\n        // System.out.println(x+\" \"+ y + \" \"+ dir);\n        re.add(matrix[x][y]);\n        check[x][y] = true;\n        if (dir == 0){\n            if ( y+1<matrix[0].length && !check[x][y+1]){\n                move(re,dir,matrix,check,x,y+1, total);\n            } else{\n                move(re,1,matrix,check,x+1,y,total);\n            }\n        } else if (dir == 1){\n            if (x+1<matrix.length && !check[x+1][y])\n                move(re,dir,matrix,check,x+1,y,total);\n            else\n                move(re,2,matrix,check,x,y-1,total);\n        } else if (dir == 2) {\n            if ( y-1 >=0 && !check[x][y-1])\n                move(re,dir,matrix,check,x,y-1,total);\n            else \n                move(re,3,matrix,check,x-1,y,total);\n        } else if (dir == 3){\n            if (x-1>=0 && !check[x-1][y])\n                move(re,dir,matrix,check,x-1,y,total);\n            else\n                move(re,0,matrix,check,x,y+1,total);\n        }\n        return;\n    }\n}","runtime":"0 ms","title":"Spiral Matrix","url":"/submissions/detail/1084142459/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1084142459,"time":"3 months","lang":"java","title_slug":"spiral-matrix","timestamp":1698269059,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111"},{"status_display":"Accepted","memory":"43.3 MB","code":"class Solution {\n    public boolean isValidSudoku(char[][] board) {\n        int n = board.length;\n        int m = board[0].length;\n        for (int i  = 0;i<n;i++){\n            HashSet<Character> set = new HashSet<>();\n            for (int j = 0;j<m;j++){\n                if (board[i][j]!='.'){\n                    if (set.contains(board[i][j])) return false;\n                    else set.add(board[i][j]);\n                }\n            }\n        }\n        \n        for (int i  = 0;i<m;i++){\n            HashSet<Character> set = new HashSet<>();\n            for (int j = 0;j<n;j++){\n                if (board[j][i]!='.'){\n                    if (set.contains(board[j][i])) return false;\n                    else set.add(board[j][i]);\n                }\n            }\n        }\n\n        for (int i = 0;i<n;i+=3){\n            for (int j = 0;j<m;j+=3){\n                HashSet<Character> set = new HashSet<>();\n                for (int x = 0;x<3;x++){\n                    for (int y = 0;y<3;y++){\n                        char temp = board[i+x][j+y];\n                        if (temp!='.') {\n                            if (set.contains(temp)) return false;\n                            else set.add(temp);\n                        }\n                        \n                    }\n                }\n            }\n        }\n        return true;\n    }\n}","runtime":"2 ms","title":"Valid Sudoku","url":"/submissions/detail/1084082607/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1084082607,"time":"3 months","lang":"java","title_slug":"valid-sudoku","timestamp":1698262455,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"43.9 MB","code":"class Solution {\n    public String minWindow(String s, String t) {\n        HashMap<Character, Integer> m = new HashMap<>();\n        HashMap<Character, Integer> tracker = new HashMap<>();\n\n        for (Character c: t.toCharArray()){\n            m.put(c,m.getOrDefault(c,0)+1);\n            tracker.put(c,0);\n        }\n        int l = 0;\n        int r = 0;\n        int count = 0;\n        int n = s.length();\n        char [] ch = s.toCharArray();\n        int min = Integer.MAX_VALUE;\n        int min_l = -1;\n        int min_r = -1;\n        // HashSet<Integer> test = new HashSet<>();\n        while (r<n){\n                                // System.out.println(l +\" \" + r +\" \" + count);\n\n            if ( tracker.containsKey( ch[r] ) ){\n                tracker.put(ch[r], tracker.get(ch[r])+1);\n                if (tracker.get(ch[r]).equals(m.get(ch[r]))){\n                    count ++;\n                }\n            }\n            // if (!test.contains(count)){\n            //     System.out.println(count + \" \"+ m.keySet().size());;\n            //     test.add(count);\n            // }\n                \n\n            if (count == m.keySet().size()){\n                \n                while (count == m.keySet().size()){\n                    if (l>=n) break;\n\n                    int dist = r - l + 1;\n                    if (dist<min) {\n                        min = dist;\n                        min_l = l;\n                        min_r = r;\n                    }\n                      \n                    if (tracker.containsKey(ch[l])){\n                        tracker.put(ch[l],tracker.get(ch[l])-1 );\n                        if (tracker.get(ch[l])<m.get(ch[l] ) ) count --;\n\n                    }\n                    l++;\n                }\n            }\n            r++;\n        }\n\n\n        if (min==Integer.MAX_VALUE) return \"\";\n        StringBuilder re = new StringBuilder();\n        for (int i = min_l; i<=min_r;i++){\n            re.append(ch[i]);\n        }\n        return re.toString();\n\n    }\n}\n// ADOBECODEBANC","runtime":"15 ms","title":"Minimum Window Substring","url":"/submissions/detail/1083313001/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1083313001,"time":"3 months","lang":"java","title_slug":"minimum-window-substring","timestamp":1698180609,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public String minWindow(String s, String t) {\n        HashMap<Character, Integer> m = new HashMap<>();\n        HashMap<Character, Integer> tracker = new HashMap<>();\n\n        for (Character c: t.toCharArray()){\n            m.put(c,m.getOrDefault(c,0)+1);\n            tracker.put(c,0);\n        }\n        int l = 0;\n        int r = 0;\n        int count = 0;\n        int n = s.length();\n        char [] ch = s.toCharArray();\n        int min = Integer.MAX_VALUE;\n        int min_l = -1;\n        int min_r = -1;\n        \n        while (r<n){\n                                // System.out.println(l +\" \" + r +\" \" + count);\n\n            if ( tracker.containsKey( ch[r] ) ){\n                tracker.put(ch[r], tracker.get(ch[r])+1);\n                if (tracker.get(ch[r])==m.get(ch[r])){\n                    count ++;\n                }\n            }\n            if (count == m.keySet().size()){\n                \n                while (count == m.keySet().size()){\n                    if (l>=n) break;\n\n                    int dist = r - l + 1;\n                    if (dist<min) {\n                        min = dist;\n                        min_l = l;\n                        min_r = r;\n                    }\n                      \n                    if (tracker.containsKey(ch[l])){\n                        tracker.put(ch[l],tracker.get(ch[l])-1 );\n                        if (tracker.get(ch[l])<m.get(ch[l] ) ) count --;\n\n                    }\n                    l++;\n                }\n            }\n            r++;\n        }\n\n\n        if (min==Integer.MAX_VALUE) return \"\";\n        StringBuilder re = new StringBuilder();\n        for (int i = min_l; i<=min_r;i++){\n            re.append(ch[i]);\n        }\n        return re.toString();\n\n    }\n}\n// ADOBECODEBANC","runtime":"N/A","title":"Minimum Window Substring","url":"/submissions/detail/1083309688/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1083309688,"time":"3 months","lang":"java","title_slug":"minimum-window-substring","timestamp":1698180243,"status":11,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111101"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public String minWindow(String s, String t) {\n        HashMap<Character, Integer> m = new HashMap<>();\n        HashMap<Character, Integer> tracker = new HashMap<>();\n\n        for (Character c: t.toCharArray()){\n            m.put(c,m.getOrDefault(c,0)+1);\n            tracker.put(c,0);\n        }\n        int l = 0;\n        int r = 0;\n        int count = 0;\n        int n = s.length();\n        char [] ch = s.toCharArray();\n        int min = Integer.MAX_VALUE;\n        int min_l = -1;\n        int min_r = -1;\n        \n        while (r<n){\n                                System.out.println(l +\" \" + r +\" \" + count);\n\n            if ( tracker.containsKey( ch[r] ) ){\n                tracker.put(ch[r], tracker.get(ch[r])+1);\n                if (tracker.get(ch[r])==m.get(ch[r])){\n                    count ++;\n                }\n            }\n            if (count == m.keySet().size()){\n                \n                while (count == m.keySet().size()){\n                    if (l>=n) break;\n\n                    int dist = r - l + 1;\n                    if (dist<min) {\n                        min = dist;\n                        min_l = l;\n                        min_r = r;\n                    }\n                      \n                    if (tracker.containsKey(ch[l])){\n                        tracker.put(ch[l],tracker.get(ch[l])-1 );\n                        if (tracker.get(ch[l])<m.get(ch[l] ) ) count --;\n\n                    }\n                    l++;\n                }\n            }\n            r++;\n        }\n\n\n        if (min==Integer.MAX_VALUE) return \"\";\n        StringBuilder re = new StringBuilder();\n        for (int i = min_l; i<=min_r;i++){\n            re.append(ch[i]);\n        }\n        return re.toString();\n\n    }\n}\n// ADOBECODEBANC","runtime":"N/A","title":"Minimum Window Substring","url":"/submissions/detail/1083309628/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1083309628,"time":"3 months","lang":"java","title_slug":"minimum-window-substring","timestamp":1698180235,"status":11,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111101"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public String minWindow(String s, String t) {\n        HashMap<Character, Integer> m = new HashMap<>();\n        HashMap<Character, Integer> tracker = new HashMap<>();\n\n        for (Character c: t.toCharArray()){\n            m.put(c,m.getOrDefault(c,0)+1);\n            tracker.put(c,0);\n        }\n        int l = 0;\n        int r = 0;\n        int count = 0;\n        int n = s.length();\n        char [] ch = s.toCharArray();\n        int min = Integer.MAX_VALUE;\n        int min_l = -1;\n        int min_r = -1;\n        \n        while (r<n){\n            if ( tracker.containsKey( ch[r] ) ){\n                tracker.put(ch[r], tracker.get(ch[r])+1);\n                if (tracker.get(ch[r])==m.get(ch[r])){\n                    count ++;\n                }\n            }\n            if (count == t.length()){\n                \n                while (count == t.length()){\n                    // System.out.println(l +\" \" + r +\" \" + count);\n\n                    int dist = r - l + 1;\n                    if (dist<min) {\n                        min = dist;\n                        min_l = l;\n                        min_r = r;\n                    }\n                      \n                    if (l>=n) break;\n                    if (tracker.containsKey(ch[l])){\n                        tracker.put(ch[l],tracker.get(ch[l])-1 );\n                        if (tracker.get(ch[l])<m.get(ch[l] ) ) count --;\n\n                    }\n                    l++;\n                }\n            }\n            r++;\n        }\n\n\n        if (min==Integer.MAX_VALUE) return \"\";\n        StringBuilder re = new StringBuilder();\n        for (int i = min_l; i<=min_r;i++){\n            re.append(ch[i]);\n        }\n        return re.toString();\n\n    }\n}\n// ADOBECODEBANC","runtime":"N/A","title":"Minimum Window Substring","url":"/submissions/detail/1083308264/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1083308264,"time":"3 months","lang":"java","title_slug":"minimum-window-substring","timestamp":1698180092,"status":11,"is_pending":"Not Pending","compare_result":"111111110111111111101100011110011011010011111100110111111011001111111111111111010111110111111111111001000001011010111000111111111101111111010111101111010111110111111111100010010011110000000101000000000000000000000000001001010000000010000001001000100000001100000000001"}],"has_next":true,"last_key":"%7B%22pk%22%3A%20%7B%22N%22%3A%20%221083308264%22%7D%2C%20%22dt%22%3A%20%7B%22S%22%3A%20%222023-10-24T20%3A41%3A32.931501%2B0000%22%7D%2C%20%22sid%22%3A%20%7B%22N%22%3A%20%227573785%22%7D%7D"}
2024-01-26 23:02:13.711 [main] DEBUG submission_dump - {"submissions_dump":[{"status_display":"Accepted","memory":"60.7 MB","code":"class Solution {\n    public int minimumSum(int[] nums) {\n        int sum = 0;\n        int n = nums.length;\n        int[] l = new int[n];\n        int[] r = new int[n];\n        int min= Integer.MAX_VALUE;\n        Arrays.fill(l, Integer.MAX_VALUE);\n        Arrays.fill(r, Integer.MAX_VALUE);\n        for (int i =0;i<n;i++) {\n        \tif (nums[i]<min) min = nums[i];\n        \tl[i] = min;\n        }\n        min= Integer.MAX_VALUE;\n        for (int i =n-1;i>0;i--) {\n        \tif (nums[i]<min) min = nums[i];\n        \tr[i] = min;\n        }\n        min= Integer.MAX_VALUE;\n        for (int i = 0;i<n;i++) {\n        \t// System.out.println(l[i]+\" \"+r[i]);\n        \tsum = l[i] + r[i]+nums[i];\n        \tif (nums[i]>l[i] && nums[i]>r[i]) {\n        \t\tif (sum<min) min = sum;\n        \t}\n        }\n        return min==Integer.MAX_VALUE?-1:min;\n \n    }\n}","runtime":"3 ms","title":"Minimum Sum of Mountain Triplets II","url":"/submissions/detail/1081005310/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1081005310,"time":"3 months, 1 week","lang":"java","title_slug":"minimum-sum-of-mountain-triplets-ii","timestamp":1697943354,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Time Limit Exceeded","memory":"N/A","code":"class Solution {\n    public int minimumSum(int[] nums) {\n        int sum = 0;\n        int n = nums.length;\n        int[] l = new int[n];\n        int[] r = new int[n];\n        int min= Integer.MAX_VALUE;\n        Arrays.fill(l, Integer.MAX_VALUE);\n        Arrays.fill(r, Integer.MAX_VALUE);\n\n        for (int i=1;i<n;i++) {\n        \tfor (int j=i-1;j>=0;j--) {\n        \t\tif (nums[i]>nums[j]) {\n        \t\t\tif (nums[j]<l[i]) {\n        \t\t\t\tl[i] = nums[j];\n        \t\t\t}\n        \t\t}\n        \t}\n        }\n        for (int i=n-2;i>=0;i--) {\n        \tfor (int j=i+1;j<n;j++) {\n        \t\tif (nums[i]>nums[j]) {\n        \t\t\tif (nums[j]<r[i]) {\n        \t\t\t\tr[i] = nums[j];\n        \t\t\t}\n        \t\t}\n        \t}\n        }\n        for (int i = 0;i<n;i++) {\n        \t// System.out.println(l[i]+\" \"+r[i]);\n        \tsum = l[i] + r[i]+nums[i];\n        \tif (l[i]!= Integer.MAX_VALUE && r[i]!=Integer.MAX_VALUE) {\n        \t\tif (sum<min) min = sum;\n        \t}\n        }\n        \n        return min==Integer.MAX_VALUE?-1:min;\n \n    }\n}","runtime":"N/A","title":"Minimum Sum of Mountain Triplets II","url":"/submissions/detail/1081000886/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1081000886,"time":"3 months, 1 week","lang":"java","title_slug":"minimum-sum-of-mountain-triplets-ii","timestamp":1697943108,"status":14,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000"},{"status_display":"Time Limit Exceeded","memory":"N/A","code":"class Solution {\n    public int minimumSum(int[] nums) {\n        int sum = 0;\n        int n = nums.length;\n        int min = Integer.MAX_VALUE;\n        for (int i =0;i<n-2;i++) {\n        \tfor (int j=i+1;j<n-1;j++) {\n        \t\tfor (int k= j+1;k<n;k++) {\n        \t\t\tif (nums[j]>nums[k] && nums[j]>nums[i]) {\n        \t\t\t\tsum = nums[i] + nums[j] + nums[k];\n        \t\t\t\tif (sum<min) min = sum;\n        \t\t\t}\n        \t\t}\n        \t}\n        }\n        return min==Integer.MAX_VALUE?-1:min;\n    }\n}","runtime":"N/A","title":"Minimum Sum of Mountain Triplets II","url":"/submissions/detail/1080984658/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1080984658,"time":"3 months, 1 week","lang":"java","title_slug":"minimum-sum-of-mountain-triplets-ii","timestamp":1697942300,"status":14,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000000000000"},{"status_display":"Accepted","memory":"41.4 MB","code":"class Solution {\n    public int minimumSum(int[] nums) {\n        int sum = 0;\n        int n = nums.length;\n        int min = Integer.MAX_VALUE;\n        for (int i =0;i<n-2;i++) {\n        \tfor (int j=i+1;j<n-1;j++) {\n        \t\tfor (int k= j+1;k<n;k++) {\n        \t\t\tif (nums[j]>nums[k] && nums[j]>nums[i]) {\n        \t\t\t\tsum = nums[i] + nums[j] + nums[k];\n        \t\t\t\tif (sum<min) min = sum;\n        \t\t\t}\n        \t\t}\n        \t}\n        }\n        return min==Integer.MAX_VALUE?-1:min;\n    }\n}","runtime":"1 ms","title":"Minimum Sum of Mountain Triplets I","url":"/submissions/detail/1080982338/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1080982338,"time":"3 months, 1 week","lang":"java","title_slug":"minimum-sum-of-mountain-triplets-i","timestamp":1697942206,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Time Limit Exceeded","memory":"N/A","code":"class Solution {\n    public String minWindow(String s, String t) {\n        HashMap<Character, Integer> m = new HashMap<>();\n        for (Character c: t.toCharArray()){\n            m.put(c,m.getOrDefault(c,0)+1);\n        }\n        int l = 0;\n        int r = 0;\n        char [] ch = s.toCharArray();\n        int n = t.length();\n        HashMap<Character, Integer> temp = new HashMap<>(m);\n        int min = Integer.MAX_VALUE;\n        int min_l = -1;\n        int min_r = -1;\n        int count = 0;\n        int next_l = -1;\n        while (l<s.length()){\n            while (l<s.length() && !temp.containsKey(ch[l])) l++;\n            r= l;\n            count = 0;\n            next_l = -1;\n            while (r<s.length() && count<n){\n                if (temp.containsKey(ch[r])){\n                    if ( r != l && next_l == -1) next_l = r;\n                }\n                if (temp.containsKey(ch[r]) && temp.get(ch[r])>0 ){\n                    count++;\n                    temp.put(ch[r], temp.get(ch[r])-1);\n                }\n                // System.out.println(l+\" \"+r+\" \"+count+ \" \"+ next_l);\n                if (count == n){\n                    int v = r-l + 1;\n                    if (v < min) {\n                        min = v;\n                        min_l = l;\n                        min_r = r;\n                        break;\n                    }\n                }\n                r++;\n            }\n            count = 1;\n\n            l = next_l!=-1?next_l:r ;\n            temp = new HashMap<>(m);\n            \n        }\n        StringBuilder re = new StringBuilder();\n        if (min == Integer.MAX_VALUE) return \"\";\n        for (int i = min_l;i<=min_r;i++){\n            re.append(s.charAt(i));\n        }\n\n        return re.toString();\n\n    }\n}","runtime":"N/A","title":"Minimum Window Substring","url":"/submissions/detail/1080881773/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1080881773,"time":"3 months, 1 week","lang":"java","title_slug":"minimum-window-substring","timestamp":1697925760,"status":14,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100"},{"status_display":"Time Limit Exceeded","memory":"N/A","code":"class Solution {\n    public String minWindow(String s, String t) {\n        HashMap<Character, Integer> m = new HashMap<>();\n        for (Character c: t.toCharArray()){\n            m.put(c,m.getOrDefault(c,0)+1);\n        }\n        int l = 0;\n        int r = 0;\n        char [] ch = s.toCharArray();\n        int n = t.length();\n        HashMap<Character, Integer> temp = new HashMap<>(m);\n        int min = Integer.MAX_VALUE;\n        int min_l = -1;\n        int min_r = -1;\n        int count = 0;\n        int next_l = -1;\n        while (l<s.length()){\n            while (l<s.length() && !temp.containsKey(ch[l])) l++;\n            r= l;\n            count = 0;\n            next_l = -1;\n            while (r<s.length() && count<n){\n                if (temp.containsKey(ch[r])){\n                    if ( r != l && next_l == -1) next_l = r;\n                }\n                if (temp.containsKey(ch[r]) && temp.get(ch[r])>0 ){\n                    count++;\n                    temp.put(ch[r], temp.get(ch[r])-1);\n                }\n                // System.out.println(l+\" \"+r+\" \"+count+ \" \"+ next_l);\n                if (count == n){\n                    int v = r-l + 1;\n                    if (v < min) {\n                        min = v;\n                        min_l = l;\n                        min_r = r;\n                        break;\n                    }\n                }\n                r++;\n            }\n            count = 1;\n\n            l = next_l!=-1?next_l:r ;\n            temp = new HashMap<>(m);\n            \n        }\n        StringBuilder re = new StringBuilder();\n        if (min == Integer.MAX_VALUE) return \"\";\n        for (int i = min_l;i<=min_r;i++){\n            re.append(s.charAt(i));\n        }\n\n        return re.toString();\n\n    }\n}","runtime":"N/A","title":"Minimum Window Substring","url":"/submissions/detail/1080297362/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1080297362,"time":"3 months, 1 week","lang":"java","title_slug":"minimum-window-substring","timestamp":1697855801,"status":14,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100"},{"status_display":"Time Limit Exceeded","memory":"N/A","code":"class Solution {\n    public String minWindow(String s, String t) {\n        HashMap<Character, Integer> m = new HashMap<>();\n        for (Character c: t.toCharArray()){\n            m.put(c,m.getOrDefault(c,0)+1);\n        }\n        int l = 0;\n        int r = 0;\n        char [] ch = s.toCharArray();\n        int n = t.length();\n        HashMap<Character, Integer> temp = new HashMap<>(m);\n        int min = Integer.MAX_VALUE;\n        int min_l = -1;\n        int min_r = -1;\n        int count = 0;\n        while (l<s.length()){\n            while (l<s.length() && !temp.containsKey(ch[l])) l++;\n            r= l;\n            count = 0;\n            while (r<s.length() && count<n){\n                if (temp.containsKey(ch[r]) && temp.get(ch[r])>0 ){\n                    count++;\n                    temp.put(ch[r], temp.get(ch[r])-1);\n                }\n                // System.out.println(l+\" \"+r+\" \"+count);\n                if (count == n){\n                    int v = r-l + 1;\n                    if (v < min) {\n                        min = v;\n                        min_l = l;\n                        min_r = r;\n                        break;\n\n                    }\n                }\n                r++;\n            }\n            count = 1;\n            l = l+1 ;\n            temp = new HashMap<>(m);\n            \n        }\n        StringBuilder re = new StringBuilder();\n        if (min == Integer.MAX_VALUE) return \"\";\n        for (int i = min_l;i<=min_r;i++){\n            re.append(s.charAt(i));\n        }\n\n        return re.toString();\n\n    }\n}","runtime":"N/A","title":"Minimum Window Substring","url":"/submissions/detail/1080295015/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1080295015,"time":"3 months, 1 week","lang":"java","title_slug":"minimum-window-substring","timestamp":1697855341,"status":14,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100"},{"status_display":"Time Limit Exceeded","memory":"N/A","code":"class Solution {\n    public String minWindow(String s, String t) {\n        HashMap<Character, Integer> m = new HashMap<>();\n        for (Character c: t.toCharArray()){\n            m.put(c,m.getOrDefault(c,0)+1);\n        }\n        int l = 0;\n        int r = 0;\n        char [] ch = s.toCharArray();\n        int n = t.length();\n        HashMap<Character, Integer> temp = new HashMap<>(m);\n        int min = Integer.MAX_VALUE;\n        int min_l = -1;\n        int min_r = -1;\n        int count = 0;\n        while (l<s.length()){\n            while (l<s.length() && !temp.containsKey(ch[l])) l++;\n            r= l;\n            count = 0;\n            while (r<s.length() && count<n){\n                if (temp.containsKey(ch[r]) && temp.get(ch[r])>0 ){\n                    count++;\n                    temp.put(ch[r], temp.get(ch[r])-1);\n                }\n                System.out.println(l+\" \"+r+\" \"+count);\n                if (count == n){\n                    int v = r-l + 1;\n                    if (v < min) {\n                        min = v;\n                        min_l = l;\n                        min_r = r;\n                        break;\n\n                    }\n                }\n                r++;\n            }\n            count = 1;\n            l = l+1 ;\n            temp = new HashMap<>(m);\n            \n        }\n        StringBuilder re = new StringBuilder();\n        if (min == Integer.MAX_VALUE) return \"\";\n        for (int i = min_l;i<=min_r;i++){\n            re.append(s.charAt(i));\n        }\n\n        return re.toString();\n\n    }\n}","runtime":"N/A","title":"Minimum Window Substring","url":"/submissions/detail/1080294956/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1080294956,"time":"3 months, 1 week","lang":"java","title_slug":"minimum-window-substring","timestamp":1697855332,"status":14,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public String minWindow(String s, String t) {\n        HashMap<Character, Integer> m = new HashMap<>();\n        for (Character c: t.toCharArray()){\n            m.put(c,m.getOrDefault(c,0)+1);\n        }\n        int l = 0;\n        int r = 0;\n        char [] ch = s.toCharArray();\n        int n = t.length();\n        HashMap<Character, Integer> temp = new HashMap<>(m);\n        int min = Integer.MAX_VALUE;\n        int min_l = -1;\n        int min_r = -1;\n        int count = 0;\n        while (l<s.length()){\n            while (l<s.length() && !temp.containsKey(ch[l])) l++;\n            r= l;\n            count = 0;\n            while (r<s.length() && count<n){\n                if (temp.containsKey(ch[r]) && temp.get(ch[r])>0 ){\n                    count++;\n                    temp.put(ch[r], temp.get(ch[r])+1);\n                }\n                System.out.println(l+\" \"+r+\" \"+count);\n                if (count == n){\n                    int v = r-l + 1;\n                    if (v < min) {\n                        min = v;\n                        min_l = l;\n                        min_r = r;\n                        break;\n\n                    }\n                }\n                r++;\n            }\n            count = 1;\n            l = l+1 ;\n            temp = new HashMap<>(m);\n            \n        }\n        StringBuilder re = new StringBuilder();\n        if (min == Integer.MAX_VALUE) return \"\";\n        for (int i = min_l;i<=min_r;i++){\n            re.append(s.charAt(i));\n        }\n\n        return re.toString();\n\n    }\n}","runtime":"N/A","title":"Minimum Window Substring","url":"/submissions/detail/1080294322/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1080294322,"time":"3 months, 1 week","lang":"java","title_slug":"minimum-window-substring","timestamp":1697855201,"status":11,"is_pending":"Not Pending","compare_result":"111111111111111111111000011111000000010001001100011110111100100011011101111110011110011110001010001000010001011111001101110111101110111111111111111111111000011111010111101001010110000000001101101000000000000000000010000000000000000000000000001000000000000000000000000"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public String minWindow(String s, String t) {\n        HashMap<Character, Integer> m = new HashMap<>();\n        for (Character c: t.toCharArray()){\n            m.put(c,m.getOrDefault(c,0)+1);\n        }\n        int l = 0;\n        int r = 0;\n        char [] ch = s.toCharArray();\n        int n = t.length();\n        HashMap<Character, Integer> temp = new HashMap<>(m);\n        int min = Integer.MAX_VALUE;\n        int min_l = -1;\n        int min_r = -1;\n        int count = 0;\n        while (l<s.length()){\n            while (l<s.length() && !temp.containsKey(ch[l])) l++;\n            r= l;\n            count = 0;\n            while (r<s.length() && count<n){\n                if (temp.containsKey(ch[r]) && temp.get(ch[r])>0 ){\n                    count++;\n                    temp.put(ch[r], temp.get(ch[r])+1);\n                }\n                // System.out.println(l+\" \"+r+\" \"+count);\n                if (count == n){\n                    int v = r-l + 1;\n                    if (v < min) {\n                        min = v;\n                        min_l = l;\n                        min_r = r;\n                    }\n                }\n                r++;\n\n            }\n            l = r + 1;\n            \n        }\n        StringBuilder re = new StringBuilder();\n        if (min == Integer.MAX_VALUE) return \"\";\n        for (int i = min_l;i<=min_r;i++){\n            re.append(s.charAt(i));\n        }\n\n        return re.toString();\n\n    }\n}","runtime":"N/A","title":"Minimum Window Substring","url":"/submissions/detail/1080281724/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1080281724,"time":"3 months, 1 week","lang":"java","title_slug":"minimum-window-substring","timestamp":1697852637,"status":11,"is_pending":"Not Pending","compare_result":"111111111111111111110000000001000000010010001100011110111100100011010101101110011110011110001010001100000001011110101101110111101110111111111111111111111000011111010111101001010110010000001101101000000000000000000000000000000000000000000000000000000000000000000000000"},{"status_display":"Runtime Error","memory":"N/A","code":"class Solution {\n    public String minWindow(String s, String t) {\n        HashMap<Character, Integer> m = new HashMap<>();\n        for (Character c: t.toCharArray()){\n            m.put(c,m.getOrDefault(c,0)+1);\n        }\n        int l = 0;\n        int r = 0;\n        char [] ch = s.toCharArray();\n        int n = t.length();\n        HashMap<Character, Integer> temp = new HashMap<>(m);\n        int min = Integer.MAX_VALUE;\n        int min_l = -1;\n        int min_r = -1;\n        int count = 0;\n        while (l<s.length()){\n            while (!temp.containsKey(ch[l])) l++;\n            r= l;\n            count = 0;\n            while (r<s.length() && count<n){\n                if (temp.containsKey(ch[r]) && temp.get(ch[r])>0 ){\n                    count++;\n                    temp.put(ch[r], temp.get(ch[r])+1);\n                }\n                // System.out.println(l+\" \"+r+\" \"+count);\n                if (count == n){\n                    int v = r-l + 1;\n                    if (v < min) {\n                        min = v;\n                        min_l = l;\n                        min_r = r;\n                    }\n                }\n                r++;\n\n            }\n            l = r + 1;\n            \n        }\n        StringBuilder re = new StringBuilder();\n        if (min == Integer.MAX_VALUE) return \"\";\n        for (int i = min_l;i<=min_r;i++){\n            re.append(s.charAt(i));\n        }\n\n        return re.toString();\n\n    }\n}","runtime":"N/A","title":"Minimum Window Substring","url":"/submissions/detail/1080281548/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1080281548,"time":"3 months, 1 week","lang":"java","title_slug":"minimum-window-substring","timestamp":1697852601,"status":15,"is_pending":"Not Pending","compare_result":"111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"},{"status_display":"Runtime Error","memory":"N/A","code":"class Solution {\n    public String minWindow(String s, String t) {\n        HashMap<Character, Integer> m = new HashMap<>();\n        for (Character c: t.toCharArray()){\n            m.put(c,m.getOrDefault(c,0)+1);\n        }\n        int l = 0;\n        int r = 0;\n        char [] ch = s.toCharArray();\n        int n = t.length();\n        HashMap<Character, Integer> temp = new HashMap<>(m);\n        int min = Integer.MAX_VALUE;\n        int min_l = -1;\n        int min_r = -1;\n        int count = 0;\n        while (l<s.length()){\n            while (!temp.containsKey(ch[l])) l++;\n            r= l;\n            count = 0;\n            while (r<s.length() && count<n){\n                if (temp.containsKey(ch[r]) && temp.get(ch[r])>0 ){\n                    count++;\n                    temp.put(ch[r], temp.get(ch[r])+1);\n                }\n                System.out.println(l+\" \"+r+\" \"+count);\n                if (count == n){\n                    int v = r-l + 1;\n                    if (v < min) {\n                        min = v;\n                        min_l = l;\n                        min_r = r;\n                    }\n                }\n                r++;\n\n            }\n            l = r + 1;\n            \n        }\n        StringBuilder re = new StringBuilder();\n        if (min == Integer.MAX_VALUE) return \"\";\n        for (int i = min_l;i<=min_r;i++){\n            re.append(s.charAt(i));\n        }\n\n        return re.toString();\n\n    }\n}","runtime":"N/A","title":"Minimum Window Substring","url":"/submissions/detail/1080281525/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1080281525,"time":"3 months, 1 week","lang":"java","title_slug":"minimum-window-substring","timestamp":1697852595,"status":15,"is_pending":"Not Pending","compare_result":"111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"},{"status_display":"Accepted","memory":"45 MB","code":"class Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        HashMap<String,Integer> map = new HashMap<>();\n        for (String si: words){\n            if (map.containsKey(si)) map.put(si,map.get(si)+1);\n            else map.put(si,1);\n        }\n        HashMap<String,Integer> temp = new HashMap<>();\n        StringBuilder sb = new StringBuilder();\n        int l = 0;\n        int r = 0;\n        int count = 0;\n        int wordLen = words[0].length();\n        int start = l;\n        List<Integer> re = new ArrayList<>();\n        while (l<s.length()){\n            boolean check = false;\n            for (String si:map.keySet()){\n                if (!temp.containsKey(si)){\n                    if (s.startsWith(si,l)){\n                        // System.out.println(si);\n                        count++;\n                        l= l + si.length();\n                        temp.put(si,1);\n                        check = true;\n                    }\n                }\n                else if (temp.get(si)<map.get(si)){\n                    if (s.startsWith(si,l)){\n                        // System.out.println(si);\n                        count++;\n                        l= l + si.length();\n                        temp.put(si,temp.get(si)+1);\n                        check = true;\n                    }\n                }\n                \n            }\n            if (!check){\n                if (count == words.length) re.add(start);\n                l = start+1;\n                start = l;\n                count = 0;\n                temp = new HashMap<>();\n            }   \n        }\n        // System.out.println(count);\n        if (count == words.length) re.add(start);\n\n        return re;\n    }\n}","runtime":"2346 ms","title":"Substring with Concatenation of All Words","url":"/submissions/detail/1080272298/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1080272298,"time":"3 months, 1 week","lang":"java","title_slug":"substring-with-concatenation-of-all-words","timestamp":1697850613,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"45 MB","code":"class Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        HashMap<String,Integer> map = new HashMap<>();\n        for (String si: words){\n            if (map.containsKey(si)) map.put(si,map.get(si)+1);\n            else map.put(si,1);\n        }\n        HashMap<String,Integer> temp = new HashMap<>();\n        StringBuilder sb = new StringBuilder();\n        int l = 0;\n        int r = 0;\n        int count = 0;\n        int wordLen = words[0].length();\n        int start = l;\n        List<Integer> re = new ArrayList<>();\n        while (l<s.length()){\n            boolean check = false;\n            for (String si:map.keySet()){\n                if (!temp.containsKey(si)){\n                    if (s.startsWith(si,l)){\n                        // System.out.println(si);\n                        count++;\n                        l= l + si.length();\n                        temp.put(si,1);\n                        check = true;\n                    }\n                }\n                else if (temp.get(si)<map.get(si)){\n                    if (s.startsWith(si,l)){\n                        // System.out.println(si);\n                        count++;\n                        l= l + si.length();\n                        temp.put(si,temp.get(si)+1);\n                        check = true;\n                    }\n                }\n                \n            }\n            if (!check){\n                if (count == words.length) re.add(start);\n                l = start+1;\n                start = l;\n                count = 0;\n                temp.clear();\n            }   \n        }\n        // System.out.println(count);\n        if (count == words.length) re.add(start);\n\n        return re;\n    }\n}","runtime":"2277 ms","title":"Substring with Concatenation of All Words","url":"/submissions/detail/1080272159/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1080272159,"time":"3 months, 1 week","lang":"java","title_slug":"substring-with-concatenation-of-all-words","timestamp":1697850587,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"45 MB","code":"class Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        HashMap<String,Integer> map = new HashMap<>();\n        for (String si: words){\n            if (map.containsKey(si)) map.put(si,map.get(si)+1);\n            else map.put(si,1);\n        }\n        HashMap<String,Integer> temp = new HashMap<>();\n        StringBuilder sb = new StringBuilder();\n        int l = 0;\n        int r = 0;\n        int count = 0;\n        int wordLen = words[0].length();\n        int start = l;\n        List<Integer> re = new ArrayList<>();\n        while (l<s.length()){\n            boolean check = false;\n            for (String si:map.keySet()){\n                if (!temp.containsKey(si)){\n                    if (s.startsWith(si,l)){\n                        // System.out.println(si);\n                        count++;\n                        l= l + si.length();\n                        temp.put(si,1);\n                        check = true;\n                    }\n                }\n                else if (temp.get(si)<map.get(si)){\n                    if (s.startsWith(si,l)){\n                        // System.out.println(si);\n                        count++;\n                        l= l + si.length();\n                        temp.put(si,temp.get(si)+1);\n                        check = true;\n                    }\n                }\n                \n            }\n            if (!check){\n                if (count == words.length) re.add(start);\n                l = start+1;\n                start = l;\n                count = 0;\n                temp.clear();\n            }   \n        }\n        // System.out.println(count);\n        if (count == words.length) re.add(start);\n\n        return re;\n    }\n}","runtime":"2275 ms","title":"Substring with Concatenation of All Words","url":"/submissions/detail/1080272096/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1080272096,"time":"3 months, 1 week","lang":"java","title_slug":"substring-with-concatenation-of-all-words","timestamp":1697850574,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"45 MB","code":"class Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        HashMap<String,Integer> map = new HashMap<>();\n        for (String si: words){\n            if (map.containsKey(si)) map.put(si,map.get(si)+1);\n            else map.put(si,1);\n        }\n        HashMap<String,Integer> temp = new HashMap<>(map);\n        StringBuilder sb = new StringBuilder();\n        int l = 0;\n        int r = 0;\n        int count = 0;\n        int wordLen = words[0].length();\n        int start = l;\n        List<Integer> re = new ArrayList<>();\n        while (l<s.length()){\n            boolean check = false;\n            for (String si:map.keySet()){\n                if (map.get(si)>0){\n                    if (s.startsWith(si,l)){\n                        // System.out.println(si);\n                        count++;\n                        l= l + si.length();\n                        map.put(si,map.get(si)-1);\n                        check = true;\n                    }\n                }\n            }\n            if (!check){\n                if (count == words.length) re.add(start);\n                l = start+1;\n                start = l;\n                count = 0;\n                map = new HashMap<>(temp);\n            }   \n        }\n        // System.out.println(count);\n        if (count == words.length) re.add(start);\n\n        return re;\n    }\n}","runtime":"1959 ms","title":"Substring with Concatenation of All Words","url":"/submissions/detail/1080245817/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1080245817,"time":"3 months, 1 week","lang":"java","title_slug":"substring-with-concatenation-of-all-words","timestamp":1697845047,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Time Limit Exceeded","memory":"N/A","code":"class Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        HashMap<String,Integer> map = new HashMap<>();\n        for (String si: words){\n            if (map.containsKey(si)) map.put(si,map.get(si)+1);\n            else map.put(si,1);\n        }\n        HashMap<String,Integer> temp = new HashMap<>(map);\n        StringBuilder sb = new StringBuilder();\n        int l = 0;\n        int r = 0;\n        int count = 0;\n        int wordLen = words[0].length();\n        int start = l;\n        List<Integer> re = new ArrayList<>();\n        while (l<s.length()){\n            boolean check = false;\n            for (String si:map.keySet()){\n                if (map.get(si)>0){\n                    if (s.startsWith(si,l)){\n                        System.out.println(si);\n                        count++;\n                        l= l + si.length();\n                        map.put(si,map.get(si)-1);\n                        check = true;\n                    }\n                }\n            }\n            if (!check){\n                if (count == words.length) re.add(start);\n                l = start+1;\n                start = l;\n                count = 0;\n                map = new HashMap<>(temp);\n            }   \n        }\n        System.out.println(count);\n        if (count == words.length) re.add(start);\n\n        return re;\n    }\n}","runtime":"N/A","title":"Substring with Concatenation of All Words","url":"/submissions/detail/1080245566/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1080245566,"time":"3 months, 1 week","lang":"java","title_slug":"substring-with-concatenation-of-all-words","timestamp":1697844995,"status":14,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        HashMap<String,Integer> map = new HashMap<>();\n        for (String si: words){\n            if (map.containsKey(si)) map.put(si,map.get(si)+1);\n            else map.put(si,1);\n        }\n        HashMap<String,Integer> temp = new HashMap<>(map);\n        StringBuilder sb = new StringBuilder();\n        int l = 0;\n        int r = 0;\n        int count = 0;\n        int wordLen = words[0].length();\n        int start = l;\n        List<Integer> re = new ArrayList<>();\n        while (l<s.length()){\n            boolean check = false;\n            for (String si:map.keySet()){\n                if (map.get(si)>0){\n                    if (s.startsWith(si,l)){\n                        System.out.println(si);\n                        count++;\n                        l= l + si.length();\n                        map.put(si,map.get(si)-1);\n                        check = true;\n                    }\n                }\n            }\n            if (!check){\n                if (count == words.length) re.add(start);\n                l = start+wordLen;\n                start = l;\n                count = 0;\n                map = new HashMap<>(temp);\n            }   \n        }\n        System.out.println(count);\n        if (count == words.length) re.add(start);\n\n        return re;\n    }\n}","runtime":"N/A","title":"Substring with Concatenation of All Words","url":"/submissions/detail/1080245094/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1080245094,"time":"3 months, 1 week","lang":"java","title_slug":"substring-with-concatenation-of-all-words","timestamp":1697844893,"status":11,"is_pending":"Not Pending","compare_result":"11110111110110111100111110010011010001111011100110110001111110111011110100000011111001000111110001101101110010110011010101010000010010000001000000100000000000000000000000000011010"},{"status_display":"Accepted","memory":"52.4 MB","code":"class Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        Set<List<Integer>> a = new HashSet<>();\n        int zeros = 0;\n        ArrayList<Integer> pos = new ArrayList<>();\n        ArrayList<Integer> neg = new ArrayList<>();\n        HashSet<Integer> posSet = new HashSet<>();\n        HashSet<Integer> negSet = new HashSet<>();\n        for (int i : nums){\n            if (i ==0) zeros++;\n            if (i>0) {\n                pos.add(i);\n                posSet.add(i);\n            }\n            if (i<0){\n                neg.add(i);\n                negSet.add(i);\n            }\n        }\n        List<List<Integer>> re = new ArrayList<>();\n        if (zeros >=3) a.add(Arrays.asList(0,0,0));\n        if (zeros >0 ){\n            for (int i: posSet){\n                if (negSet.contains(-i)){\n                    a.add(Arrays.asList(-i,0,i));\n                }\n            }\n        }\n        //2 pos\n        for (int i = 0; i<pos.size()-1;i++){\n            for (int j = i+1;j<pos.size();j++){\n                if ( negSet.contains( -1 *(pos.get(i)+pos.get(j) ) ) )  {\n                    List<Integer> temp = Arrays.asList(-1 * (pos.get(i)+pos.get(j)), pos.get(i),pos.get(j));\n                    Collections.sort(temp);\n                    a.add(temp);\n                }\n            }\n        }\n        \n        // 2 neg\n        for (int i = 0 ;i<neg.size()-1;i++){\n            for (int j = i+1; j<neg.size();j++){\n                if (posSet.contains( -1 * (neg.get(i)+neg.get(j)) )){\n                    List<Integer> temp = Arrays.asList(neg.get(i),neg.get(j),-1 * (neg.get(i)+neg.get(j)));\n                    Collections.sort(temp);\n                    a.add(temp);\n                }\n            }\n        }       \n        re.addAll(a);\n\n        return re;\n        \n    }\n}\n\n","runtime":"119 ms","title":"3Sum","url":"/submissions/detail/1080218693/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1080218693,"time":"3 months, 1 week","lang":"java","title_slug":"3sum","timestamp":1697840016,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"53.4 MB","code":"class Solution {\n    public int minSubArrayLen(int target, int[] nums) {\n        int l = 0;\n        int r = -1;\n        int n = nums.length;\n        int sum = 0;\n        int min = Integer.MAX_VALUE;\n        while (true ){\n            if (sum<target){\n                r++;\n                if (r>=n) break;\n                sum = sum+nums[r];\n            } else{\n                if (r-l + 1 < min) min = r-l+1;\n                if (l>=n) break;\n                sum = sum - nums[l];\n                l++;\n            }\n            // System.out.println(l +\" \" + r +\" \"+ sum +\" \" + min);\n\n        }\n        return min==Integer.MAX_VALUE?0:min;\n        \n    }\n}","runtime":"1 ms","title":"Minimum Size Subarray Sum","url":"/submissions/detail/1079726575/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1079726575,"time":"3 months, 1 week","lang":"java","title_slug":"minimum-size-subarray-sum","timestamp":1697782357,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111"}],"has_next":true,"last_key":"%7B%22pk%22%3A%20%7B%22N%22%3A%20%221079726575%22%7D%2C%20%22dt%22%3A%20%7B%22S%22%3A%20%222023-10-20T06%3A12%3A37.349906%2B0000%22%7D%2C%20%22sid%22%3A%20%7B%22N%22%3A%20%227573785%22%7D%7D"}
2024-01-26 23:02:24.223 [main] DEBUG submission_dump - {"submissions_dump":[{"status_display":"Accepted","memory":"56.2 MB","code":"class Solution {\n    public int minSubArrayLen(int target, int[] nums) {\n        int l = 0;\n        int r = -1;\n        int n = nums.length;\n        int sum = 0;\n        int min = Integer.MAX_VALUE;\n        while (true ){\n            if (sum<target){\n                r++;\n                if (r>=n) break;\n                sum = sum+nums[r];\n            } else{\n                if (r-l + 1 < min) min = r-l+1;\n                if (l>=n) break;\n                sum = sum - nums[l];\n                l++;\n            }\n            System.out.println(l +\" \" + r +\" \"+ sum +\" \" + min);\n\n        }\n        return min==Integer.MAX_VALUE?0:min;\n        \n    }\n}","runtime":"356 ms","title":"Minimum Size Subarray Sum","url":"/submissions/detail/1079726461/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1079726461,"time":"3 months, 1 week","lang":"java","title_slug":"minimum-size-subarray-sum","timestamp":1697782345,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int minSubArrayLen(int target, int[] nums) {\n        Arrays.sort(nums);\n        int n = nums.length;\n        int sum = 0;\n        int count = 0;\n        for (int i = n-1;i>=0;i-- ){\n            count++;\n            sum = sum + nums[i];\n            if (sum >= target) return count;\n        }\n        return 0;\n        \n    }\n}","runtime":"N/A","title":"Minimum Size Subarray Sum","url":"/submissions/detail/1079712714/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1079712714,"time":"3 months, 1 week","lang":"java","title_slug":"minimum-size-subarray-sum","timestamp":1697780900,"status":11,"is_pending":"Not Pending","compare_result":"111111110111111110011"},{"status_display":"Accepted","memory":"52.3 MB","code":"class Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        Set<List<Integer>> a = new HashSet<>();\n        int zeros = 0;\n        ArrayList<Integer> pos = new ArrayList<>();\n        ArrayList<Integer> neg = new ArrayList<>();\n        HashSet<Integer> posSet = new HashSet<>();\n        HashSet<Integer> negSet = new HashSet<>();\n        for (int i : nums){\n            if (i ==0) zeros++;\n            if (i>0) {\n                pos.add(i);\n                posSet.add(i);\n            }\n            if (i<0){\n                neg.add(i);\n                negSet.add(i);\n            }\n        }\n        List<List<Integer>> re = new ArrayList<>();\n        if (zeros >=3) a.add(Arrays.asList(0,0,0));\n        if (zeros >0 ){\n            for (int i: posSet){\n                if (negSet.contains(-i)){\n                    a.add(Arrays.asList(-i,0,i));\n                }\n            }\n        }\n        //2 pos\n        for (int i = 0; i<pos.size()-1;i++){\n            for (int j = i+1;j<pos.size();j++){\n                if ( negSet.contains( -1 *(pos.get(i)+pos.get(j) ) ) )  {\n                    List<Integer> temp = Arrays.asList(-1 * (pos.get(i)+pos.get(j)), pos.get(i),pos.get(j));\n                    Collections.sort(temp);\n                    a.add(temp);\n                }\n            }\n        }\n        \n        // 2 neg\n        for (int i = 0 ;i<neg.size()-1;i++){\n            for (int j = i+1; j<neg.size();j++){\n                if (posSet.contains( -1 * (neg.get(i)+neg.get(j)) )){\n                    List<Integer> temp = Arrays.asList(neg.get(i),neg.get(j),-1 * (neg.get(i)+neg.get(j)));\n                    Collections.sort(temp);\n                    a.add(temp);\n                }\n            }\n        }       \n        re.addAll(a);\n\n        return re;\n        \n    }\n}\n\n","runtime":"119 ms","title":"3Sum","url":"/submissions/detail/1079701921/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1079701921,"time":"3 months, 1 week","lang":"java","title_slug":"3sum","timestamp":1697779694,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        List<List<Integer>> a = new ArrayList<>();\n        int zeros = 0;\n        ArrayList<Integer> pos = new ArrayList<>();\n        ArrayList<Integer> neg = new ArrayList<>();\n        HashSet<Integer> posSet = new HashSet<>();\n        HashSet<Integer> negSet = new HashSet<>();\n        for (int i : nums){\n            if (i ==0) zeros++;\n            if (i>0) {\n                pos.add(i);\n                posSet.add(i);\n            }\n            if (i<0){\n                neg.add(i);\n                negSet.add(i);\n            }\n        }\n        if (zeros >=3) a.add(Arrays.asList(0,0,0));\n        if (zeros >0 ){\n            for (int i: posSet){\n                if (negSet.contains(-i)){\n                    a.add(Arrays.asList(-i,0,i));\n                }\n            }\n        }\n        //2 pos\n        for (int i = 0; i<pos.size()-1;i++){\n            for (int j = i+1;j<pos.size();j++){\n                if ( negSet.contains( -1 *(pos.get(i)+pos.get(j) ) ) )  {\n                    a.add(Arrays.asList(-1 * (pos.get(i)+pos.get(j)), pos.get(i),pos.get(j)));\n                }\n            }\n        }\n        \n        // 2 neg\n        for (int i = 0 ;i<neg.size()-1;i++){\n            for (int j = i+1; j<neg.size();j++){\n                if (posSet.contains( -1 * (neg.get(i)+neg.get(j)) )){\n                    a.add(Arrays.asList(neg.get(i),neg.get(j),-1 * (neg.get(i)+neg.get(j))));\n                }\n            }\n        }       \n\n        return a;\n        \n    }\n}","runtime":"N/A","title":"3Sum","url":"/submissions/detail/1079696292/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1079696292,"time":"3 months, 1 week","lang":"java","title_slug":"3sum","timestamp":1697779062,"status":11,"is_pending":"Not Pending","compare_result":"111111111111111111111010011100011010111101001101010000000000111001000110011100011101100000000110101000100100000001111000011000000000000000000000000000000000000011000000000000000000000000001000000000000000000001011100000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000110"},{"status_display":"Accepted","memory":"40.6 MB","code":"class Solution {\n    public List<String> summaryRanges(int[] nums) {\n        int start = 0;\n        int pointer = 1;\n        // int prev = 0;\n        int n = nums.length;\n        int end = -1;\n        ArrayList<String> re = new ArrayList<>();\n        if (n == 0) return re;\n\n        while (pointer<n){\n            if ( nums[pointer] != nums[pointer -1 ] + 1 ){\n                if (start == pointer-1){\n                    re.add(\"\"+nums[start]);\n                } else{\n                    re.add(nums[start]+\"->\"+nums[pointer-1]);\n                }\n                start = pointer;\n            } \n            pointer++;\n        }\n        if (start == pointer-1){\n            re.add(\"\"+nums[start]);\n        } else{\n            re.add(nums[start]+\"->\"+nums[pointer-1]);\n        }\n        return re;\n    }\n}","runtime":"5 ms","title":"Summary Ranges","url":"/submissions/detail/1079008434/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1079008434,"time":"3 months, 1 week","lang":"java","title_slug":"summary-ranges","timestamp":1697701229,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111"},{"status_display":"Runtime Error","memory":"N/A","code":"class Solution {\n    public List<String> summaryRanges(int[] nums) {\n        int start = 0;\n        int pointer = 1;\n        // int prev = 0;\n        int n = nums.length;\n        int end = -1;\n        ArrayList<String> re = new ArrayList<>();\n        while (pointer<n){\n            if ( nums[pointer] != nums[pointer -1 ] + 1 ){\n                if (start == pointer-1){\n                    re.add(\"\"+nums[start]);\n                } else{\n                    re.add(nums[start]+\"->\"+nums[pointer-1]);\n                }\n                start = pointer;\n            } \n            pointer++;\n        }\n        if (start == pointer-1){\n            re.add(\"\"+nums[start]);\n        } else{\n            re.add(nums[start]+\"->\"+nums[pointer-1]);\n        }\n        return re;\n    }\n}","runtime":"N/A","title":"Summary Ranges","url":"/submissions/detail/1079008119/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1079008119,"time":"3 months, 1 week","lang":"java","title_slug":"summary-ranges","timestamp":1697701197,"status":15,"is_pending":"Not Pending","compare_result":"11000000000000000000000000000000"},{"status_display":"Accepted","memory":"55 MB","code":"class Solution {\n    public int maxArea(int[] height) {\n        int max = 0;\n        int n = height.length;\n        int l= 0;\n        int r = n-1;\n        while (l<r){\n            int val = Integer.min(height[l],height[r]) * (r-l);\n            if (val > max) max = val;\n            if (height[l]<height[r]) l++;\n            else r--;\n        }\n        return max;\n    }\n}","runtime":"4 ms","title":"Container With Most Water","url":"/submissions/detail/1078092930/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1078092930,"time":"3 months, 1 week","lang":"java","title_slug":"container-with-most-water","timestamp":1697605207,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Time Limit Exceeded","memory":"N/A","code":"class Solution {\n    public int maxArea(int[] height) {\n        int max = 0;\n        int n = height.length;\n        for (int i = 0;i<n-1;i++){\n            for (int j= i+1; j<n;j++){\n                int val= Integer.min(height[i],height[j]) * (j-i);\n                if (val >max) max = val;\n            }\n        }\n        return max;\n    }\n}","runtime":"N/A","title":"Container With Most Water","url":"/submissions/detail/1078090155/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1078090155,"time":"3 months, 1 week","lang":"java","title_slug":"container-with-most-water","timestamp":1697604923,"status":14,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111100000"},{"status_display":"Accepted","memory":"45.2 MB","code":"class Solution {\n    public int[] twoSum(int[] numbers, int target) {\n        int l = 0;\n        int r = numbers.length-1;\n        while(numbers[l]+numbers[r]!=target){\n            if (numbers[l]+numbers[r]> target) \n                r--;\n            else \n                l++;\n        }\n        int [] re = {l+1,r+1};\n        return re;\n        \n    }\n}","runtime":"2 ms","title":"Two Sum II - Input Array Is Sorted","url":"/submissions/detail/1078072802/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1078072802,"time":"3 months, 1 week","lang":"java","title_slug":"two-sum-ii-input-array-is-sorted","timestamp":1697603101,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111"},{"status_display":"Accepted","memory":"40.4 MB","code":"class Solution {\n    public boolean isSubsequence(String s, String t) {\n        int p1 = 0;\n        int p2 = 0;\n        while (p1<s.length() && p2<t.length()){\n            if (s.charAt(p1)==t.charAt(p2)){\n                p1++;\n                p2++;\n            } else{\n                p2++;\n            }\n        }\n        return p1>(s.length()-1);\n\n    }\n}","runtime":"1 ms","title":"Is Subsequence","url":"/submissions/detail/1078058309/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1078058309,"time":"3 months, 1 week","lang":"java","title_slug":"is-subsequence","timestamp":1697601594,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111"},{"status_display":"Accepted","memory":"41.7 MB","code":"class Solution {\n    public List<String> fullJustify(String[] words, int maxWidth) {\n        List<String> re = new ArrayList<>();\n        Queue<String> q = new LinkedList<>();\n        int count = 0;\n        int c = -1;\n        for (int i=0;i<words.length;i++){\n            count = count + words[i].length();\n            c++;\n            if (count+c<=maxWidth){\n                q.add(words[i]);\n            } else{\n                String s = \"\";\n                String sp = \"\";\n                String sp1 = \"\";\n\n                count = count - words[i].length();\n                int numspace;\n                int tempcount = 0;\n                if (q.size() == 1) {\n                    numspace = maxWidth - count;\n                    tempcount = 0;\n                } else{\n                    numspace = (maxWidth - count) /(q.size() -1);\n                    tempcount = (maxWidth - count) % (q.size() -1);\n                }\n                \n                while (sp.length()<numspace) sp=sp+\" \";\n                while (sp1.length()<numspace+1) sp1=sp1+\" \";\n                System.out.println(tempcount + \" \"+ numspace);\n                if (q.size() > 1)\n                {\n                    while (q.size()>1){\n                    if (tempcount > 0){\n                        s= s+ q.poll() + sp1;\n                    }\n                    else{\n                        s= s+ q.poll() + sp;\n                    }\n                    tempcount--;\n                    }\n                    if (q.size()==1)\n                    {\n                        s= s+q.poll();\n                    }\n                } else{\n                    s= s+q.poll();\n                    while (s.length()<maxWidth){\n                        s= s+\" \";\n                    }\n\n                }\n                \n                re.add(s);\n                q.add(words[i]);\n\n                count = 0;\n                c= -1;\n                count = count + words[i].length();\n                c++;\n            }\n        }\n        String s = \"\";\n        while (!q.isEmpty()){\n            s = s + q.poll() +\" \";\n        }\n        s = s.substring(0,s.length()-1);\n        while (s.length()<maxWidth){\n            s= s+\" \";\n        }\n\n        re.add(s);\n        for (String i:re){\n            System.out.println(i);\n        }\n        System.out.println(re.get(0).length());\n\n        return re;\n        \n    }\n}\n","runtime":"18 ms","title":"Text Justification","url":"/submissions/detail/1078005534/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1078005534,"time":"3 months, 1 week","lang":"java","title_slug":"text-justification","timestamp":1697595467,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public List<String> fullJustify(String[] words, int maxWidth) {\n        List<String> re = new ArrayList<>();\n        Queue<String> q = new LinkedList<>();\n        int count = 0;\n        int c = -1;\n        for (int i=0;i<words.length;i++){\n            count = count + words[i].length();\n            c++;\n            if (count+c<=maxWidth){\n                q.add(words[i]);\n            } else{\n                String s = \"\";\n                String sp = \"\";\n                count = count - words[i].length();\n                int numspace1;\n                int numspace;\n                if (q.size() == 1) {\n                    numspace = maxWidth - count;\n                    numspace1 = numspace;\n                } else{\n                    numspace = (maxWidth - count) /(q.size() -1);\n                    numspace1 = numspace + (maxWidth - count) % (q.size() -1);\n                }\n                \n                while (sp.length()<numspace1) sp=sp+\" \";\n                s = q.poll() + sp;\n                sp = \"\";\n                while (sp.length()<numspace) sp=sp+\" \";\n                while (q.size()>1){\n                    s= s+ q.poll() + sp;\n                }\n                if (q.size()==1)\n                {\n                    s= s+q.poll();\n                }\n                re.add(s);\n                q.add(words[i]);\n\n                count = 0;\n                c= -1;\n                count = count + words[i].length();\n                c++;\n            }\n        }\n        String s = \"\";\n        while (!q.isEmpty()){\n            s = s + q.poll() +\" \";\n        }\n        s = s.substring(0,s.length()-1);\n        while (s.length()<maxWidth){\n            s= s+\" \";\n        }\n\n        re.add(s);\n        for (String i:re){\n            System.out.println(i);\n        }\n        System.out.println(re.get(0).length());\n\n        return re;\n        \n    }\n}","runtime":"N/A","title":"Text Justification","url":"/submissions/detail/1077962591/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1077962591,"time":"3 months, 1 week","lang":"java","title_slug":"text-justification","timestamp":1697589329,"status":11,"is_pending":"Not Pending","compare_result":"11000111111111111110100100011"},{"status_display":"Accepted","memory":"40.2 MB","code":"class Solution {\n    public int strStr(String haystack, String needle) {\n        return haystack.indexOf(needle);\n    }\n}","runtime":"0 ms","title":"Find the Index of the First Occurrence in a String","url":"/submissions/detail/1077930590/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1077930590,"time":"3 months, 1 week","lang":"java","title_slug":"find-the-index-of-the-first-occurrence-in-a-string","timestamp":1697584485,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"40.8 MB","code":"class Solution {\n    public int strStr(String haystack, String needle) {\n        return haystack.indexOf(needle);\n    }\n}","runtime":"0 ms","title":"Find the Index of the First Occurrence in a String","url":"/submissions/detail/1077930522/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1077930522,"time":"3 months, 1 week","lang":"java","title_slug":"find-the-index-of-the-first-occurrence-in-a-string","timestamp":1697584475,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"44.5 MB","code":"class Solution {\n    public String convert(String s, int numRows) {\n        StringBuilder[] st = new StringBuilder[numRows];\n        for (int i = 0;i<numRows;i++) st[i] = new StringBuilder();\n        int count = 0;\n        main:\n        while (count<s.length()){\n            for (int i = 0;i< numRows;i++){\n                if (count >=s.length() ) break main;\n                st[i].append(s.charAt(count));\n                count++;\n            }\n            for (int i = numRows - 2 ; i>=1; i--){\n                if (count >=s.length() ) break main;\n                st[i].append(s.charAt(count));\n                count++;\n            }\n        }\n        StringBuilder re = new StringBuilder();\n        for (StringBuilder si:st){\n            re.append( si.toString() );\n        }\n        return re.toString();\n        \n    }\n}","runtime":"4 ms","title":"Zigzag Conversion","url":"/submissions/detail/1077929824/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1077929824,"time":"3 months, 1 week","lang":"java","title_slug":"zigzag-conversion","timestamp":1697584370,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"44.6 MB","code":"class Solution {\n    public String convert(String s, int numRows) {\n        String []st = new String[numRows];\n        Arrays.fill(st,\"\");\n        int count = 0;\n        main:\n        while (count<s.length()){\n            for (int i = 0;i< numRows;i++){\n                if (count >=s.length() ) break main;\n                st[i] = st[i] + s.charAt(count);\n                count++;\n            }\n            for (int i = numRows - 2 ; i>=1; i--){\n                if (count >=s.length() ) break main;\n                st[i] = st[i] + s.charAt(count);\n                count++;\n            }\n        }\n        String re = \"\";\n        for (String si:st){\n            re= re + si;\n        }\n        return re;\n        \n    }\n}","runtime":"14 ms","title":"Zigzag Conversion","url":"/submissions/detail/1077928086/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1077928086,"time":"3 months, 1 week","lang":"java","title_slug":"zigzag-conversion","timestamp":1697584088,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public String convert(String s, int numRows) {\n        String []st = new String[numRows];\n        // Arrays.fill(st,\"\");\n        int count = 0;\n        main:\n        while (count<s.length()){\n            for (int i = 0;i< numRows;i++){\n                if (count >=s.length() ) break main;\n                st[i] = st[i] + s.charAt(count);\n                count++;\n            }\n            for (int i = numRows - 2 ; i>=1; i--){\n                if (count >=s.length() ) break main;\n                st[i] = st[i] + s.charAt(count);\n                count++;\n            }\n        }\n        String re = \"\";\n        for (String si:st){\n            re= re + si;\n        }\n        return re;\n        \n    }\n}","runtime":"N/A","title":"Zigzag Conversion","url":"/submissions/detail/1077928047/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1077928047,"time":"3 months, 1 week","lang":"java","title_slug":"zigzag-conversion","timestamp":1697584082,"status":11,"is_pending":"Not Pending","compare_result":"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public String convert(String s, int numRows) {\n        String []st = new String[numRows];\n        // Arrays.fill(st,\"\");\n        int count = 0;\n        main:\n        while (count<s.length()){\n            for (int i = 0;i< numRows;i++){\n                if (count >=s.length() ) break main;\n                st[i] = st[i] + s.charAt(count);\n                count++;\n            }\n            for (int i = numRows - 2 ; i>=1; i--){\n                if (count >=s.length() ) break main;\n                st[i] = st[i] + s.charAt(count);\n                count++;\n            }\n        }\n        String re = \"\";\n        for (String si:st){\n            re= re + si;\n        }\n        return re;\n        \n    }\n}","runtime":"N/A","title":"Zigzag Conversion","url":"/submissions/detail/1077927996/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1077927996,"time":"3 months, 1 week","lang":"java","title_slug":"zigzag-conversion","timestamp":1697584073,"status":11,"is_pending":"Not Pending","compare_result":"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"},{"status_display":"Accepted","memory":"44.3 MB","code":"class Solution {\n    public String convert(String s, int numRows) {\n        String []st = new String[numRows];\n        Arrays.fill(st,\"\");\n        int count = 0;\n        main:\n        while (count<s.length()){\n            for (int i = 0;i< numRows;i++){\n                if (count >=s.length() ) break main;\n                st[i] = st[i] + s.charAt(count);\n                count++;\n            }\n            for (int i = numRows - 2 ; i>=1; i--){\n                if (count >=s.length() ) break main;\n                st[i] = st[i] + s.charAt(count);\n                count++;\n            }\n        }\n        String re = \"\";\n        for (String si:st){\n            re= re + si;\n        }\n        return re;\n        \n    }\n}","runtime":"14 ms","title":"Zigzag Conversion","url":"/submissions/detail/1077927917/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1077927917,"time":"3 months, 1 week","lang":"java","title_slug":"zigzag-conversion","timestamp":1697584063,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"43.9 MB","code":"class Solution {\n    public String reverseWords(String s) {\n        String [] temp = s.split(\"\\\\s+\");\n        StringBuilder sb = new StringBuilder();\n        for (int i = temp.length-1; i>=0;i--){\n            // System.out.println(temp[i]);\n            sb.append(temp[i] + \" \");\n        }\n        return sb.toString().trim();\n        \n    }\n}","runtime":"8 ms","title":"Reverse Words in a String","url":"/submissions/detail/1077923764/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1077923764,"time":"3 months, 1 week","lang":"java","title_slug":"reverse-words-in-a-string","timestamp":1697583427,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111"}],"has_next":true,"last_key":"%7B%22pk%22%3A%20%7B%22N%22%3A%20%221077923764%22%7D%2C%20%22dt%22%3A%20%7B%22S%22%3A%20%222023-10-17T22%3A57%3A07.623057%2B0000%22%7D%2C%20%22sid%22%3A%20%7B%22N%22%3A%20%227573785%22%7D%7D"}
2024-01-26 23:02:34.784 [main] DEBUG submission_dump - {"submissions_dump":[{"status_display":"Accepted","memory":"43.7 MB","code":"class Solution {\n    public String reverseWords(String s) {\n        String [] temp = s.split(\"\\\\s+\");\n        StringBuilder sb = new StringBuilder();\n        for (int i = temp.length-1; i>=0;i--){\n            System.out.println(temp[i]);\n            sb.append(temp[i] + \" \");\n        }\n        return sb.toString().trim();\n        \n    }\n}","runtime":"21 ms","title":"Reverse Words in a String","url":"/submissions/detail/1077923727/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1077923727,"time":"3 months, 1 week","lang":"java","title_slug":"reverse-words-in-a-string","timestamp":1697583421,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"40.3 MB","code":"class Solution {\n    public String longestCommonPrefix(String[] strs) {\n        int count = 0;\n        boolean check = true;\n        while (check){\n            if (count>=strs[0].length()) break;\n            char temp = strs[0].charAt(count);\n            for (String st: strs){\n\n                if ( count>=st.length() || st.charAt(count)!=temp){\n                    check = false;\n                    break;\n                }\n            }\n            if (!check) break;\n            count++;\n        }\n        System.out.println(count);\n        return strs[0].substring(0,count);\n    }\n}","runtime":"2 ms","title":"Longest Common Prefix","url":"/submissions/detail/1077913294/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1077913294,"time":"3 months, 1 week","lang":"java","title_slug":"longest-common-prefix","timestamp":1697581877,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"40.7 MB","code":"class Solution {\n    public int lengthOfLastWord(String s) {\n        String [] temp = s.split(\" \");\n        return temp[temp.length-1].length();\n    }\n}","runtime":"1 ms","title":"Length of Last Word","url":"/submissions/detail/1077908823/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1077908823,"time":"3 months, 1 week","lang":"java","title_slug":"length-of-last-word","timestamp":1697581260,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"43.2 MB","code":"class Solution {\n    public String intToRoman(int num) {\n        StringBuilder sb = new StringBuilder();\n        while(  num>=1000){\n            num = num - 1000;\n            sb.append(\"M\");\n        }\n\n        if (num >=900) {\n            num = num - 900;\n            sb.append(\"CM\");\n        }\n        if (num >=500) {\n            num = num - 500;\n            sb.append(\"D\");\n        }\n        if (num >=400) {\n            num = num - 400;\n            sb.append(\"CD\");\n        }\n        while (num >=100){\n            num = num-100;\n            sb.append(\"C\");\n        }\n\n        if (num >=90) {\n            num = num - 90;\n            sb.append(\"XC\");\n        }\n        if (num >=50) {\n            num = num - 50;\n            sb.append(\"L\");\n        }\n        if (num >=40) {\n            num = num - 40;\n            sb.append(\"XL\");\n        }\n        while (num >=10){\n            num = num-10;\n            sb.append(\"X\");\n        }\n\n        if (num >=9) {\n            num = num - 9;\n            sb.append(\"IX\");\n        }\n        if (num >=5) {\n            num = num - 5;\n            sb.append(\"V\");\n        }\n        if (num >=4) {\n            num = num - 4;\n            sb.append(\"IV\");\n        }\n        while (num >=1){\n            num = num-1;\n            sb.append(\"I\");\n        }\n        return sb.toString();\n        \n    }\n}","runtime":"2 ms","title":"Integer to Roman","url":"/submissions/detail/1077907368/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1077907368,"time":"3 months, 1 week","lang":"java","title_slug":"integer-to-roman","timestamp":1697581058,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public String intToRoman(int num) {\n        StringBuilder sb = new StringBuilder();\n        while(  num>=1000){\n            num = num - 1000;\n            sb.append(\"M\");\n        }\n\n        if (num >=900) {\n            num = num - 900;\n            sb.append(\"CM\");\n        }\n        if (num >=500) {\n            num = num - 900;\n            sb.append(\"D\");\n        }\n        if (num >=400) {\n            num = num - 400;\n            sb.append(\"CD\");\n        }\n        while (num >=100){\n            num = num-100;\n            sb.append(\"C\");\n        }\n\n        if (num >=90) {\n            num = num - 90;\n            sb.append(\"XC\");\n        }\n        if (num >=50) {\n            num = num - 50;\n            sb.append(\"L\");\n        }\n        if (num >=40) {\n            num = num - 40;\n            sb.append(\"XL\");\n        }\n        while (num >=10){\n            num = num-10;\n            sb.append(\"X\");\n        }\n\n        if (num >=9) {\n            num = num - 9;\n            sb.append(\"IX\");\n        }\n        if (num >=5) {\n            num = num - 5;\n            sb.append(\"V\");\n        }\n        if (num >=4) {\n            num = num - 4;\n            sb.append(\"IV\");\n        }\n        while (num >=1){\n            num = num-1;\n            sb.append(\"I\");\n        }\n        return sb.toString();\n        \n    }\n}","runtime":"N/A","title":"Integer to Roman","url":"/submissions/detail/1077907232/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1077907232,"time":"3 months, 1 week","lang":"java","title_slug":"integer-to-roman","timestamp":1697581042,"status":11,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public String intToRoman(int num) {\n        StringBuilder sb = new StringBuilder();\n        while(  num>=1000){\n            num = num - 1000;\n            sb.append(\"M\");\n        }\n\n        if (num >=900) {\n            num = num - 900;\n            sb.append(\"CM\");\n        }\n        if (num >=500) {\n            num = num - 900;\n            sb.append(\"D\");\n        }\n        if (num >=400) {\n            num = num - 400;\n            sb.append(\"CD\");\n        }\n        while (num >=100){\n            num = num-100;\n            sb.append(\"C\");\n        }\n\n        if (num >=90) {\n            num = num - 90;\n            sb.append(\"XC\");\n        }\n        if (num >=50) {\n            num = num - 50;\n            sb.append(\"L\");\n        }\n        if (num >=40) {\n            num = num - 400;\n            sb.append(\"XL\");\n        }\n        while (num >=10){\n            num = num-10;\n            sb.append(\"X\");\n        }\n\n        if (num >=9) {\n            num = num - 9;\n            sb.append(\"IX\");\n        }\n        if (num >=5) {\n            num = num - 5;\n            sb.append(\"V\");\n        }\n        if (num >=4) {\n            num = num - 4;\n            sb.append(\"IV\");\n        }\n        while (num >=1){\n            num = num-1;\n            sb.append(\"I\");\n        }\n        return sb.toString();\n        \n    }\n}","runtime":"N/A","title":"Integer to Roman","url":"/submissions/detail/1077907042/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1077907042,"time":"3 months, 1 week","lang":"java","title_slug":"integer-to-roman","timestamp":1697581017,"status":11,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000000001111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000000111111111111111111111111111111111111111111111111111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000111111111111111111111111111111111111111110000000001111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000000001111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000011111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011111111111111111111111111111111111111111000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000000001111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000011111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011111111111111111111111111111111111111111000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000000001111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000000001111111111111111111111111111111111111111111111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001111111111111111111111111111111111111111100000000011111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"44.3 MB","code":"class Solution {\n    public int trap(int[] r) {\n        int n = r.length;\n        int max = 0;\n        int sum = 0;\n        int [] left = new int[n];\n        int [] right = new int[n];\n        for (int i=0;i<n;i++){\n            if (r[i]>max){\n                max = r[i];\n                left[i] = 0;\n            } else{\n                left[i] = max- r[i];\n            }\n        }\n        max = 0;\n        for (int i=n-1;i>=0;i--){\n            if (r[i]>max){\n                max = r[i];\n                right[i] = 0;\n            }\n            else{\n                right[i] = max-r[i];\n            }\n        }\n        for (int i = 0;i<n;i++){\n            sum = sum + Integer.min(left[i],right[i]);\n        }\n        \n        return sum;\n        \n    }\n}","runtime":"1 ms","title":"Trapping Rain Water","url":"/submissions/detail/1077167694/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1077167694,"time":"3 months, 1 week","lang":"java","title_slug":"trapping-rain-water","timestamp":1697511241,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"44.4 MB","code":"class Solution {\n    public int trap(int[] r) {\n        int n = r.length;\n        int max = 0;\n        int sum = 0;\n        int [] left = new int[n];\n        int [] right = new int[n];\n        for (int i=0;i<n;i++){\n            if (r[i]>max){\n                max = r[i];\n                // temp = i;\n                left[i] = 0;\n            } else{\n                left[i] = max- r[i];\n                // sum = sum + max-r[i];\n            }\n        }\n        max = 0;\n        for (int i=n-1;i>=0;i--){\n            if (r[i]>max){\n                max = r[i];\n                right[i] = 0;\n            }\n            else{\n                right[i] = max-r[i];\n            }\n        }\n        for (int i = 0;i<n;i++){\n            // System.out.println(left[i] + \" \" + right[i]);\n            sum = sum + Integer.min(left[i],right[i]);\n        }\n        \n        return sum;\n        \n    }\n}","runtime":"1 ms","title":"Trapping Rain Water","url":"/submissions/detail/1077164357/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1077164357,"time":"3 months, 1 week","lang":"java","title_slug":"trapping-rain-water","timestamp":1697510873,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"43.7 MB","code":"class Solution {\n    public int trap(int[] r) {\n        int n = r.length;\n        int ind = 0;\n        int max = 0;\n        int sum = 0;\n        int min = Integer.MAX_VALUE;\n        int temp = -1;\n        int [] left = new int[n];\n        int [] right = new int[n];\n        for (int i=0;i<n;i++){\n            if (r[i]>max){\n                max = r[i];\n                // temp = i;\n                left[i] = 0;\n            } else{\n                left[i] = max- r[i];\n                // sum = sum + max-r[i];\n            }\n        }\n        max = 0;\n        for (int i=n-1;i>=0;i--){\n            if (r[i]>max){\n                max = r[i];\n                right[i] = 0;\n            }\n            else{\n                right[i] = max-r[i];\n            }\n        }\n        for (int i = 0;i<n;i++){\n            // System.out.println(left[i] + \" \" + right[i]);\n            sum = sum + Integer.min(left[i],right[i]);\n        }\n        \n        return sum;\n        \n    }\n}","runtime":"1 ms","title":"Trapping Rain Water","url":"/submissions/detail/1077163814/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1077163814,"time":"3 months, 1 week","lang":"java","title_slug":"trapping-rain-water","timestamp":1697510806,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"52.9 MB","code":"class Solution {\n    public int[] productExceptSelf(int[] nums) {\n        int [] re = new int [nums.length];\n        // Array.fills(1);\n        int left = 1;\n        re[0] = 1;\n        for (int i = 1;i<nums.length;i++){\n            left = left*nums[i-1];\n            re[i] = left;\n        }\n        int right = 1;\n        for (int i = nums.length-2;i>=0;i--){\n            right = right*nums[i+1];\n            re [i] = re[i]*right;\n        }\n        return re;\n    }\n}","runtime":"2 ms","title":"Product of Array Except Self","url":"/submissions/detail/1077078915/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1077078915,"time":"3 months, 1 week","lang":"java","title_slug":"product-of-array-except-self","timestamp":1697499422,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111"},{"status_display":"Accepted","memory":"92.5 MB","code":"class RandomizedSet {\n    HashMap<Integer,Integer> map;\n    ArrayList<Integer> list;\n    public RandomizedSet() {\n        map = new HashMap<>();\n        list= new ArrayList<>();\n    }\n    \n    public boolean insert(int val) {\n        if (map.containsKey(val)) return false;\n        map.put(val,list.size());\n        list.add(val);\n        return true;\n    }\n    \n    public boolean remove(int val) {\n        if (!map.containsKey(val)) return false;\n        int temp = list.remove(list.size()-1);\n        if (temp!=val){\n            list.set(map.get(val),temp);\n            map.put(temp,map.get(val));\n        }\n        map.remove(val);\n        return true;\n    }\n    \n    public int getRandom() {\n        return list.get(new Random().nextInt(list.size()));\n        \n    }\n}\n\n/**\n * Your RandomizedSet object will be instantiated and called as such:\n * RandomizedSet obj = new RandomizedSet();\n * boolean param_1 = obj.insert(val);\n * boolean param_2 = obj.remove(val);\n * int param_3 = obj.getRandom();\n */","runtime":"29 ms","title":"Insert Delete GetRandom O(1)","url":"/submissions/detail/1077076182/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1077076182,"time":"3 months, 1 week","lang":"java","title_slug":"insert-delete-getrandom-o1","timestamp":1697499004,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111"},{"status_display":"Accepted","memory":"84.9 MB","code":"class RandomizedSet {\n    HashMap<Integer,Integer> map;\n    ArrayList<Integer> list;\n    public RandomizedSet() {\n        map = new HashMap<>();\n        list= new ArrayList<>();\n    }\n    \n    public boolean insert(int val) {\n        if (map.containsKey(val)) return false;\n        map.put(val,list.size());\n        list.add(val);\n        return true;\n    }\n    \n    public boolean remove(int val) {\n        if (!map.containsKey(val)) return false;\n        int temp = list.remove(list.size()-1);\n        if (temp!=val){\n            list.set(map.get(val),temp);\n            map.put(temp,map.get(val));\n        }\n        map.remove(val);\n        return true;\n    }\n    \n    public int getRandom() {\n        return list.get(new Random().nextInt(list.size()));\n        \n    }\n}\n\n/**\n * Your RandomizedSet object will be instantiated and called as such:\n * RandomizedSet obj = new RandomizedSet();\n * boolean param_1 = obj.insert(val);\n * boolean param_2 = obj.remove(val);\n * int param_3 = obj.getRandom();\n */","runtime":"29 ms","title":"Insert Delete GetRandom O(1)","url":"/submissions/detail/1077076084/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1077076084,"time":"3 months, 1 week","lang":"java","title_slug":"insert-delete-getrandom-o1","timestamp":1697498992,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111"},{"status_display":"Accepted","memory":"44.2 MB","code":"class Solution {\n    public boolean canJump(int[] nums) {\n        int n = nums.length;\n        if (n==1) return true;\n        if (nums[0]==0) return false;\n        int max = 0;\n        for (int i=0;i<n;i++){\n            if (i>max) return false;\n            if (max<i+nums[i]) max = i+nums[i];\n        }\n        return true;\n\n        \n    }\n}","runtime":"2 ms","title":"Jump Game","url":"/submissions/detail/1077070761/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1077070761,"time":"3 months, 1 week","lang":"java","title_slug":"jump-game","timestamp":1697498205,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"43.6 MB","code":"class Solution {\n    public int maxProfit(int[] prices) {\n        int count = 0;\n        int re = 0;\n        int ind = 0;\n        int n = prices.length;\n        while (ind<n){\n            while (ind <n-1 && prices[ind]>prices[ind+1]) ind++;\n            int temp = ind;\n            if (temp == n-1) break;\n            while (ind < n-1 && prices[ind]<=prices[ind+1]) ind++;\n            re = re + prices[ind] - prices[temp];\n            if (ind == n-1) break;\n            ind++;\n        }\n\n        return re;\n    }\n}","runtime":"1 ms","title":"Best Time to Buy and Sell Stock II","url":"/submissions/detail/1077067643/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1077067643,"time":"3 months, 1 week","lang":"java","title_slug":"best-time-to-buy-and-sell-stock-ii","timestamp":1697497759,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"55.3 MB","code":"class Solution {\n    public void rotate(int[] nums, int k) {\n        k = k % nums.length;\n\t\trev(nums,0,nums.length-1);\n\t\trev(nums,0,k-1);\n\t\trev(nums,k,nums.length-1);\n    }\n    void rev(int [] nums, int x, int y) {\n\t\t\n\t\twhile (x< y) {\n\t\t\tint temp = nums[x];\n\t\t\tnums[x] = nums[y];\n\t\t\tnums[y] = temp;\n\t\t\tx ++;\n\t\t\ty --;\n\t\t}\n\t}\n}","runtime":"0 ms","title":"Rotate Array","url":"/submissions/detail/1077062343/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1077062343,"time":"3 months, 1 week","lang":"java","title_slug":"rotate-array","timestamp":1697496996,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"43.4 MB","code":"class Solution {\n    public int romanToInt(String s) {\n        char [] c = s.toCharArray();\n        HashMap<Character,Integer> m = new HashMap<>();\n        m.put('I',1);\n        m.put('V',5);\n        m.put('X',10);\n        m.put('L',50);\n        m.put('C',100);\n        m.put('D',500);\n        m.put('M',1000);\n        int n = c.length;\n        int prev = 0;\n        int sum = 0;\n        for (int i = n-1;i>=0;i--){\n            int cur = m.get(c[i]);\n            if (cur>=prev) sum = sum+m.get(c[i]);\n            else sum = sum - m.get(c[i]);\n            prev= cur; \n        }\n        return sum;\n    }\n}","runtime":"4 ms","title":"Roman to Integer","url":"/submissions/detail/1077061850/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1077061850,"time":"3 months, 1 week","lang":"java","title_slug":"roman-to-integer","timestamp":1697496929,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"44.1 MB","code":"class Solution {\n    public int removeDuplicates(int[] nums) {\n        int p1 = 0;\n        int n = nums.length;\n        int p2 = 0;\n        while (p2<n){\n            int count = 1;\n            while (p2<n-1&&nums[p2]==nums[p2+1]){\n                if (count<3)\n                {\n                    nums[p1] = nums[p2];\n                    p1++;\n                }                \n                count++;\n                p2++;\n            }\n            if (count<3){\n                nums[p1] = nums[p2];\n                p1++;\n                p2++;\n            } else{\n                p2++;\n            }\n\n        }\n        \n        return p1;       \n    }\n}","runtime":"0 ms","title":"Remove Duplicates from Sorted Array II","url":"/submissions/detail/1077056614/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1077056614,"time":"3 months, 1 week","lang":"java","title_slug":"remove-duplicates-from-sorted-array-ii","timestamp":1697496200,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"39.9 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    \n    int prev =-100001;\n    int min = Integer.MAX_VALUE;\n    public int minDiffInBST(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        minDiffInBST(root.left);\n        int val = root.val - prev;\n        if (val<min) min = val;\n        prev = root.val;\n        // System.out.println(root.val);\n        minDiffInBST(root.right);\n        \n        return min;\n        \n    }\n}","runtime":"0 ms","title":"Minimum Distance Between BST Nodes","url":"/submissions/detail/1077027033/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1077027033,"time":"3 months, 1 week","lang":"java","title_slug":"minimum-distance-between-bst-nodes","timestamp":1697492248,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"43.4 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int prev =-100001;\n    int min = Integer.MAX_VALUE;\n    public int getMinimumDifference(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        getMinimumDifference(root.left);\n        int val = root.val - prev;\n        if (val<min) min = val;\n        prev = root.val;\n        // System.out.println(root.val);\n        getMinimumDifference(root.right);\n        \n        return min;\n        \n    }\n}","runtime":"0 ms","title":"Minimum Absolute Difference in BST","url":"/submissions/detail/1076542721/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076542721,"time":"3 months, 1 week","lang":"java","title_slug":"minimum-absolute-difference-in-bst","timestamp":1697448133,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int searchInsert(int[] nums, int target) {\n        return search(nums,target,0,nums.length);\n    }\n    public int search(int [] nums, int t, int l, int r){\n        System.out.println(l+ \" \"+ r);\n        if (l<0) return 0;\n        if (r>nums.length) return nums.length;\n        if (l == r) return l;\n        if (l>r) return l;\n        int mid =  l + (r-l)/2;\n        if (nums[mid]<t) return search(nums,t,mid+1,r);\n        if (nums[mid]>t) return search(nums,t,l,mid-1);\n        return mid;\n\n    }\n}","runtime":"N/A","title":"Search Insert Position","url":"/submissions/detail/1076521255/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076521255,"time":"3 months, 1 week","lang":"java","title_slug":"search-insert-position","timestamp":1697445813,"status":11,"is_pending":"Not Pending","compare_result":"11111111101111011111111110111111001111110111111111111111111101111"}],"has_next":true,"last_key":"%7B%22pk%22%3A%20%7B%22N%22%3A%20%221076521255%22%7D%2C%20%22dt%22%3A%20%7B%22S%22%3A%20%222023-10-16T08%3A43%3A33.120114%2B0000%22%7D%2C%20%22sid%22%3A%20%7B%22N%22%3A%20%227573785%22%7D%7D"}
2024-01-26 23:02:45.231 [main] DEBUG submission_dump - {"submissions_dump":[{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int searchInsert(int[] nums, int target) {\n        return search(nums,target,0,nums.length);\n    }\n    public int search(int [] nums, int t, int l, int r){\n        System.out.println(l+ \" \"+ r);\n        if (l<0) return 0;\n        if (r>nums.length) return nums.length;\n        if (l>=r) return l;\n        int mid =  l + (r-l)/2;\n        if (nums[mid]<t) return search(nums,t,mid+1,r);\n        if (nums[mid]>t) return search(nums,t,l,mid-1);\n        return mid;\n\n    }\n}","runtime":"N/A","title":"Search Insert Position","url":"/submissions/detail/1076521133/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076521133,"time":"3 months, 1 week","lang":"java","title_slug":"search-insert-position","timestamp":1697445797,"status":11,"is_pending":"Not Pending","compare_result":"11111111101111011111111110111111001111110111111111111111111101111"},{"status_display":"Runtime Error","memory":"N/A","code":"class Solution {\n    public int searchInsert(int[] nums, int target) {\n        return search(nums,target,0,nums.length);\n    }\n    public int search(int [] nums, int t, int l, int r){\n        System.out.println(l+ \" \"+ r);\n        if (l<0) return 0;\n        if (r>nums.length) return nums.length;\n        if (l>r) return l;\n        int mid =  l + (r-l)/2;\n        if (nums[mid]<t) return search(nums,t,mid+1,r);\n        if (nums[mid]>t) return search(nums,t,l,mid-1);\n        return mid;\n\n    }\n}","runtime":"N/A","title":"Search Insert Position","url":"/submissions/detail/1076521041/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076521041,"time":"3 months, 1 week","lang":"java","title_slug":"search-insert-position","timestamp":1697445788,"status":15,"is_pending":"Not Pending","compare_result":"11000000000000000000000000000000000000000000000000000000000000000"},{"status_display":"Accepted","memory":"43.8 MB","code":"class Solution {\n    public int searchInsert(int[] nums, int target) {\n        return search(nums,target,0,nums.length-1);\n    }\n    public int search(int [] nums, int t, int l, int r){\n        System.out.println(l+ \" \"+ r);\n        if (l>r) return l;\n        int mid =  l + (r-l)/2;\n        if (nums[mid]<t) return search(nums,t,mid+1,r);\n        if (nums[mid]>t) return search(nums,t,l,mid-1);\n        return mid;\n\n    }\n}","runtime":"8 ms","title":"Search Insert Position","url":"/submissions/detail/1076519550/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076519550,"time":"3 months, 1 week","lang":"java","title_slug":"search-insert-position","timestamp":1697445626,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int searchInsert(int[] nums, int target) {\n        return search(nums,target,0,nums.length);\n    }\n    public int search(int [] nums, int t, int l, int r){\n        System.out.println(l+ \" \"+ r);\n        if (r>nums.length) return nums.length;\n        if (l == r) return l;\n        if (l>r) return l;\n        int mid =  l + (r-l)/2;\n        if (nums[mid]<t) return search(nums,t,mid+1,r);\n        if (nums[mid]>t) return search(nums,t,l,mid-1);\n        return mid;\n\n    }\n}","runtime":"N/A","title":"Search Insert Position","url":"/submissions/detail/1076519066/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076519066,"time":"3 months, 1 week","lang":"java","title_slug":"search-insert-position","timestamp":1697445573,"status":11,"is_pending":"Not Pending","compare_result":"11111111101111011111111110111111001111110111111111111111111101111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int searchInsert(int[] nums, int target) {\n        return search(nums,target,0,nums.length);\n    }\n    public int search(int [] nums, int t, int l, int r){\n        System.out.println(l+ \" \"+ r);\n        if (l<0) return 0;\n        if (r>nums.length) return nums.length;\n        if (l == r) return l;\n        if (l>r) return l;\n        int mid =  l + (r-l)/2;\n        if (nums[mid]<t) return search(nums,t,mid+1,r);\n        if (nums[mid]>t) return search(nums,t,l,mid-1);\n        return mid;\n\n    }\n}","runtime":"N/A","title":"Search Insert Position","url":"/submissions/detail/1076517979/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076517979,"time":"3 months, 1 week","lang":"java","title_slug":"search-insert-position","timestamp":1697445450,"status":11,"is_pending":"Not Pending","compare_result":"11111111101111011111111110111111001111110111111111111111111101111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int searchInsert(int[] nums, int target) {\n        return search(nums,target,0,nums.length);\n    }\n    public int search(int [] nums, int t, int l, int r){\n        System.out.println(l+ \" \"+ r);\n        if (l<0) return 0;\n        if (r>nums.length) return nums.length;\n        if (l == r) return l;\n        if (l>r) return r;\n        int mid =  l + (r-l)/2;\n        if (nums[mid]<t) return search(nums,t,mid+1,r);\n        if (nums[mid]>t) return search(nums,t,l,mid-1);\n        return mid;\n\n    }\n}","runtime":"N/A","title":"Search Insert Position","url":"/submissions/detail/1076517629/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076517629,"time":"3 months, 1 week","lang":"java","title_slug":"search-insert-position","timestamp":1697445414,"status":11,"is_pending":"Not Pending","compare_result":"11100111101111010110111010101111001111110111111111010111111101101"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int searchInsert(int[] nums, int target) {\n        return search(nums,target,0,nums.length);\n    }\n    public int search(int [] nums, int t, int l, int r){\n        System.out.println(l+ \" \"+ r);\n        if (l == r) return l;\n        if (l>r) return r;\n        int mid =  l + (r-l)/2;\n        if (nums[mid]<t) return search(nums,t,mid+1,r);\n        if (nums[mid]>t) return search(nums,t,l,mid-1);\n        return mid;\n\n    }\n}","runtime":"N/A","title":"Search Insert Position","url":"/submissions/detail/1076517020/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076517020,"time":"3 months, 1 week","lang":"java","title_slug":"search-insert-position","timestamp":1697445350,"status":11,"is_pending":"Not Pending","compare_result":"11100111101111010110111010101111001111110111111111010111111101101"},{"status_display":"Accepted","memory":"44.3 MB","code":"class Solution {\n    public int singleNumber(int[] nums) {\n        int re = 0;\n        for (int i: nums) re = re^i;\n        return re;\n    }\n}","runtime":"1 ms","title":"Single Number","url":"/submissions/detail/1076489271/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076489271,"time":"3 months, 1 week","lang":"java","title_slug":"single-number","timestamp":1697442082,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"42.7 MB","code":"class Solution {\n    public boolean isPalindrome(int x) {\n        if (x<0) return false;\n        return x == rev(x);\n    }\n    public int rev(int x){\n        int re = 0;\n        \n        while (x!=0){\n            re = 10*re + x %10;\n            x = x/10;\n        }\n        return re;\n    }\n}","runtime":"5 ms","title":"Palindrome Number","url":"/submissions/detail/1076486538/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076486538,"time":"3 months, 1 week","lang":"java","title_slug":"palindrome-number","timestamp":1697441777,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"41.1 MB","code":"class Solution {\n    public int[] plusOne(int[] digits) {\n        int n = digits.length;\n        LinkedList<Integer> re = new LinkedList<>();\n        int i = n-1;\n        int left = 1;\n        while (i>=0){\n            if (digits[i] + left >9 ){\n                left = 1;\n                re.addFirst(0);\n            } else{\n                re.addFirst(digits[i]+left);\n                left = 0;\n            }\n            i--;\n        }\n        if (left==1) re.addFirst(1);\n        int re1 [] = new int[re.size()];\n        int count = 0;\n        for (int val:re){\n            re1[count] = val;\n            count++;\n        }\n        return re1;\n    }\n}","runtime":"1 ms","title":"Plus One","url":"/submissions/detail/1076485171/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076485171,"time":"3 months, 1 week","lang":"java","title_slug":"plus-one","timestamp":1697441614,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"41.2 MB","code":"class Solution {\n    public int[] plusOne(int[] digits) {\n        int n = digits.length;\n        LinkedList<Integer> re = new LinkedList<>();\n        int i = n-1;\n        int left = 1;\n        while (i>=0){\n            if (digits[i] + left >9 ){\n                left = 1;\n                re.addFirst(0);\n            } else{\n                re.addFirst(digits[i]+left);\n                left = 0;\n            }\n            i--;\n        }\n        if (left==1) re.addFirst(1);\n        int re1 [] = new int[re.size()];\n        int count = 0;\n        for (int val:re){\n            re1[count] = val;\n            count++;\n        }\n        return re1;\n    }\n}","runtime":"1 ms","title":"Plus One","url":"/submissions/detail/1076485095/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076485095,"time":"3 months, 1 week","lang":"java","title_slug":"plus-one","timestamp":1697441605,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"40.2 MB","code":"class Solution {\n    public int mySqrt(int x) {\n        long r = x;\n        while (r*r > x)\n            r = (r + x/r) / 2;\n        return (int) r;\n    }\n}","runtime":"1 ms","title":"Sqrt(x)","url":"/submissions/detail/1076478896/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076478896,"time":"3 months, 1 week","lang":"java","title_slug":"sqrtx","timestamp":1697440925,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"61.6 MB","code":"class Solution {\n    public int maxProfit(int[] prices) {\n        int runMin = Integer.MAX_VALUE;\n        int max = 0;\n        for (int i:prices){\n            if (i>runMin){\n                if (i-runMin > max) max = i - runMin;\n            }\n            if (i<runMin){\n                runMin = i;\n            }\n        }\n        return max;\n    }\n}","runtime":"2 ms","title":"Best Time to Buy and Sell Stock","url":"/submissions/detail/1076469419/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076469419,"time":"3 months, 1 week","lang":"java","title_slug":"best-time-to-buy-and-sell-stock","timestamp":1697439960,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"48.2 MB","code":"class Solution {\n    public int majorityElement(int[] nums) {\n        int candidate = 0;\n        int freq = 0;\n        for (int i: nums){\n            if (i!=candidate) freq--;\n            else freq++;\n            if (freq<0) {\n                candidate = i;\n                freq = 1;\n            }\n\n        }\n        return candidate;\n        \n    }\n}","runtime":"1 ms","title":"Majority Element","url":"/submissions/detail/1076465295/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076465295,"time":"3 months, 1 week","lang":"java","title_slug":"majority-element","timestamp":1697439566,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"44 MB","code":"class Solution {\n    public int removeDuplicates(int[] nums) {\n        int p1 = 0;\n        int n = nums.length;\n        int p2 = 0;\n        while (p2<n){\n            while (p2<n-1 && nums[p2]==nums[p2+1]){\n                p2++;\n            } \n            nums[p1] = nums[p2];\n            p1++;\n            p2++;\n        }\n        return p1;\n\n        \n    }\n}","runtime":"1 ms","title":"Remove Duplicates from Sorted Array","url":"/submissions/detail/1076461449/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076461449,"time":"3 months, 1 week","lang":"java","title_slug":"remove-duplicates-from-sorted-array","timestamp":1697439202,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"46.3 MB","code":"class Solution {\n    public int removeDuplicates(int[] nums) {\n        int p1 = 0;\n        int n = nums.length;\n        int p2 = 0;\n        // int count = 0;\n        while (p2<n){\n            while (p2<n-1 && nums[p2]==nums[p2+1]){\n                p2++;\n            } \n            System.out.println(p1 +\" \" + p2);\n\n            nums[p1] = nums[p2];\n            p1++;\n            p2++;\n            // count++;\n        }\n        // System.out.println(p1);\n        return p1;\n\n        \n    }\n}","runtime":"23 ms","title":"Remove Duplicates from Sorted Array","url":"/submissions/detail/1076461200/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076461200,"time":"3 months, 1 week","lang":"java","title_slug":"remove-duplicates-from-sorted-array","timestamp":1697439179,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"43 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n\n    public boolean hasPathSum(TreeNode root, int targetSum) {\n        if (root == null){\n            return false;\n        }\n        return hasPathSum1(root, targetSum);        \n    }\n    public boolean hasPathSum1(TreeNode root, int targetSum) {\n        if (root == null){\n            if (targetSum == 0) return true;\n            return false;\n        }\n        if (root.left == null) return hasPathSum1(root.right, targetSum-root.val);\n        if (root.right == null) return hasPathSum1(root.left, targetSum-root.val);\n\n        return hasPathSum1(root.left, targetSum-root.val) || hasPathSum1(root.right, targetSum-root.val);        \n    }\n}","runtime":"0 ms","title":"Path Sum","url":"/submissions/detail/1076454742/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076454742,"time":"3 months, 1 week","lang":"java","title_slug":"path-sum","timestamp":1697438589,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n\n    public boolean hasPathSum(TreeNode root, int targetSum) {\n        if (root == null){\n            return false;\n        }\n        return hasPathSum1(root, targetSum);        \n    }\n    public boolean hasPathSum1(TreeNode root, int targetSum) {\n        if (root == null){\n            if (targetSum == 0) return true;\n            return false;\n        }\n        return hasPathSum1(root.left, targetSum-root.val) || hasPathSum1(root.right, targetSum-root.val);        \n    }\n}","runtime":"N/A","title":"Path Sum","url":"/submissions/detail/1076452529/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076452529,"time":"3 months, 1 week","lang":"java","title_slug":"path-sum","timestamp":1697438380,"status":11,"is_pending":"Not Pending","compare_result":"111111110111011111111101011101011111111010111101111111101111111011111111101111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"40.4 MB","code":"class Solution {\n    public int removeElement(int[] nums, int val) {\n        int count = 0;\n        int n = nums.length;\n        for (int i = 0;i<n;i++){\n            if (nums[i]!=val){\n                nums[count] = nums[i];\n                count++;\n            }\n        }\n        return count;\n    }\n}","runtime":"0 ms","title":"Remove Element","url":"/submissions/detail/1076449732/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076449732,"time":"3 months, 1 week","lang":"java","title_slug":"remove-element","timestamp":1697438109,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"40.9 MB","code":"class Solution {\n    public int removeElement(int[] nums, int val) {\n        int count = 0;\n        int n = nums.length;\n        for (int i=0;i<n;i++){\n            if (nums[i] != val){\n                count++;\n            }\n        }\n        for (int i = 0; i< n-1;i++){\n            if (nums[i] == val){\n                for (int j=i+1;j<n;j++){\n                    if (nums[j]!= val){\n                        nums[i] = nums[j];\n                        nums[j] = val;\n                        break;\n                    }\n                }\n            }\n        }\n        return count;\n    }\n}","runtime":"0 ms","title":"Remove Element","url":"/submissions/detail/1076447445/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076447445,"time":"3 months, 1 week","lang":"java","title_slug":"remove-element","timestamp":1697437883,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}],"has_next":true,"last_key":"%7B%22pk%22%3A%20%7B%22N%22%3A%20%221076447445%22%7D%2C%20%22dt%22%3A%20%7B%22S%22%3A%20%222023-10-16T06%3A31%3A23.918126%2B0000%22%7D%2C%20%22sid%22%3A%20%7B%22N%22%3A%20%227573785%22%7D%7D"}
2024-01-26 23:02:55.845 [main] DEBUG submission_dump - {"submissions_dump":[{"status_display":"Accepted","memory":"40.6 MB","code":"class Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        int p1 = m - 1;\n        int p2 = n-1;\n        int p = n+m-1;\n        while (p1>=0 && p2>=0){\n            \n            if (nums1[p1]>nums2[p2]){\n                nums1[p] = nums1[p1];\n                p1--;\n                p--;\n            } else if (nums2[p2]>nums1[p1]){\n                nums1[p] = nums2[p2];\n                p2--;\n                p--;\n            } else{\n                nums1[p] = nums1[p1];\n                p1--;\n                p--;\n                nums1[p] = nums2[p2];\n                p2--;\n                p--;\n            }\n        }\n        while (p2>=0){\n            nums1[p] = nums2[p2];\n            p2--;\n            p--;\n        } \n        while (p1>=0){\n            nums1[p] = nums1[p1];\n            p1--;\n            p--;\n        } \n        \n    }\n}","runtime":"0 ms","title":"Merge Sorted Array","url":"/submissions/detail/1076439592/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076439592,"time":"3 months, 1 week","lang":"java","title_slug":"merge-sorted-array","timestamp":1697437150,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"40.6 MB","code":"class Solution {\n    HashSet<String> set ;\n    HashSet<String> notSet ;\n\n    public boolean wordBreak(String s, List<String> wordDict) {\n        set= new HashSet<>(wordDict);\n        notSet= new HashSet<>();\n        if (set.contains(s)) return true;\n        return check(s);\n        \n    }\n\n    boolean check(String s){\n        // if (index >= s.length) return true;\n        if (s==\"\") return true;\n        if (set.contains(s)) return true;\n        if (notSet.contains(s)) return false;\n        for (String si: set){\n            if (s.startsWith(si)){\n                // System.out.println(si+\" \"+s.substring(si.length()));\n                if (check(s.substring(si.length()))) return true;\n                else notSet.add(s);\n            }\n        }\n        if (!notSet.contains(s))\n            notSet.add(s);\n        return false;\n    }\n}","runtime":"2 ms","title":"Word Break","url":"/submissions/detail/1076420906/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076420906,"time":"3 months, 1 week","lang":"java","title_slug":"word-break","timestamp":1697435382,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"40.9 MB","code":"class Solution {\n    HashSet<String> set ;\n    HashSet<String> notSet ;\n\n    public boolean wordBreak(String s, List<String> wordDict) {\n        set= new HashSet<>(wordDict);\n        notSet= new HashSet<>();\n        if (set.contains(s)) return true;\n        return check(s);\n        \n    }\n\n    boolean check(String s){\n        // if (index >= s.length) return true;\n        if (s==\"\") return true;\n        if (set.contains(s)) return true;\n        if (notSet.contains(s)) return false;\n        for (String si: set){\n            if (s.startsWith(si)){\n                // System.out.println(si+\" \"+s.substring(si.length()));\n                if (check(s.substring(si.length()))) return true;\n                else notSet.add(s);\n            }\n        }\n        notSet.add(s);\n        return false;\n    }\n}","runtime":"3 ms","title":"Word Break","url":"/submissions/detail/1076420656/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076420656,"time":"3 months, 1 week","lang":"java","title_slug":"word-break","timestamp":1697435360,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"41.3 MB","code":"class Solution {\n    HashSet<String> set ;\n    HashSet<String> notSet ;\n\n    public boolean wordBreak(String s, List<String> wordDict) {\n        set= new HashSet<>(wordDict);\n        notSet= new HashSet<>();\n        if (set.contains(s)) return true;\n        return check(s);\n        \n    }\n\n    boolean check(String s){\n        // if (index >= s.length) return true;\n        if (s==\"\") return true;\n        if (set.contains(s)) return true;\n        if (notSet.contains(s)) return false;\n        for (String si: set){\n            if (s.startsWith(si)){\n                // System.out.println(si+\" \"+s.substring(si.length()));\n                if (check(s.substring(si.length()))) return true;\n                else notSet.add(s);\n            }\n        }\n        return false;\n    }\n}","runtime":"2 ms","title":"Word Break","url":"/submissions/detail/1076419392/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076419392,"time":"3 months, 1 week","lang":"java","title_slug":"word-break","timestamp":1697435244,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111"},{"status_display":"Time Limit Exceeded","memory":"N/A","code":"class Solution {\n    HashSet<String> set ;\n\n    public boolean wordBreak(String s, List<String> wordDict) {\n        set= new HashSet<>(wordDict);\n        // notSet= new HashSet<>();\n        if (set.contains(s)) return true;\n        return check(s);\n        \n    }\n\n    boolean check(String s){\n        // if (index >= s.length) return true;\n        if (s==\"\") return true;\n        if (set.contains(s)) return true;\n        for (String si: set){\n            if (s.startsWith(si)){\n                // System.out.println(si+\" \"+s.substring(si.length()));\n                if (check(s.substring(si.length()))) return true;\n            }\n        }\n        return false;\n    }\n}","runtime":"N/A","title":"Word Break","url":"/submissions/detail/1076417033/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076417033,"time":"3 months, 1 week","lang":"java","title_slug":"word-break","timestamp":1697435024,"status":14,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111100000000000"},{"status_display":"Accepted","memory":"45.7 MB","code":"class Solution {\n    HashSet<String> set ;\n    HashSet<String> notSet;\n    public boolean wordBreak(String s, List<String> wordDict) {\n        set= new HashSet<>(wordDict);\n        notSet= new HashSet<>();\n\n        if (set.contains(s)) return true;\n        \n\n        return check(s);\n        \n    }\n\n    boolean check(String s){\n        if (set.contains(s)) return true;\n        if (notSet.contains(s)) return false;\n        for (int i = 1;i<s.length();i++){\n            String sl = s.substring(0,i);\n            String sr = s.substring(i,s.length());\n            // System.out.println\n            boolean left = check(sl);\n            if (left) set.add(sl);\n            else notSet.add(sl);\n            boolean right = check(sr);\n            if (right) set.add(sr);\n            else notSet.add(sr);\n            if (left && right) return true;\n        }\n        return false;\n    }\n}","runtime":"379 ms","title":"Word Break","url":"/submissions/detail/1076389096/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076389096,"time":"3 months, 1 week","lang":"java","title_slug":"word-break","timestamp":1697432228,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111"},{"status_display":"Time Limit Exceeded","memory":"N/A","code":"class Solution {\n    HashSet<String> set ;\n    public boolean wordBreak(String s, List<String> wordDict) {\n        set= new HashSet<>(wordDict);\n        if (set.contains(s)) return true;\n        \n\n        return check(s);\n        \n    }\n\n    boolean check(String s){\n        if (set.contains(s)) return true;\n        for (int i = 1;i<s.length();i++){\n            String sl = s.substring(0,i);\n            String sr = s.substring(i,s.length());\n            // System.out.println\n            boolean left = check(sl);\n            if (left) set.add(sl);\n            boolean right = check(sr);\n            if (right) set.add(sr);\n            if (left && right) return true;\n        }\n        return false;\n    }\n}","runtime":"N/A","title":"Word Break","url":"/submissions/detail/1076387672/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076387672,"time":"3 months, 1 week","lang":"java","title_slug":"word-break","timestamp":1697432089,"status":14,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111000000000000"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    HashSet<String> set ;\n    public boolean wordBreak(String s, List<String> wordDict) {\n        set= new HashSet<>(wordDict);\n        if (set.contains(s)) return true;\n        \n\n        return check(s);\n        \n    }\n\n    boolean check(String s){\n        if (set.contains(s)) return true;\n        for (int i = 1;i<s.length()-1;i++){\n            String sl = s.substring(0,i);\n            String sr = s.substring(i,s.length());\n            boolean left = check(sl);\n            if (left) set.add(sl);\n            boolean right = check(sr);\n            if (right) set.add(sr);\n            if (left && right) return true;\n        }\n        return false;\n    }\n}","runtime":"N/A","title":"Word Break","url":"/submissions/detail/1076386858/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076386858,"time":"3 months, 1 week","lang":"java","title_slug":"word-break","timestamp":1697432009,"status":11,"is_pending":"Not Pending","compare_result":"1111100101111111111111111111011111000000000000"},{"status_display":"Accepted","memory":"40.3 MB","code":"class Solution {\n    public int rob(int[] nums) {\n        int n = nums.length;\n        if (n==1) return nums[0];\n        if (n==2) return Integer.max(nums[0],nums[1]);;\n        int [] dp = new int [n];\n        dp[0] = nums[0];\n        dp[1] = Integer.max(nums[0],nums[1]);\n        for (int i = 2;i<n;i++){\n            dp[i]= Integer.max(dp[i-2]+nums[i],dp[i-1]);\n        }\n        return dp[n-1];\n    }\n}","runtime":"0 ms","title":"House Robber","url":"/submissions/detail/1076333570/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076333570,"time":"3 months, 1 week","lang":"java","title_slug":"house-robber","timestamp":1697426031,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Runtime Error","memory":"N/A","code":"class Solution {\n    public int rob(int[] nums) {\n        int n = nums.length;\n        int [] dp = new int [n];\n        dp[0] = nums[0];\n        dp[1] = Integer.max(nums[0],nums[1]);\n        for (int i = 2;i<n;i++){\n            dp[i]= Integer.max(dp[i-2]+nums[i],dp[i-1]);\n        }\n        return dp[n-1];\n    }\n}","runtime":"N/A","title":"House Robber","url":"/submissions/detail/1076333037/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076333037,"time":"3 months, 1 week","lang":"java","title_slug":"house-robber","timestamp":1697425966,"status":15,"is_pending":"Not Pending","compare_result":"1100000000000000000000000000000000000000000000000000000000000000000000"},{"status_display":"Accepted","memory":"39.2 MB","code":"class Solution {\n    public int climbStairs(int n) {\n        if (n<=2) return n;\n        int a = 1;\n        int b = 2;\n        int c = 2;\n        int count = 2;\n        while (count<n){\n            count++;\n            c = a + b;\n            a = b;\n            b = c;\n        }\n        return c;\n        \n    }\n}","runtime":"0 ms","title":"Climbing Stairs","url":"/submissions/detail/1076330917/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076330917,"time":"3 months, 1 week","lang":"java","title_slug":"climbing-stairs","timestamp":1697425703,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"43.2 MB","code":"class Solution {\n    int [] dp;\n    public int candy(int[] r) {\n        int n = r.length;\n        int []left = new int[n];\n        int [] right = new int [n];        \n        int sum = 0;\n        left [0] = 1;\n        for (int i=1;i<n;i++){\n            if (r[i]>r[i-1]) left[i] = left[i-1]+1;\n            else left[i] = 1;\n        }\n        right[n-1] = 1;\n        for (int i=n-2;i>=0;i--){\n            if (r[i]>r[i+1]) right[i] = right[i+1]+1;\n            else right[i] = 1;\n        }\n        for (int i = 0; i<n;i++){\n            // System.out.println(left[i] + \" \"+ right[i]);\n            sum = sum + Integer.max(left[i],right[i]);\n        }\n        \n        return sum;\n\n    }\n\n    // public int getCandy(int x, int[] ratings){\n    //     System.out.println(x);\n    //     if (x<=0) return 0;\n    //     if (x>=dp.length-1) return 0;\n    //     if (dp[x]!=0) return dp[x];\n    //     if (ratings[x]<ratings[x-1] && ratings[x]<ratings[x+1]) return 1;\n    //     // int min = Integer.min(getCandy(x-1,ratings),getCandy(x+1,ratings))+1;\n    //     int a = getCandy(x-1,ratings);\n    //     int b = getCandy(x+1,ratings);\n    //     int min = Integer.min(a,b)+1;\n    //     dp[x] = min;\n    //     return min;\n    // }\n}","runtime":"3 ms","title":"Candy","url":"/submissions/detail/1076327826/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076327826,"time":"3 months, 1 week","lang":"java","title_slug":"candy","timestamp":1697425307,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"61.3 MB","code":"class Solution {\n    public int canCompleteCircuit(int[] gas, int[] cost) {\n\n        \n        int g = 0;\n        int c = 0;\n        for (int i: gas){\n            g= g + i;\n        }\n        for (int i:cost){\n            c = c+i;\n        }\n        if (g<c) return -1;\n        int n = gas.length;\n        int a [] = new int [n];\n        for (int i=0;i<n;i++){\n            a[i] = gas[i] - cost[i];\n        }\n        int start = 0;\n        int runSum = 0;\n        for (int i = 0; i< n ; i++){\n            runSum = runSum+a[i];\n            if (runSum<0){\n                start = i+1;\n                runSum=0;\n            }\n            // System.out.println(start+\" \"+runSum);\n\n        }\n        // for (int i: a){\n        //     System.out.print(i +\" \");\n\n        // }\n        // System.out.println();\n        \n\n        return start;\n        \n    }\n\n    \n}","runtime":"2 ms","title":"Gas Station","url":"/submissions/detail/1075591421/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1075591421,"time":"3 months, 1 week","lang":"java","title_slug":"gas-station","timestamp":1697346572,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int canCompleteCircuit(int[] gas, int[] cost) {\n        int g = 0;\n        int c = 0;\n        for (int i: gas){\n            g= g + i;\n        }\n        for (int i:cost){\n            c = c+i;\n        }\n        if (g<c) return -1;\n        int n = gas.length;\n        int a [] = new int [n];\n        for (int i=0;i<n;i++){\n            a[i] = gas[i] - cost[i];\n        }\n        int start =0;\n        while (a[start]*a[start+1]>=0){\n            start++;\n        }\n        start = start + 1;\n        int count = start;\n        boolean check = false;\n        int runSum = 0;\n        int max = 0;\n        int res = 0;\n        for (int i: a){\n            System.out.print(i +\" \");\n\n        }\n        System.out.println();\n        while (!check){\n            if (a[count]>=0){\n                int temp = count;\n                runSum = 0;\n                while (a[count]>=0){\n                    runSum=runSum+a[count];\n                    count++;\n                    if (count >=n) count =0;\n                    if (count == start) check = true;\n\n                }\n                if (runSum> max) {\n                    max = runSum;\n                    res = temp;\n                }\n\n            }\n            // System.out.println(count+\" \"+runSum);\n            count++;\n            if (count >=n) count =0;\n            if (count == start) check = true;\n\n        }\n        System.out.println(start+\" \"+max);\n\n        return res;\n        \n    }\n\n    \n}","runtime":"N/A","title":"Gas Station","url":"/submissions/detail/1075584351/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1075584351,"time":"3 months, 1 week","lang":"java","title_slug":"gas-station","timestamp":1697345870,"status":11,"is_pending":"Not Pending","compare_result":"1111101111111111100000000000000000000000"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int canCompleteCircuit(int[] gas, int[] cost) {\n        int g = 0;\n        int c = 0;\n        for (int i: gas){\n            g= g + i;\n        }\n        for (int i:cost){\n            c = c+i;\n        }\n        if (g<c) return -1;\n        int n = gas.length;\n        int a [] = new int [n];\n        for (int i=0;i<n;i++){\n            a[i] = gas[i] - cost[i];\n        }\n        int start =0;\n        while (a[start]*a[start+1]>=0){\n            start++;\n        }\n        start = start + 1;\n        int count = start;\n        boolean check = false;\n        int runSum = 0;\n        int max = 0;\n        int res = 0;\n        for (int i: a){\n            System.out.print(i +\" \");\n\n        }\n        System.out.println();\n        while (!check){\n            if (a[count]>=0){\n                int temp = count;\n                while (a[count]>=0){\n                    runSum=runSum+a[count];\n                    count++;\n                    if (count >=n) count =0;\n                    if (count == start) check = true;\n\n                }\n                if (runSum> max) {\n                    max = runSum;\n                    res = temp;\n                }\n\n            }\n            // System.out.println(count+\" \"+runSum);\n            count++;\n            if (count >=n) count =0;\n            if (count == start) check = true;\n\n        }\n        // System.out.println(start);\n\n        return res;\n        \n    }\n\n    \n}","runtime":"N/A","title":"Gas Station","url":"/submissions/detail/1075582880/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1075582880,"time":"3 months, 1 week","lang":"java","title_slug":"gas-station","timestamp":1697345731,"status":11,"is_pending":"Not Pending","compare_result":"1111111111111110100000000000000000000000"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int canCompleteCircuit(int[] gas, int[] cost) {\n        int g = 0;\n        int c = 0;\n        for (int i: gas){\n            g= g + i;\n        }\n        for (int i:cost){\n            c = c+i;\n        }\n        if (g<c) return -1;\n        int n = gas.length;\n        int a [] = new int [n];\n        for (int i=0;i<n;i++){\n            a[i] = gas[i] - cost[i];\n        }\n        int start =0;\n        while (a[start]*a[start+1]>=0){\n            start++;\n        }\n        start = start + 1;\n        int count = start;\n        boolean check = false;\n        int runSum = 0;\n        int max = 0;\n        int res = 0;\n        while (!check){\n            if (a[count]>=0){\n                int temp = count;\n                while (a[count]>=0){\n                    runSum=runSum+a[count];\n                    count++;\n                    if (count >=n) count =0;\n                    if (count == start) check = true;\n\n                }\n                if (runSum> max) {\n                    max = runSum;\n                    res = temp;\n                }\n\n            }\n            // System.out.println(count+\" \"+runSum);\n            count++;\n            if (count >=n) count =0;\n            if (count == start) check = true;\n\n        }\n        // System.out.println(start);\n\n        return res;\n        \n    }\n\n    \n}","runtime":"N/A","title":"Gas Station","url":"/submissions/detail/1075582236/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1075582236,"time":"3 months, 1 week","lang":"java","title_slug":"gas-station","timestamp":1697345664,"status":11,"is_pending":"Not Pending","compare_result":"1111111111111110100000000000000000000000"},{"status_display":"Time Limit Exceeded","memory":"N/A","code":"class Solution {\n    public int canCompleteCircuit(int[] gas, int[] cost) {\n        int g = 0;\n        int c = 0;\n        for (int i: gas){\n            g= g + i;\n        }\n        for (int i:cost){\n            c = c+i;\n        }\n        if (g<c) return -1;\n        int n = gas.length;\n        int a [] = new int [n];\n        for (int i=0;i<n;i++){\n            a[i] = gas[i] - cost[i];\n        }\n        int start =0;\n        while (a[start]*a[start+1]>=0){\n            start++;\n        }\n        start = start + 1;\n        int count = start;\n        boolean check = false;\n        int runSum = 0;\n        int max = 0;\n        int res = 0;\n        while (!check){\n            if (a[count]>=0){\n                int temp = count;\n                while (a[count]>=0){\n                    runSum=runSum+a[count];\n                    count++;\n                    if (count >=n) count =0;\n                }\n                if (runSum> max) {\n                    max = runSum;\n                    res = temp;\n                }\n\n            }\n            // System.out.println(count+\" \"+runSum);\n            count++;\n            if (count >=n) count =0;\n            if (count == start) check = true;\n\n        }\n        // System.out.println(start);\n\n        return res;\n        \n    }\n\n    \n}","runtime":"N/A","title":"Gas Station","url":"/submissions/detail/1075581822/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1075581822,"time":"3 months, 1 week","lang":"java","title_slug":"gas-station","timestamp":1697345620,"status":14,"is_pending":"Not Pending","compare_result":"1110000000000000000000000000000000000000"},{"status_display":"Time Limit Exceeded","memory":"N/A","code":"class Solution {\n    public int canCompleteCircuit(int[] gas, int[] cost) {\n        int g = 0;\n        int c = 0;\n        for (int i: gas){\n            g= g + i;\n        }\n        for (int i:cost){\n            c = c+i;\n        }\n        if (g<c) return -1;\n        int n = gas.length;\n        int a [] = new int [n];\n        for (int i=0;i<n;i++){\n            a[i] = gas[i] - cost[i];\n        }\n        int start =0;\n        while (a[start]*a[start+1]>=0){\n            start++;\n        }\n        start = start + 1;\n        int count = start;\n        boolean check = false;\n        int runSum = 0;\n        int max = 0;\n        int res = 0;\n        while (!check){\n            if (a[count]>=0){\n                int temp = count;\n                while (a[count]>=0){\n                    runSum=runSum+a[count];\n                    count++;\n                    if (count >=n) count =0;\n                }\n                if (runSum> max) {\n                    max = runSum;\n                    res = temp;\n                }\n\n            }\n            // System.out.println(count+\" \"+runSum);\n            count++;\n            if (count >=n) count =0;\n            if (count == start) check = true;\n\n        }\n        // System.out.println(start);\n\n        return res;\n        \n    }\n\n    \n}","runtime":"N/A","title":"Gas Station","url":"/submissions/detail/1075581621/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1075581621,"time":"3 months, 1 week","lang":"java","title_slug":"gas-station","timestamp":1697345599,"status":14,"is_pending":"Not Pending","compare_result":"1110000000000000000000000000000000000000"},{"status_display":"Output Limit Exceeded","memory":"N/A","code":"class Solution {\n    public int canCompleteCircuit(int[] gas, int[] cost) {\n        int g = 0;\n        int c = 0;\n        for (int i: gas){\n            g= g + i;\n        }\n        for (int i:cost){\n            c = c+i;\n        }\n        if (g<c) return -1;\n        int n = gas.length;\n        int a [] = new int [n];\n        for (int i=0;i<n;i++){\n            a[i] = gas[i] - cost[i];\n        }\n        int start =0;\n        while (a[start]*a[start+1]>=0){\n            start++;\n        }\n        start = start + 1;\n        int count = start;\n        boolean check = false;\n        int runSum = 0;\n        int max = 0;\n        int res = 0;\n        while (!check){\n            if (a[count]>=0){\n                int temp = count;\n                while (a[count]>=0){\n                    runSum=runSum+a[count];\n                    count++;\n                    if (count >=n) count =0;\n                }\n                if (runSum> max) {\n                    max = runSum;\n                    res = temp;\n                }\n\n            }\n            System.out.println(count+\" \"+runSum);\n            count++;\n            if (count >=n) count =0;\n            if (count == start) check = true;\n\n        }\n        // System.out.println(start);\n\n        return res;\n        \n    }\n\n    \n}","runtime":"N/A","title":"Gas Station","url":"/submissions/detail/1075581447/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1075581447,"time":"3 months, 1 week","lang":"java","title_slug":"gas-station","timestamp":1697345583,"status":13,"is_pending":"Not Pending","compare_result":"1110000000000000000000000000000000000000"},{"status_display":"Accepted","memory":"43 MB","code":"class Solution {\n    public int coinChange(int[] coins, int amount) {\n        if (amount == 0) return 0;\n        int [] dp = new int[amount+1];\n        HashSet<Integer> set = new HashSet<>();\n        dp[0] = 0;\n        for (int i=1;i<=amount;i++){\n            dp[i] = Integer.MAX_VALUE;\n        }\n        for (int i : coins){\n            if (i<=amount){\n                dp[i] = 1;\n                set.add(i);\n            }\n            \n        }\n\n        for (int i = 1;i<=amount; i++){\n            int min = dp[i];\n            for (int coin: coins){\n                if (i>coin){\n                    if (dp[i-coin]!=Integer.MAX_VALUE)\n                        if (dp[i-coin]+1 < min) min = dp[i-coin] +1;\n                }\n            }\n            if (min!=Integer.MAX_VALUE)\n                dp[i] = min;\n            \n        }\n        // for (int i = 0; i<=amount;i++){\n        //     System.out.println(i+\" \"+dp[i]);\n        // }\n\n        return dp[amount]!=Integer.MAX_VALUE?dp[amount]:-1;\n        \n    }\n}","runtime":"16 ms","title":"Coin Change","url":"/submissions/detail/1075232509/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1075232509,"time":"3 months, 2 weeks","lang":"java","title_slug":"coin-change","timestamp":1697309659,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}],"has_next":true,"last_key":"%7B%22pk%22%3A%20%7B%22N%22%3A%20%221075232509%22%7D%2C%20%22dt%22%3A%20%7B%22S%22%3A%20%222023-10-14T18%3A54%3A19.499222%2B0000%22%7D%2C%20%22sid%22%3A%20%7B%22N%22%3A%20%227573785%22%7D%7D"}
2024-01-26 23:03:06.370 [main] DEBUG submission_dump - {"submissions_dump":[{"status_display":"Accepted","memory":"43.7 MB","code":"class Solution {\n    public int coinChange(int[] coins, int amount) {\n        if (amount == 0) return 0;\n        int [] dp = new int[amount+1];\n        HashSet<Integer> set = new HashSet<>();\n        dp[0] = 0;\n        for (int i=1;i<=amount;i++){\n            dp[i] = Integer.MAX_VALUE;\n        }\n        for (int i : coins){\n            if (i<=amount){\n                dp[i] = 1;\n                set.add(i);\n            }\n            \n        }\n\n        for (int i = 1;i<=amount; i++){\n            int min = dp[i];\n            for (int coin: coins){\n                if (i>coin){\n                    if (dp[i-coin]!=Integer.MAX_VALUE)\n                        if (dp[i-coin]+1 < min) min = dp[i-coin] +1;\n                }\n            }\n            if (min!=Integer.MAX_VALUE)\n                dp[i] = min;\n            \n        }\n        // for (int i = 0; i<=amount;i++){\n        //     System.out.println(i+\" \"+dp[i]);\n        // }\n\n        return dp[amount]>0&&dp[amount]!=Integer.MAX_VALUE?dp[amount]:-1;\n        \n    }\n}","runtime":"15 ms","title":"Coin Change","url":"/submissions/detail/1075226455/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1075226455,"time":"3 months, 2 weeks","lang":"java","title_slug":"coin-change","timestamp":1697309094,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int coinChange(int[] coins, int amount) {\n        if (amount == 0) return 0;\n        int [] dp = new int[amount+1];\n        HashSet<Integer> set = new HashSet<>();\n        dp[0] = 0;\n        for (int i=1;i<=amount;i++){\n            dp[i] = Integer.MAX_VALUE;\n        }\n        for (int i : coins){\n            if (i<=amount){\n                dp[i] = 1;\n                set.add(i);\n            }\n            \n        }\n\n        for (int i = 1;i<=amount; i++){\n            int min = Integer.MAX_VALUE;\n            for (int coin: coins){\n                if (i>coin){\n                    if (dp[i-coin]+1 < min) min = dp[i-coin] +1;\n                }\n            }\n            if (min!=Integer.MAX_VALUE)\n                dp[i] = Integer.min(min,dp[i]);\n            \n        }\n        // for (int i = 0; i<=amount;i++){\n        //     System.out.println(i+\" \"+dp[i]);\n        // }\n\n        return dp[amount]>0&&dp[amount]!=Integer.MAX_VALUE?dp[amount]:-1;\n        \n    }\n}","runtime":"N/A","title":"Coin Change","url":"/submissions/detail/1075223060/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1075223060,"time":"3 months, 2 weeks","lang":"java","title_slug":"coin-change","timestamp":1697308785,"status":11,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111100000000000001000010000010000010001000100000000000000000000010000000000001000000011000000000000000000000000000000000000000000000000000001100000000000000110111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int coinChange(int[] coins, int amount) {\n        if (amount == 0) return 0;\n        int [] dp = new int[amount+1];\n        HashSet<Integer> set = new HashSet<>();\n        dp[0] = 0;\n        for (int i=1;i<=amount;i++){\n            dp[i] = Integer.MAX_VALUE;\n        }\n        for (int i : coins){\n            if (i<=amount){\n                dp[i] = 1;\n                set.add(i);\n            }\n            \n        }\n\n        for (int i = 1;i<=amount; i++){\n            int min = Integer.MAX_VALUE;\n            for (int coin: coins){\n                if (i>coin){\n                    if (dp[i-coin]+1 < min) min = dp[i-coin] +1;\n                }\n            }\n            if (min!=Integer.MAX_VALUE)\n                dp[i] = min;\n            \n        }\n        // for (int i = 0; i<=amount;i++){\n        //     System.out.println(i+\" \"+dp[i]);\n        // }\n\n        return dp[amount]>0&&dp[amount]!=Integer.MAX_VALUE?dp[amount]:-1;\n        \n    }\n}","runtime":"N/A","title":"Coin Change","url":"/submissions/detail/1075222276/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1075222276,"time":"3 months, 2 weeks","lang":"java","title_slug":"coin-change","timestamp":1697308720,"status":11,"is_pending":"Not Pending","compare_result":"111111111110110011101011010110000000000000001000010000010000010001000100000000000000000000010000000000001000000011000000000000000000000000000000000000000000000000000000100000000000000110111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int coinChange(int[] coins, int amount) {\n        if (amount == 0) return 0;\n        int [] dp = new int[amount+1];\n        HashSet<Integer> set = new HashSet<>();\n        dp[0] = 0;\n        for (int i=1;i<=amount;i++){\n            dp[i] = Integer.MAX_VALUE;\n        }\n        for (int i : coins){\n            if (i<=amount){\n                dp[i] = 1;\n                set.add(i);\n            }\n            \n        }\n\n        for (int i = 1;i<=amount; i++){\n            int min = Integer.MAX_VALUE;\n            for (int coin: coins){\n                if (i>coin){\n                    if (dp[i-coin]+1 < min) min = dp[i-coin] +1;\n                }\n            }\n            if (min!=Integer.MAX_VALUE)\n                dp[i] = min;\n            \n        }\n        // for (int i = 0; i<=amount;i++){\n        //     System.out.println(i+\" \"+dp[i]);\n        // }\n\n        return dp[amount]>0?dp[amount]:-1;\n        \n    }\n}","runtime":"N/A","title":"Coin Change","url":"/submissions/detail/1075221760/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1075221760,"time":"3 months, 2 weeks","lang":"java","title_slug":"coin-change","timestamp":1697308674,"status":11,"is_pending":"Not Pending","compare_result":"111110110110110011101011010110000000000000001000010000010000010000000100000000000000000000010000000000001000000011000000000000000000000000000000000000000000000000000000100000000000000110011"},{"status_display":"Accepted","memory":"43.7 MB","code":"class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        HashSet<Character> tracker =  new HashSet<>();\n        char [] ch = s.toCharArray();\n\n        int p_l = 0;\n        int p_r = 0;\n        int count = 0;\n        int max = 0;\n        while (p_l<s.length() && p_r<s.length()){\n            if (tracker.contains(ch[p_r])){\n                while (tracker.contains(ch[p_r])){\n                    tracker.remove(ch[p_l]);\n                    p_l++;\n                    count --;\n                }\n            }\n            \n            count++;\n            if (count > max) max= count;\n            tracker.add(ch[p_r]);\n            \n            p_r++;\n        }\n\n        return max;\n        \n    }\n}","runtime":"7 ms","title":"Longest Substring Without Repeating Characters","url":"/submissions/detail/1074721918/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1074721918,"time":"3 months, 2 weeks","lang":"java","title_slug":"longest-substring-without-repeating-characters","timestamp":1697259456,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        HashSet<Character> tracker =  new HashSet<>();\n        char [] ch = s.toCharArray();\n\n        int p_l = 0;\n        int p_r = 0;\n        int count = 0;\n        int max = 0;\n        while (p_l<s.length() && p_r<s.length()){\n            if (tracker.contains(ch[p_r])){\n                while (tracker.contains(ch[p_r])){\n                    tracker.remove(ch[p_l]);\n                    p_l++;\n                    count --;\n                }\n            }\n            else{\n                count++;\n                if (count > max) max= count;\n                tracker.add(ch[p_r]);\n            }\n            p_r++;\n        }\n\n        return max;\n        \n    }\n}","runtime":"N/A","title":"Longest Substring Without Repeating Characters","url":"/submissions/detail/1074662574/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1074662574,"time":"3 months, 2 weeks","lang":"java","title_slug":"longest-substring-without-repeating-characters","timestamp":1697250360,"status":11,"is_pending":"Not Pending","compare_result":"111111111011111111101111111101111110111110011111000110011111111111011111100110110010011111001110110011000101000110100001001100110000000010010000010010000010110100100011001000011001100100011100000000001001000101000100000100000000110010000000000101000000000010000000010001000001000010000000000001000000000100100000001010000000001000000000100000000001100000000011001100000000000000000000000000010000000010001100010100001000010001000000000000001000010000000000000000000000010000000001010000000100000000000000011000011000010101000000001000000010000000000000010000000001000000000000010000010010010000000000000000000100000010000000000100000000000000000000000000000001000100000000000001001000000000000000000000000000000000110010000000001000001000000001100001000000010000000000000000100000000000000000010100000011010100000010000000110000010000000100000000000000000000000000000000000001000000000000000000000000010000000000000000000000000000000010000000001000000000000000000010000000000000000000011"},{"status_display":"Accepted","memory":"42.6 MB","code":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode l1_p = l1;\n        ListNode l2_p = l2;\n        ListNode re = null;\n        ListNode re_p = re;\n        int left = 0;\n        while (l1_p!=null || l2_p !=null){\n            int val = left;\n            if (l1_p != null) {\n                val = val+l1_p.val;\n                l1_p = l1_p.next;\n            }\n            if (l2_p != null) {\n                val = val+l2_p.val;\n                l2_p = l2_p.next;\n            }\n            if (val > 9 ){\n                val = val- 10;\n                left = 1;\n            }else{\n                left = 0;\n            }\n            if (re_p==null){\n                re = new ListNode(val);\n                re_p = re;\n            }else{\n                re_p.next = new ListNode(val);\n                re_p = re_p.next;\n            }\n            \n        }\n        if (left > 0) re_p.next = new ListNode(left);\n\n        return re;\n        \n    }\n}","runtime":"1 ms","title":"Add Two Numbers","url":"/submissions/detail/1074655235/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1074655235,"time":"3 months, 2 weeks","lang":"java","title_slug":"add-two-numbers","timestamp":1697248954,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"42.9 MB","code":"class Solution {\n    public int numberOfPoints(List<List<Integer>> nums) {\n        List<Data> nums_data = new ArrayList<>();\n        int n = nums.size();\n        for (List<Integer> i : nums){\n            nums_data.add(new Data(i.get(0),i.get(1)));\n        }\n        Collections.sort(nums_data);\n\n        LinkedList<Data> re = new LinkedList<>();\n        re.add(nums_data.get(0));\n        for (int i =1;i<n;i++){\n            Data d = re.getLast();\n            Data i_d = nums_data.get(i);\n            if (d.b>=i_d.a) {\n                d.b = Integer.max(d.b,i_d.b);\n            } else{\n                re.add(i_d);\n            }\n        }\n        int count = 0;\n        for (Data d: re){\n            count = count + d.b-d.a+1;\n        }\n        return count;\n    }\n}\n\nclass Data implements Comparable<Data>{\n    int a;\n    int b;\n    public Data (int x, int y){\n        a= x;\n        b = y;\n    }\n\n    @Override\n    public int compareTo(Data o){\n        if (a==o.a) return Integer.compare(b,o.b);\n        return Integer.compare(a,o.a);\n    }\n}","runtime":"5 ms","title":"Points That Intersect With Cars","url":"/submissions/detail/1074626816/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1074626816,"time":"3 months, 2 weeks","lang":"java","title_slug":"points-that-intersect-with-cars","timestamp":1697243027,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"43.8 MB","code":"class Solution {\n    public int numberOfPoints(List<List<Integer>> nums) {\n        List<Data> nums_data = new ArrayList<>();\n        int n = nums.size();\n        for (List<Integer> i : nums){\n            nums_data.add(new Data(i.get(0),i.get(1)));\n        }\n        Collections.sort(nums_data);\n        for (Data d: nums_data){\n                        System.out.println(d.a+\" \"+d.b);\n\n        }\n        LinkedList<Data> re = new LinkedList<>();\n        re.add(nums_data.get(0));\n        for (int i =1;i<n;i++){\n            Data d = re.getLast();\n            Data i_d = nums_data.get(i);\n            if (d.b>=i_d.a) {\n                d.b = Integer.max(d.b,i_d.b);\n            } else{\n                re.add(i_d);\n            }\n        }\n        int count = 0;\n        for (Data d: re){\n            System.out.println(d.a+\" \"+d.b);\n            count = count + d.b-d.a+1;\n        }\n        return count;\n    }\n}\n\nclass Data implements Comparable<Data>{\n    int a;\n    int b;\n    public Data (int x, int y){\n        a= x;\n        b = y;\n    }\n\n    @Override\n    public int compareTo(Data o){\n        if (a==o.a) return Integer.compare(b,o.b);\n        return Integer.compare(a,o.a);\n    }\n}","runtime":"32 ms","title":"Points That Intersect With Cars","url":"/submissions/detail/1074626752/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1074626752,"time":"3 months, 2 weeks","lang":"java","title_slug":"points-that-intersect-with-cars","timestamp":1697243013,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int numberOfPoints(List<List<Integer>> nums) {\n        List<Data> nums_data = new ArrayList<>();\n        int n = nums.size();\n        for (List<Integer> i : nums){\n            nums_data.add(new Data(i.get(0),i.get(1)));\n        }\n        Collections.sort(nums_data);\n        LinkedList<Data> re = new LinkedList<>();\n        re.add(nums_data.get(0));\n        for (int i =1;i<n;i++){\n            Data d = re.getLast();\n            Data i_d = nums_data.get(i);\n            if (d.b>=i_d.a) {\n                d.b = Integer.max(d.b,i_d.b);\n            } else{\n                re.add(i_d);\n            }\n        }\n        int count = 0;\n        for (Data d: re){\n            System.out.println(d.a+\" \"+d.b);\n            count = count + d.b-d.a+1;\n        }\n        return count;\n    }\n}\n\nclass Data implements Comparable<Data>{\n    int a;\n    int b;\n    public Data (int x, int y){\n        a= x;\n        b = y;\n    }\n\n    @Override\n    public int compareTo(Data o){\n        if (a==o.a) return Integer.compare(b,o.b);\n        return Integer.compare(b,o.b);\n    }\n}","runtime":"N/A","title":"Points That Intersect With Cars","url":"/submissions/detail/1074626422/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1074626422,"time":"3 months, 2 weeks","lang":"java","title_slug":"points-that-intersect-with-cars","timestamp":1697242948,"status":11,"is_pending":"Not Pending","compare_result":"110001011001110101100110001011110001010000100101011110111010100011111101100100011111100000100101110100110011100110100110101101010100101100000110000110001111000000001000100011111010010110110110101100001010110001100100010011110001000010010111010101000110010001101100011110111111001101111101111101001010101000011100101001001000011110110111111111111011110110110011011111011010111100000001011011010110100000111110101010100000011101000101101100100011000011110100101111011001000100010000111100011111111011100100000001000110001001010000000010000100000001100010000000100100000001001000000010001000010001001100100001000000101000000001000000000010000001001000001000000101000001000000000000000000100010000001000100000001000000000010000000011000010010100001000000000000000000000010000000000000001000100000000000001011111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int numberOfPoints(List<List<Integer>> nums) {\n        List<Data> nums_data = new ArrayList<>();\n        int n = nums.size();\n        for (List<Integer> i : nums){\n            nums_data.add(new Data(i.get(0),i.get(1)));\n        }\n        Collections.sort(nums_data);\n        LinkedList<Data> re = new LinkedList<>();\n        re.add(nums_data.get(0));\n        for (int i =1;i<n;i++){\n            Data d = re.getLast();\n            Data i_d = nums_data.get(i);\n            if (d.b>=i_d.a) {\n                d.b = Integer.max(d.b,i_d.b);\n            } else{\n                re.add(i_d);\n            }\n        }\n        int count = 0;\n        for (Data d: re){\n            count = count + d.b-d.a+1;\n        }\n        return count;\n    }\n}\n\nclass Data implements Comparable<Data>{\n    int a;\n    int b;\n    public Data (int x, int y){\n        a= x;\n        b = y;\n    }\n\n    @Override\n    public int compareTo(Data o){\n        if (a==o.a) return Integer.compare(b,o.b);\n        return Integer.compare(b,o.b);\n    }\n}","runtime":"N/A","title":"Points That Intersect With Cars","url":"/submissions/detail/1074625819/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1074625819,"time":"3 months, 2 weeks","lang":"java","title_slug":"points-that-intersect-with-cars","timestamp":1697242825,"status":11,"is_pending":"Not Pending","compare_result":"110001011001110101100110001011110001010000100101011110111010100011111101100100011111100000100101110100110011100110100110101101010100101100000110000110001111000000001000100011111010010110110110101100001010110001100100010011110001000010010111010101000110010001101100011110111111001101111101111101001010101000011100101001001000011110110111111111111011110110110011011111011010111100000001011011010110100000111110101010100000011101000101101100100011000011110100101111011001000100010000111100011111111011100100000001000110001001010000000010000100000001100010000000100100000001001000000010001000010001001100100001000000101000000001000000000010000001001000001000000101000001000000000000000000100010000001000100000001000000000010000000011000010010100001000000000000000000000010000000000000001000100000000000001011111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int numberOfPoints(List<List<Integer>> nums) {\n        List<Data> nums_data = new ArrayList<>();\n        int n = nums.size();\n        for (List<Integer> i : nums){\n            nums_data.add(new Data(i.get(0),i.get(1)));\n        }\n        Collections.sort(nums_data);\n        LinkedList<Data> re = new LinkedList<>();\n        re.add(nums_data.get(0));\n        for (int i =1;i<n;i++){\n            Data d = re.getLast();\n            Data i_d = nums_data.get(i);\n            if (d.b>i_d.a) {\n                d.b = Integer.max(d.b,i_d.b);\n            } else{\n                re.add(i_d);\n            }\n        }\n        int count = 0;\n        for (Data d: re){\n            count = count + d.b-d.a+1;\n        }\n        return count;\n    }\n}\n\nclass Data implements Comparable<Data>{\n    int a;\n    int b;\n    public Data (int x, int y){\n        a= x;\n        b = y;\n    }\n\n    @Override\n    public int compareTo(Data o){\n        if (a==o.a) return Integer.compare(b,o.b);\n        return Integer.compare(b,o.b);\n    }\n}","runtime":"N/A","title":"Points That Intersect With Cars","url":"/submissions/detail/1074625602/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1074625602,"time":"3 months, 2 weeks","lang":"java","title_slug":"points-that-intersect-with-cars","timestamp":1697242782,"status":11,"is_pending":"Not Pending","compare_result":"110001010100000001100100001011110001010000000100001111011010000001110100000000110111101000000100100100001111100110000100111001110100000000000110000100000100000010011000110011101000000111011100110110010010111110100000010001111011101010000111011101000010000000011001001010000011010000001001010101011000100000001100101001001100011110001011011101001011100100001011010111001000110000000000010101001001000000101010001010111000011000000101100101100111000000110100001001011001100000100000111000011011011101101100000000100000100000010000000000000100000001100000000000001000000001011000000010100100001001000000100001000000000000000000000000000000000001000000000010000001000001000000000000000000100001000100000000000001000000000010000001010000010000100000000000000000000000000010000000001000001000100000010000001011011"},{"status_display":"Accepted","memory":"43.6 MB","code":"class Solution {\n    public int countSymmetricIntegers(int low, int high) {\n        int count = 0;\n        for (int i = low;i<=high;i++){\n            if (isSym(i)) count ++;\n        }\n        return count;\n        \n    }\n    public boolean isSym(int num){\n        String s = \"\" + num;\n        if (s.length()%2!=0) return false;\n        int left = 0;\n        int right = 0;\n        int n = s.length();\n        for (int i=0;i<n/2;i++){\n            left = left + s.charAt(i)-'0';\n            right = right + s.charAt(i+n/2)-'0';\n        }\n        return left==right;\n\n    }\n}","runtime":"27 ms","title":"  Count Symmetric Integers","url":"/submissions/detail/1074622122/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1074622122,"time":"3 months, 2 weeks","lang":"java","title_slug":"count-symmetric-integers","timestamp":1697242056,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"42.3 MB","code":"class Solution {\n    public boolean canBeEqual(String s1, String s2) {\n        String s1_1 = \"\"+s1.charAt(2)+s1.charAt(1)+s1.charAt(0)+s1.charAt(3);\n        String s1_2 = \"\"+s1.charAt(2)+s1.charAt(3)+s1.charAt(0)+s1.charAt(1);\n        String s1_3 = \"\"+s1.charAt(0)+s1.charAt(3)+s1.charAt(2)+s1.charAt(1);\n        return s1.equals(s2) || s1_1.equals(s2) || s1_2.equals(s2) || s1_3.equals(s2);\n    }\n}","runtime":"10 ms","title":"Check if Strings Can be Made Equal With Operations I","url":"/submissions/detail/1074620248/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1074620248,"time":"3 months, 2 weeks","lang":"java","title_slug":"check-if-strings-can-be-made-equal-with-operations-i","timestamp":1697241691,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public boolean canBeEqual(String s1, String s2) {\n        String s1_1 = \"\"+s1.charAt(2)+s1.charAt(1)+s1.charAt(0)+s1.charAt(3);\n        String s1_2 = \"\"+s1.charAt(2)+s1.charAt(3)+s1.charAt(0)+s1.charAt(1);\n        String s1_3 = \"\"+s1.charAt(0)+s1.charAt(3)+s1.charAt(2)+s1.charAt(2);\n        return s1.equals(s2) || s1_1.equals(s2) || s1_2.equals(s2) || s1_3.equals(s2);\n    }\n}","runtime":"N/A","title":"Check if Strings Can be Made Equal With Operations I","url":"/submissions/detail/1074619981/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1074619981,"time":"3 months, 2 weeks","lang":"java","title_slug":"check-if-strings-can-be-made-equal-with-operations-i","timestamp":1697241634,"status":11,"is_pending":"Not Pending","compare_result":"1101101111111110111111111111111111011111111111111111011111010011101101101111111111111111111111111111111011011111111100111111111111111111111011111111111111111101111111111111111110111111111111111111111111101111111111110111111111111111111111111111111111110101110111111111111001111011111011111101111111110101111110111010101110011101111111111110111111111111011111111110111111111111111111111110111011111111101111110111101110110111111011111101011111011110011111111111110011111111111111011011100001101110101100101111101101111111111111011111111110111001111011111111111101111111111111110111011111111110010111111110111011110111111111101111111111011111111111111101111111111111100011111011111011111101111111111110101101111111111011111011110111011111111111101111111111101101111111111111111111101111111111011111110011111111111111101111111011111111011101001111110110101011111111111101011111111111111101111011011111111111001101101111111011110111111111111111111111111111011110111011110111111111111010111111111101111111101"},{"status_display":"Accepted","memory":"41.2 MB","code":"class Solution {\n    public int furthestDistanceFromOrigin(String moves) {\n        int countL=0;\n        int countR=0;\n        int count = 0;\n        int n = moves.length();\n        for (int i = 0;i<n;i++){\n            if (moves.charAt(i)=='L') countL++;\n            if (moves.charAt(i)=='R') countR++;\n            if (moves.charAt(i)=='_') count++;\n        }\n        if (countL==countR) return count;\n        if (countL>countR) return countL+count-countR;\n        return countR+count-countL;\n        \n    }\n}","runtime":"1 ms","title":"Furthest Point From Origin","url":"/submissions/detail/1074618190/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1074618190,"time":"3 months, 2 weeks","lang":"java","title_slug":"furthest-point-from-origin","timestamp":1697241279,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"44.2 MB","code":"class Solution {\n    public boolean isAcronym(List<String> words, String s) {\n        StringBuilder sb = new StringBuilder();\n        for (String d:words){\n            sb.append(d.charAt(0));\n        }\n        return sb.toString().equals(s);\n        \n    }\n}","runtime":"1 ms","title":"Check if a String Is an Acronym of Words","url":"/submissions/detail/1074617067/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1074617067,"time":"3 months, 2 weeks","lang":"java","title_slug":"check-if-a-string-is-an-acronym-of-words","timestamp":1697241057,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"41.5 MB","code":"class Solution {\n    public int countPairs(List<Integer> nums, int target) {\n        int count = 0;\n        int n = nums.size();\n        for (int i = 0; i<n-1;i++){\n            for (int j = i+1;j<n;j++){\n                if (nums.get(i)+nums.get(j)<target) count++;\n            }\n        }\n        return count;\n        \n    }\n}","runtime":"2 ms","title":"Count Pairs Whose Sum is Less than Target","url":"/submissions/detail/1074616399/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1074616399,"time":"3 months, 2 weeks","lang":"java","title_slug":"count-pairs-whose-sum-is-less-than-target","timestamp":1697240931,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"40.6 MB","code":"class Solution {\n    public long maximumTripletValue(int[] nums) {\n        long max = 0;\n        int n = nums.length;\n        for (int i = 0; i<n-2;i++){\n            for (int j = i+1;j<n-1;j++){\n                for (int k = j+1;k<n;k++){\n                    long temp = (long)(nums[i]-nums[j])*nums[k];\n                    if (temp>max) max = temp;\n                }\n            }\n        }\n        return max;\n    }\n}","runtime":"3 ms","title":"Maximum Value of an Ordered Triplet I","url":"/submissions/detail/1074615354/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1074615354,"time":"3 months, 2 weeks","lang":"java","title_slug":"maximum-value-of-an-ordered-triplet-i","timestamp":1697240726,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public long maximumTripletValue(int[] nums) {\n        long max = 0;\n        int n = nums.length;\n        for (int i = 0; i<n-2;i++){\n            for (int j = i+1;j<n-1;j++){\n                for (int k = j+1;k<n;k++){\n                    long temp = (nums[i]-nums[j])*nums[k];\n                    if (temp>max) max = temp;\n                }\n            }\n        }\n        return max;\n    }\n}","runtime":"N/A","title":"Maximum Value of an Ordered Triplet I","url":"/submissions/detail/1074614941/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1074614941,"time":"3 months, 2 weeks","lang":"java","title_slug":"maximum-value-of-an-ordered-triplet-i","timestamp":1697240649,"status":11,"is_pending":"Not Pending","compare_result":"111110111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000100000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000100000000001001000000000000000000100010000000000000000000000100000000000000000000001000000000000000000000000000000010000000000000000000001000000000000000000000000000000000000000000000000000000000001"}],"has_next":true,"last_key":"%7B%22pk%22%3A%20%7B%22N%22%3A%20%221074614941%22%7D%2C%20%22dt%22%3A%20%7B%22S%22%3A%20%222023-10-13T23%3A44%3A09.198066%2B0000%22%7D%2C%20%22sid%22%3A%20%7B%22N%22%3A%20%227573785%22%7D%7D"}
2024-01-26 23:03:17.065 [main] DEBUG submission_dump - {"submissions_dump":[{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public long maximumTripletValue(int[] nums) {\n        int max = 0;\n        int n = nums.length;\n        for (int i = 0; i<n-2;i++){\n            for (int j = i+1;j<n-1;j++){\n                for (int k = j+1;k<n;k++){\n                    int temp = (nums[i]-nums[j])*nums[k];\n                    if (temp>max) max = temp;\n                }\n            }\n        }\n        return max;\n    }\n}","runtime":"N/A","title":"Maximum Value of an Ordered Triplet I","url":"/submissions/detail/1074614751/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1074614751,"time":"3 months, 2 weeks","lang":"java","title_slug":"maximum-value-of-an-ordered-triplet-i","timestamp":1697240613,"status":11,"is_pending":"Not Pending","compare_result":"111110111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000100000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000100000000001001000000000000000000100010000000000000000000000100000000000000000000001000000000000000000000000000000010000000000000000000001000000000000000000000000000000000000000000000000000000000001"},{"status_display":"Accepted","memory":"40.8 MB","code":"class Solution {\n    public int minOperations(List<Integer> nums, int k) {\n        HashSet<Integer> check= new HashSet<>();\n        int n = nums.size();\n        Collections.reverse(nums);\n        int count =0;\n        for (int i = 0;i<n;i++){\n            if (nums.get(i)<=k && nums.get(i)>=1 && !check.contains(nums.get(i))){\n                count++;\n                check.add(nums.get(i));\n            }\n            if (count == k ){\n                return i+1;\n            }\n        }\n        return 0;\n\n        \n    }\n}","runtime":"2 ms","title":"Minimum Operations to Collect Elements","url":"/submissions/detail/1074613638/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1074613638,"time":"3 months, 2 weeks","lang":"java","title_slug":"minimum-operations-to-collect-elements","timestamp":1697240394,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"44 MB","code":"class Solution {\n    public String maximumOddBinaryNumber(String s) {\n        char [] c = s.toCharArray();\n        int n = s.length();\n        int count = 0;\n        for (char i: c){\n            if (i=='1'){\n                count ++;\n            }\n        }\n        \n        String re = \"\";\n        count --;\n        for (int i = 0;i<count;i++){\n            re='1'+re;\n        }\n        for (int i=0;i<n-count-1;i++){\n            re=re + \"0\";\n        }\n        return re+\"1\";\n    }\n}","runtime":"3 ms","title":"Maximum Odd Binary Number","url":"/submissions/detail/1074610512/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1074610512,"time":"3 months, 2 weeks","lang":"java","title_slug":"maximum-odd-binary-number","timestamp":1697239804,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"40.1 MB","code":"class Solution {\n    public int differenceOfSums(int n, int m) {\n        int l = (n/m) * m;\n        int sum2 = (m+l)*((l-m)/m+1)/2;\n        int sum = (n+1)*n /2;\n        int sum1 = sum - sum2;\n        // System.out.println(sum1 + \" \" + sum2);\n        return sum1-sum2;\n        \n    }\n}","runtime":"0 ms","title":"Divisible and Non-divisible Sums Difference","url":"/submissions/detail/1074609403/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1074609403,"time":"3 months, 2 weeks","lang":"java","title_slug":"divisible-and-non-divisible-sums-difference","timestamp":1697239586,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"40.6 MB","code":"class Solution {\n    public int hIndex(int[] citations) {\n        Arrays.sort(citations);\n        int count = 0;\n        for (int i = citations.length-1;i>=0;i--){\n            System.out.println(citations[i]);\n            if (citations[i]<=count) break;\n            \n            count++;\n        }\n\n        return count;\n        \n    }\n}","runtime":"8 ms","title":"H-Index","url":"/submissions/detail/1074543534/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1074543534,"time":"3 months, 2 weeks","lang":"java","title_slug":"h-index","timestamp":1697229253,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"41.8 MB","code":"class Solution {\n    public int numberOfEmployeesWhoMetTarget(int[] hours, int target) {\n        int re = 0;\n        for (int i: hours){\n            if (i>= target) re ++;\n        }\n        return re;\n        \n    }\n}","runtime":"0 ms","title":"Number of Employees Who Met the Target","url":"/submissions/detail/1073946748/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1073946748,"time":"3 months, 2 weeks","lang":"java","title_slug":"number-of-employees-who-met-the-target","timestamp":1697166764,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"43.6 MB","code":"class Solution {\n    public boolean isPalindrome(String s) {\n        StringBuilder sb = new StringBuilder();\n        s = s.toLowerCase();\n        for (int i = 0; i< s.length();i++){\n            char t = s.charAt(i);\n            if ((t<='z' && t >='a') || (t>='0' && t<='9')){\n                sb.append(t);\n            }\n        }\n        String st = \"\";\n        st = sb.toString();\n        if (st.length()<2) return true;\n        for (int i = 0;i<st.length()/2;i++){\n            if (st.charAt(i)!=st.charAt(st.length()-i-1)) return false;\n        }\n    return true;\n    }\n}","runtime":"3 ms","title":"Valid Palindrome","url":"/submissions/detail/1073850664/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1073850664,"time":"3 months, 2 weeks","lang":"java","title_slug":"valid-palindrome","timestamp":1697152587,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"44.9 MB","code":"class Solution {\n    public boolean isPalindrome(String s) {\n\n        String st = \"\";\n        s = s.toLowerCase();\n        for (int i = 0; i< s.length();i++){\n            char t = s.charAt(i);\n            if ((t<='z' && t >='a') || (t>='0' && t<='9')){\n                st = st + t;\n            }\n        }\n        if (st.length()<2) return true;\n        for (int i = 0;i<st.length()/2;i++){\n            if (st.charAt(i)!=st.charAt(st.length()-i-1)) return false;\n        }\n    return true;\n    }\n}","runtime":"128 ms","title":"Valid Palindrome","url":"/submissions/detail/1073849705/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1073849705,"time":"3 months, 2 weeks","lang":"java","title_slug":"valid-palindrome","timestamp":1697152429,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"45 MB","code":"class Solution {\n    public boolean isPalindrome(String s) {\n\n        String st = \"\";\n        s = s.toLowerCase();\n        for (int i = 0; i< s.length();i++){\n            char t = s.charAt(i);\n            if ((t<='z' && t >='a') || (t>='0' && t<='9')){\n                st = st + t;\n            }\n        }\n        if (st.length()<2) return true;\n        for (int i = 0;i<st.length()/2;i++){\n            if (st.charAt(i)!=st.charAt(st.length()-i-1)) return false;\n        }\n    return true;\n    }\n}","runtime":"131 ms","title":"Valid Palindrome","url":"/submissions/detail/1073849633/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1073849633,"time":"3 months, 2 weeks","lang":"java","title_slug":"valid-palindrome","timestamp":1697152418,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"45 MB","code":"class Solution {\n    public boolean isPalindrome(String s) {\n\n        String st = \"\";\n        s = s.toLowerCase();\n        for (int i = 0; i< s.length();i++){\n            char t = s.charAt(i);\n            if ((t<='z' && t >='a') || (t>='0' && t<='9')){\n                st = st + t;\n            }\n        }\n        if (st.length()<2) return true;\n        for (int i = 0;i<st.length();i++){\n            if (st.charAt(i)!=st.charAt(st.length()-i-1)) return false;\n        }\n    return true;\n    }\n}","runtime":"126 ms","title":"Valid Palindrome","url":"/submissions/detail/1073849341/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1073849341,"time":"3 months, 2 weeks","lang":"java","title_slug":"valid-palindrome","timestamp":1697152370,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public boolean isPalindrome(String s) {\n\n        String st = \"\";\n        s = s.toLowerCase();\n        for (int i = 0; i< s.length();i++){\n            char t = s.charAt(i);\n            if (t<='z' && t >='a'){\n                st = st + t;\n            }\n        }\n        if (st.length()<2) return true;\n        for (int i = 0;i<st.length();i++){\n            if (st.charAt(i)!=st.charAt(st.length()-i-1)) return false;\n        }\n    return true;\n    }\n}","runtime":"N/A","title":"Valid Palindrome","url":"/submissions/detail/1073848988/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1073848988,"time":"3 months, 2 weeks","lang":"java","title_slug":"valid-palindrome","timestamp":1697152308,"status":11,"is_pending":"Not Pending","compare_result":"11111111111011111110110111111101111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100111111101111101111101110101111110111111111111111011101101111010111111111011101101011111111111110011111111"},{"status_display":"Accepted","memory":"45.6 MB","code":"class Solution {\n\n    public int[][] merge(int[][] inp) {\n        int n = inp.length;\n        ArrayList<Pair> l = new ArrayList<>();\n        LinkedList<Pair> m = new LinkedList<>();\n\n        for (int[] i : inp){\n            l.add(new Pair(i[0],i[1]));\n        }\n        Collections.sort(l);\n        \n        m.add(l.get(0));\n        for (int i = 1;i<n;i++){\n            Pair pointer_m = m.getLast();\n            Pair pointer_l = l.get(i);\n            if (pointer_m.b>=pointer_l.a){\n                pointer_m.b = Integer.max(pointer_m.b, pointer_l.b);\n            } else{\n                m.add(pointer_l);\n            }\n        }\n        // System.out.println(m.size());\n        int [][] re = new int[m.size()][2];\n        int count = 0;\n        for (Pair i : m){\n            re[count][0] = i.a;\n            re[count][1] = i.b;\n            count++;\n        }\n        return re;\n    }\n}\nclass Pair implements Comparable<Pair>{\n    int a;\n    int b;\n    public Pair(int x, int y){\n        a = x;\n        b = y;\n\n    }\n    @Override\n    public int compareTo(Pair o){\n        if (a == o.a) return Integer.compare(b,o.b);\n        return Integer.compare(a,o.a);\n    }\n\n    @Override\n    public String toString(){\n        return a+\" \"+b;\n    }\n}","runtime":"9 ms","title":"Merge Intervals","url":"/submissions/detail/1073841303/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1073841303,"time":"3 months, 2 weeks","lang":"java","title_slug":"merge-intervals","timestamp":1697151078,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n\n    public int[][] merge(int[][] inp) {\n        int n = inp.length;\n        ArrayList<Pair> l = new ArrayList<>();\n        LinkedList<Pair> m = new LinkedList<>();\n\n        for (int[] i : inp){\n            l.add(new Pair(i[0],i[1]));\n        }\n        Collections.sort(l);\n        \n        m.add(l.get(0));\n        for (int i = 1;i<n;i++){\n            Pair pointer_m = m.getLast();\n            Pair pointer_l = l.get(i);\n            if (pointer_m.b>=pointer_l.a){\n                pointer_m.b = pointer_l.b;\n            } else{\n                m.add(pointer_l);\n            }\n        }\n        // System.out.println(m.size());\n        int [][] re = new int[m.size()][2];\n        int count = 0;\n        for (Pair i : m){\n            re[count][0] = i.a;\n            re[count][1] = i.b;\n            count++;\n        }\n        return re;\n    }\n}\nclass Pair implements Comparable<Pair>{\n    int a;\n    int b;\n    public Pair(int x, int y){\n        a = x;\n        b = y;\n\n    }\n    @Override\n    public int compareTo(Pair o){\n        if (a == o.a) return Integer.compare(b,o.b);\n        return Integer.compare(a,o.a);\n    }\n\n    @Override\n    public String toString(){\n        return a+\" \"+b;\n    }\n}","runtime":"N/A","title":"Merge Intervals","url":"/submissions/detail/1073840906/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1073840906,"time":"3 months, 2 weeks","lang":"java","title_slug":"merge-intervals","timestamp":1697151015,"status":11,"is_pending":"Not Pending","compare_result":"11111111110011101110111110111111111111110111111111111111101111111011111111110111101101110111111010101110101111111111110110011101100001001100010110000000000000000000000111"},{"status_display":"Accepted","memory":"43.9 MB","code":"class Solution {\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n        \n        HashSet<String> dict = new HashSet<String>(wordList);\n        if (!dict.contains(endWord)) return new ArrayList<>();\n        dict.add(beginWord);\n        System.out.println(dict.size());\n        List<List<String>> re = new ArrayList<>();\n        HashMap<String,HashSet<String>> map = new HashMap<>();\n\n        for (String s: dict){\n            map.put(s, new HashSet<>());\n        }\n        \n        for (String s1: dict){\n            for (String s2: dict){\n                if (!s1.equals(s2)){\n                    if (comp(s1,s2))\n                        map.get(s1).add(s2);\n                }\n            }\n        }\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        HashMap<String,Integer> shortPath = new HashMap<>();\n        HashMap<String,HashSet<String>> tracer = new HashMap<>();\n\n        for (String s: dict){\n            shortPath.put(s,Integer.MAX_VALUE);\n            tracer.put(s,new HashSet<>());\n        }\n\n        shortPath.put(beginWord,1);\n        \n        bfs.add(beginWord);\n        // int size = 1;\n        while (!bfs.isEmpty()){\n            String cur = bfs.poll();\n\n            if (!visited.contains(cur)){\n                visited.add(cur);\n                if (cur.equals(endWord)) break;\n                    for (String s: map.get(cur)){\n                        if (!visited.contains(s)){\n                            bfs.add(s);\n                            int min = shortPath.get(s);\n                            if (shortPath.get(cur)+1<=min){\n                                min = shortPath.get(cur)+1;\n                                shortPath.put(s,min);\n                                tracer.get(s).add(cur);\n                            }\n                        }\n                    }\n            }\n            \n        }\n\n        List<String> temp = new ArrayList<String>();\n        // System.out.println(shortPath.get(endWord));\n        gen(tracer,re,temp,beginWord,endWord);\n        return re;\n    }\n\n    public boolean comp(String s1, String s2){\n        if (s1.length()!=s2.length()) return false;\n        int n = s1.length(); \n        int count =0;\n        for (int i = 0;i<n;i++){\n            if (s1.charAt(i)!=s2.charAt(i))\n                count++;\n            if (count>1) return false;\n        }\n        return true;\n\n    }\n\n    public void gen(HashMap<String,HashSet<String>> tracer,List<List<String>> re, List<String> temp, String beginWord, String cur){\n        temp.add(cur);\n        // System.out.print(cur+\" \");\n        for (String s: tracer.get(cur)){\n            gen(tracer,re,temp,beginWord,s);\n        }\n        if (cur.equals(beginWord)){\n            List<String> t = new ArrayList<>(temp);\n            Collections.reverse(t);\n            re.add(t);\n            // System.out.println();\n        }\n        temp.remove(cur);\n        \n    }   \n}","runtime":"41 ms","title":"Word Ladder II","url":"/submissions/detail/1073833042/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1073833042,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder-ii","timestamp":1697149783,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"43.8 MB","code":"class Solution {\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n        \n        HashSet<String> dict = new HashSet<String>(wordList);\n        if (!dict.contains(endWord)) return new ArrayList<>();\n        dict.add(beginWord);\n        System.out.println(dict.size());\n        List<List<String>> re = new ArrayList<>();\n        HashMap<String,HashSet<String>> map = new HashMap<>();\n\n        for (String s: dict){\n            map.put(s, new HashSet<>());\n        }\n        \n        for (String s1: dict){\n            for (String s2: dict){\n                if (!s1.equals(s2)){\n                    if (comp(s1,s2))\n                        map.get(s1).add(s2);\n                }\n            }\n        }\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        HashMap<String,Integer> shortPath = new HashMap<>();\n        HashMap<String,HashSet<String>> tracer = new HashMap<>();\n\n        for (String s: dict){\n            shortPath.put(s,Integer.MAX_VALUE);\n            tracer.put(s,new HashSet<>());\n        }\n\n        shortPath.put(beginWord,1);\n        \n        bfs.add(beginWord);\n        // int size = 1;\n        while (!bfs.isEmpty()){\n            String cur = bfs.poll();\n            // System.out.println(cur);\n            // System.out.println(visited.size());\n            if (!visited.contains(cur)){\n                visited.add(cur);\n                if (cur.equals(endWord)) break;\n                    for (String s: map.get(cur)){\n                        if (!visited.contains(s)){\n                            bfs.add(s);\n                            int min = shortPath.get(s);\n                            if (shortPath.get(cur)+1<=min){\n                                min = shortPath.get(cur)+1;\n                                shortPath.put(s,min);\n                                tracer.get(s).add(cur);\n                            }\n                        }\n                    }\n            }\n            \n        }\n\n        List<String> temp = new ArrayList<String>();\n        // System.out.println(shortPath.get(endWord));\n        gen(tracer,re,temp,beginWord,endWord);\n        return re;\n    }\n\n    public boolean comp(String s1, String s2){\n        if (s1.length()!=s2.length()) return false;\n        int n = s1.length(); \n        int count =0;\n        for (int i = 0;i<n;i++){\n            if (s1.charAt(i)!=s2.charAt(i))\n                count++;\n            if (count>1) return false;\n        }\n        return true;\n\n    }\n\n    public void gen(HashMap<String,HashSet<String>> tracer,List<List<String>> re, List<String> temp, String beginWord, String cur){\n        temp.add(cur);\n        // System.out.print(cur+\" \");\n        for (String s: tracer.get(cur)){\n            gen(tracer,re,temp,beginWord,s);\n        }\n        if (cur.equals(beginWord)){\n            List<String> t = new ArrayList<>(temp);\n            Collections.reverse(t);\n            re.add(t);\n            // System.out.println();\n        }\n        temp.remove(cur);\n        \n    }   \n}","runtime":"39 ms","title":"Word Ladder II","url":"/submissions/detail/1073832870/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1073832870,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder-ii","timestamp":1697149757,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111"},{"status_display":"Time Limit Exceeded","memory":"N/A","code":"class Solution {\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n        \n        HashSet<String> dict = new HashSet<String>(wordList);\n        if (!dict.contains(endWord)) return new ArrayList<>();\n        dict.add(beginWord);\n\n        List<List<String>> re = new ArrayList<>();\n        HashMap<String,HashSet<String>> map = new HashMap<>();\n\n        for (String s: dict){\n            map.put(s, new HashSet<>());\n        }\n        \n        for (String s1: dict){\n            for (String s2: dict){\n                if (!s1.equals(s2)){\n                    if (comp(s1,s2))\n                        map.get(s1).add(s2);\n                }\n            }\n        }\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        HashMap<String,Integer> shortPath = new HashMap<>();\n        HashMap<String,HashSet<String>> tracer = new HashMap<>();\n\n        for (String s: dict){\n            shortPath.put(s,Integer.MAX_VALUE);\n            tracer.put(s,new HashSet<>());\n        }\n\n        shortPath.put(beginWord,1);\n        \n        bfs.add(beginWord);\n        // int size = 1;\n        while (!bfs.isEmpty()){\n            String cur = bfs.poll();\n            // System.out.println(cur);\n            visited.add(cur);\n            if (cur.equals(endWord)) break;\n                for (String s: map.get(cur)){\n                    if (!visited.contains(s)){\n                        bfs.add(s);\n                        int min = shortPath.get(s);\n                        if (shortPath.get(cur)+1<=min){\n                            min = shortPath.get(cur)+1;\n                            shortPath.put(s,min);\n                            tracer.get(s).add(cur);\n                        }\n                    }\n                }\n        }\n\n        List<String> temp = new ArrayList<String>();\n        System.out.println(shortPath.get(endWord));\n        gen(tracer,re,temp,beginWord,endWord);\n        return re;\n    }\n\n    public boolean comp(String s1, String s2){\n        if (s1.length()!=s2.length()) return false;\n        int n = s1.length(); \n        int count =0;\n        for (int i = 0;i<n;i++){\n            if (s1.charAt(i)!=s2.charAt(i))\n                count++;\n            if (count>1) return false;\n        }\n        return true;\n\n    }\n\n    public void gen(HashMap<String,HashSet<String>> tracer,List<List<String>> re, List<String> temp, String beginWord, String cur){\n        temp.add(cur);\n        // System.out.print(cur+\" \");\n        for (String s: tracer.get(cur)){\n            gen(tracer,re,temp,beginWord,s);\n        }\n        if (cur.equals(beginWord)){\n            List<String> t = new ArrayList<>(temp);\n            Collections.reverse(t);\n            re.add(t);\n            // System.out.println();\n        }\n        temp.remove(cur);\n        \n    }   \n}","runtime":"N/A","title":"Word Ladder II","url":"/submissions/detail/1073807323/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1073807323,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder-ii","timestamp":1697146236,"status":14,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111110000"},{"status_display":"Time Limit Exceeded","memory":"N/A","code":"class Solution {\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n        \n        HashSet<String> dict = new HashSet<String>(wordList);\n        if (!dict.contains(endWord)) return new ArrayList<>();\n        dict.add(beginWord);\n\n        List<List<String>> re = new ArrayList<>();\n        HashMap<String,HashSet<String>> map = new HashMap<>();\n\n        for (String s: dict){\n            map.put(s, new HashSet<>());\n        }\n        \n        for (String s1: dict){\n            for (String s2: dict){\n                if (!s1.equals(s2)){\n                    if (comp(s1,s2))\n                        map.get(s1).add(s2);\n                }\n            }\n        }\n\n        // for (String s: dict){\n        //     System.out.print(s+\": \");\n        //         for (String si: map.get(s)){\n        //             System.out.print(si+\" \");\n        //         }\n        //     System.out.println();\n        // }\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        HashMap<String,Integer> shortPath = new HashMap<>();\n        HashMap<String,HashSet<String>> tracer = new HashMap<>();\n\n        for (String s: dict){\n            shortPath.put(s,Integer.MAX_VALUE);\n            tracer.put(s,new HashSet<>());\n        }\n\n        shortPath.put(beginWord,1);\n        \n        bfs.add(beginWord);\n        // int size = 1;\n        while (!bfs.isEmpty()){\n            String cur = bfs.poll();\n            // System.out.println(cur);\n            visited.add(cur);\n            if (cur.equals(endWord)) break;\n                for (String s: map.get(cur)){\n                    if (!visited.contains(s)){\n                        bfs.add(s);\n                        int min = shortPath.get(s);\n                        if (shortPath.get(cur)+1<=min){\n                            min = shortPath.get(cur)+1;\n                            shortPath.put(s,min);\n                            tracer.get(s).add(cur);\n                        }\n                    }\n                }\n        }\n        // System.out.println(shortPath.get(endWord));\n        // for (String s: dict){\n        //     System.out.print(s+\": \" + shortPath.get(s)+\": \");\n        //         for (String si: tracer.get(s)){\n        //             System.out.print(si+\" \");\n        //         }\n        //     System.out.println();\n        // }\n        List<String> temp = new ArrayList<String>();\n        System.out.println(shortPath.get(endWord));\n        gen(tracer,re,temp,beginWord,endWord);\n        return re;\n    }\n\n    public boolean comp(String s1, String s2){\n        if (s1.length()!=s2.length()) return false;\n        int n = s1.length(); \n        int count =0;\n        for (int i = 0;i<n;i++){\n            if (s1.charAt(i)!=s2.charAt(i))\n                count++;\n            if (count>1) return false;\n        }\n        return true;\n\n    }\n\n    public void gen(HashMap<String,HashSet<String>> tracer,List<List<String>> re, List<String> temp, String beginWord, String cur){\n        temp.add(cur);\n        // System.out.print(cur+\" \");\n        for (String s: tracer.get(cur)){\n            gen(tracer,re,temp,beginWord,s);\n        }\n        if (cur.equals(beginWord)){\n            List<String> t = new ArrayList<>(temp);\n            Collections.reverse(t);\n            re.add(t);\n            // System.out.println();\n        }\n        temp.remove(cur);\n        \n    }   \n}","runtime":"N/A","title":"Word Ladder II","url":"/submissions/detail/1073806540/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1073806540,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder-ii","timestamp":1697146139,"status":14,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111110000"},{"status_display":"Time Limit Exceeded","memory":"N/A","code":"class Solution {\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n        \n        HashSet<String> dict = new HashSet<String>(wordList);\n        if (!dict.contains(endWord)) return new ArrayList<>();\n        dict.add(beginWord);\n\n        List<List<String>> re = new ArrayList<>();\n        HashMap<String,HashSet<String>> map = new HashMap<>();\n\n        for (String s: dict){\n            map.put(s, new HashSet<>());\n        }\n        \n        for (String s1: dict){\n            for (String s2: dict){\n                if (!s1.equals(s2)){\n                    if (comp(s1,s2))\n                        map.get(s1).add(s2);\n                }\n            }\n        }\n\n        // for (String s: dict){\n        //     System.out.print(s+\": \");\n        //         for (String si: map.get(s)){\n        //             System.out.print(si+\" \");\n        //         }\n        //     System.out.println();\n        // }\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        HashMap<String,Integer> shortPath = new HashMap<>();\n        HashMap<String,HashSet<String>> tracer = new HashMap<>();\n\n        for (String s: dict){\n            shortPath.put(s,Integer.MAX_VALUE);\n            tracer.put(s,new HashSet<>());\n        }\n\n        shortPath.put(beginWord,1);\n        \n        bfs.add(beginWord);\n        // int size = 1;\n        while (!bfs.isEmpty()){\n            String cur = bfs.poll();\n            // System.out.println(cur);\n            visited.add(cur);\n            if (cur.equals(endWord)) break;\n                for (String s: map.get(cur)){\n                    if (!visited.contains(s)){\n                        bfs.add(s);\n                        int min = shortPath.get(s);\n                        if (shortPath.get(cur)+1<=min){\n                            min = shortPath.get(cur)+1;\n                            shortPath.put(s,min);\n                            tracer.get(s).add(cur);\n                        }\n                    }\n                }\n        }\n        // System.out.println(shortPath.get(endWord));\n        // for (String s: dict){\n        //     System.out.print(s+\": \" + shortPath.get(s)+\": \");\n        //         for (String si: tracer.get(s)){\n        //             System.out.print(si+\" \");\n        //         }\n        //     System.out.println();\n        // }\n        List<String> temp = new ArrayList<String>();\n        gen(tracer,re,temp,beginWord,endWord);\n        return re;\n    }\n\n    public boolean comp(String s1, String s2){\n        if (s1.length()!=s2.length()) return false;\n        int n = s1.length(); \n        int count =0;\n        for (int i = 0;i<n;i++){\n            if (s1.charAt(i)!=s2.charAt(i))\n                count++;\n            if (count>1) return false;\n        }\n        return true;\n\n    }\n\n    public void gen(HashMap<String,HashSet<String>> tracer,List<List<String>> re, List<String> temp, String beginWord, String cur){\n        temp.add(cur);\n        // System.out.print(cur+\" \");\n        for (String s: tracer.get(cur)){\n            gen(tracer,re,temp,beginWord,s);\n        }\n        if (cur.equals(beginWord)){\n            List<String> t = new ArrayList<>(temp);\n            Collections.reverse(t);\n            re.add(t);\n            // System.out.println();\n        }\n        temp.remove(cur);\n        \n    }   \n}","runtime":"N/A","title":"Word Ladder II","url":"/submissions/detail/1073803125/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1073803125,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder-ii","timestamp":1697145719,"status":14,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111110000"},{"status_display":"Accepted","memory":"44.5 MB","code":"class Solution {\n    public int jump(int[] nums) {\n        int n = nums.length;\n        if (n==1) return 0;\n        int max = 0 + nums[0];\n        int cap = nums[0];\n        int re = 1;\n        for (int i = 1;i<n-1;i++){\n            if (i+ nums[i]>max) {\n                max = i+ nums[i];\n            }\n            if (i == cap){\n                cap = max;\n                re++;\n            }\n        }\n        return re;\n        \n    }\n}","runtime":"1 ms","title":"Jump Game II","url":"/submissions/detail/1073199266/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1073199266,"time":"3 months, 2 weeks","lang":"java","title_slug":"jump-game-ii","timestamp":1697088490,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"44.7 MB","code":"class Solution {\n    public int jump(int[] nums) {\n        int n = nums.length;\n        if (n==1) return 0;\n        int max = 0 + nums[0];\n        int cap = nums[0];\n        int re = 1;\n        for (int i = 1;i<n-1;i++){\n            if (i+ nums[i]>max) {\n                max = i+ nums[i];\n            }\n            if (i == cap){\n                cap = max;\n                re++;\n            }\n        }\n        return re;\n        \n    }\n}","runtime":"1 ms","title":"Jump Game II","url":"/submissions/detail/1073199147/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1073199147,"time":"3 months, 2 weeks","lang":"java","title_slug":"jump-game-ii","timestamp":1697088478,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}],"has_next":true,"last_key":"%7B%22pk%22%3A%20%7B%22N%22%3A%20%221073199147%22%7D%2C%20%22dt%22%3A%20%7B%22S%22%3A%20%222023-10-12T05%3A27%3A58.451936%2B0000%22%7D%2C%20%22sid%22%3A%20%7B%22N%22%3A%20%227573785%22%7D%7D"}
2024-01-26 23:03:27.691 [main] DEBUG submission_dump - {"submissions_dump":[{"status_display":"Accepted","memory":"43.9 MB","code":"class Solution {\n    public int jump(int[] nums) {\n        int n = nums.length;\n        if (n==1) return 0;\n        int [] maxPos = new int [n];\n        for(int i = 0;i<n;i++){\n            maxPos[i] = i + nums[i];\n        }\n        int max = maxPos[0];\n        int cap = nums[0];\n        int re = 1;\n        for (int i = 1;i<n-1;i++){\n            if (maxPos[i]>max) {\n                max = maxPos[i];\n            }\n            if (i == cap){\n                cap = max;\n                re++;\n            }\n        }\n        return re;\n        \n    }\n}","runtime":"1 ms","title":"Jump Game II","url":"/submissions/detail/1073198455/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1073198455,"time":"3 months, 2 weeks","lang":"java","title_slug":"jump-game-ii","timestamp":1697088410,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"44.4 MB","code":"class Solution {\n    public int jump(int[] nums) {\n        int n = nums.length;\n        if (n==1) return 0;\n        int [] maxPos = new int [n];\n        for(int i = 0;i<n;i++){\n            maxPos[i] = i + nums[i];\n        }\n        int max = maxPos[0];\n        int cap = nums[0];\n        int re = 1;\n        int count = 0;\n        int temp = 0;\n        for (int i = 1;i<n-1;i++){\n            if (maxPos[i]>max) {\n                max = maxPos[i];\n                temp = nums[i];\n            }\n            // count++;\n            if (i == cap){\n                cap = max;\n                // count = 0;\n                re++;\n            }\n        }\n        return re;\n        \n    }\n}","runtime":"2 ms","title":"Jump Game II","url":"/submissions/detail/1073198211/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1073198211,"time":"3 months, 2 weeks","lang":"java","title_slug":"jump-game-ii","timestamp":1697088385,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int jump(int[] nums) {\n        int n = nums.length;\n        if (n==1) return 0;\n        int [] maxPos = new int [n];\n        for(int i = 0;i<n;i++){\n            maxPos[i] = i + nums[i];\n        }\n        int max = maxPos[0];\n        int cap = nums[0];\n        int re = 0;\n        int count = 0;\n        int temp = 0;\n        for (int i = 1;i<n;i++){\n            if (maxPos[i]>max) {\n                max = maxPos[i];\n                temp = nums[i];\n            }\n            count++;\n            if (count == 1) re ++;\n            if (count == cap){\n                cap = temp;\n                count = 0;\n            }\n        }\n        return re;\n        \n    }\n}","runtime":"N/A","title":"Jump Game II","url":"/submissions/detail/1073191094/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1073191094,"time":"3 months, 2 weeks","lang":"java","title_slug":"jump-game-ii","timestamp":1697087684,"status":11,"is_pending":"Not Pending","compare_result":"1111111111111111111111111101111101011111111111111111111111111111111010100111001101000000100000111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int jump(int[] nums) {\n        int n = nums.length;\n        if (n==1) return 0;\n        int [] maxPos = new int [n];\n        for(int i = 0;i<n;i++){\n            maxPos[i] = i + nums[i];\n        }\n        int max = maxPos[0];\n        int cap = nums[0];\n        int re = 0;\n        int count = 0;\n        for (int i = 1;i<n;i++){\n            if (maxPos[i]>max) max = maxPos[i];\n            count++;\n            if (count == 1) re ++;\n            if (count == cap){\n                cap = max;\n                count = 0;\n            }\n        }\n        return re;\n        \n    }\n}","runtime":"N/A","title":"Jump Game II","url":"/submissions/detail/1073189748/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1073189748,"time":"3 months, 2 weeks","lang":"java","title_slug":"jump-game-ii","timestamp":1697087554,"status":11,"is_pending":"Not Pending","compare_result":"1111111111011100100111110101111101011100001111111111010110111010000010000000000000000000000000010000001100111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int jump(int[] nums) {\n        int n = nums.length;\n        if (n==1) return 0;\n        int [] maxPos = new int [n];\n        for(int i = 0;i<n;i++){\n            maxPos[i] = i + nums[i];\n        }\n        int max = maxPos[0];\n        int cap = nums[0];\n        int re = 1;\n        int count = 0;\n        for (int i = 1;i<n;i++){\n            if (maxPos[i]>max) max = maxPos[i];\n            count++;\n            if (count == cap){\n                cap = max;\n                re ++;\n                count = 0;\n            }\n        }\n        return re;\n        \n    }\n}","runtime":"N/A","title":"Jump Game II","url":"/submissions/detail/1073187160/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1073187160,"time":"3 months, 2 weeks","lang":"java","title_slug":"jump-game-ii","timestamp":1697087300,"status":11,"is_pending":"Not Pending","compare_result":"1111011110111100110111111100111101011111101011110111010110111110000010000000000000000000000000010000000100100"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int jump(int[] nums) {\n        if (nums[0] == 0) return 0;\n        int n = nums.length;\n        int [] maxPos = new int [n];\n        for(int i = 0;i<n;i++){\n            maxPos[i] = i + nums[i];\n        }\n        int max = maxPos[0];\n        int cap = nums[0];\n        int re = 1;\n        int count = 0;\n        for (int i = 1;i<n;i++){\n            if (maxPos[i]>max) max = maxPos[i];\n            count++;\n            if (count == cap){\n                cap = max;\n                re ++;\n                count = 0;\n            }\n        }\n        return re;\n        \n    }\n}","runtime":"N/A","title":"Jump Game II","url":"/submissions/detail/1073186903/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1073186903,"time":"3 months, 2 weeks","lang":"java","title_slug":"jump-game-ii","timestamp":1697087274,"status":11,"is_pending":"Not Pending","compare_result":"1110011110111100110111111100111101011111101011110111010110111110000010000000000000000000000000010000000100100"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int jump(int[] nums) {\n        int n = nums.length;\n        int [] maxPos = new int [n];\n        for(int i = 0;i<n;i++){\n            maxPos[i] = i + nums[i];\n        }\n        int max = maxPos[0];\n        int cap = nums[0];\n        int re = 1;\n        int count = 0;\n        for (int i = 1;i<n;i++){\n            if (maxPos[i]>max) max = maxPos[i];\n            count++;\n            if (count == cap){\n                cap = max;\n                re ++;\n                count = 0;\n            }\n        }\n        return re;\n        \n    }\n}","runtime":"N/A","title":"Jump Game II","url":"/submissions/detail/1073186404/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1073186404,"time":"3 months, 2 weeks","lang":"java","title_slug":"jump-game-ii","timestamp":1697087229,"status":11,"is_pending":"Not Pending","compare_result":"1100011110111100110111111100111101011111101011110111010110111110000010000000000000000000000000010000000100100"},{"status_display":"Accepted","memory":"43.6 MB","code":"class Solution {\n    public int swimInWater(int[][] grid) {\n        int n = grid.length;\n        PriorityQueue<Data> q = new PriorityQueue<>();\n\n        int cur_x = n-1;\n        int cur_y = n-1;\n        q.add(new Data(grid[cur_x][cur_y],cur_x,cur_y));\n        int max = grid[cur_x][cur_y];\n        boolean [][] marker = new boolean[n][n];\n        // marker[n-1][n-1]= true;\n\n        while (cur_x!=0 || cur_y!=0){\n            Data temp = q.poll();\n            cur_x = temp.x;\n            cur_y = temp.y;\n            marker[cur_x][cur_y] = true;\n            // System.out.println(cur_x+\" \"+cur_y + \" \"+temp.val);\n            if (temp.val > max) max = temp.val;\n            if (cur_x>0 && !marker[cur_x-1][cur_y])\n            {\n                int x = cur_x -1;\n                int y = cur_y;\n                q.add(new Data(grid[x][y],x,y));\n            }\n            if (cur_y>0 && !marker[cur_x][cur_y-1]){\n                int x = cur_x;\n                int y= cur_y - 1;\n                q.add(new Data(grid[x][y],x,y));\n            }\n            if (cur_x+1<n && !marker[cur_x+1][cur_y]){\n                int x = cur_x + 1;\n                int y = cur_y;\n                q.add(new Data(grid[x][y],x,y));\n            }\n            if (cur_y+1<n && !marker[cur_x][cur_y+1]){\n                int x = cur_x;\n                int y = cur_y + 1;\n                q.add(new Data(grid[x][y],x,y));\n            }\n            // for (Data d: q){\n            //     System.out.println(d);\n            // }\n            // System.out.println(\"******\");\n                \n        }\n\n        return max;     \n    }\n}\n\nclass Data implements Comparable<Data>{\n    int val;\n    int x;\n    int y;\n    public Data(int val, int x, int y){\n        this.val = val;\n        this.x = x;\n        this.y = y;\n    }\n        @Override\n    \tpublic int compareTo(Data o) {\n\t\t// TODO Auto-generated method stub\n\t\treturn Integer.compare(val,o.val);\n        }\n\n        @Override\n        public String toString(){\n            return x+\" \"+y+\": \"+val;\n        }\n\t\n}","runtime":"17 ms","title":"Swim in Rising Water","url":"/submissions/detail/1073026486/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1073026486,"time":"3 months, 2 weeks","lang":"java","title_slug":"swim-in-rising-water","timestamp":1697067092,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"44.3 MB","code":"class Solution {\n    public List<String> findItinerary(List<List<String>> tickets) {\n\t        HashMap<String,List<String>> map = new HashMap<>();\n\t        HashMap<String,Integer> in = new HashMap<>();\n\t        HashMap<String,Integer> out = new HashMap<>();\n\t        List<String> path = new LinkedList<>();\n\t        for (List<String> i : tickets){\n\t            if (map.keySet().contains(i.get(0))){\n\t                map.get(i.get(0)).add(i.get(1));\n\t            } else{\n\t                map.put(i.get(0),new ArrayList<>());\n\t                map.get(i.get(0)).add(i.get(1));\n\t            }\n\t            if (!map.keySet().contains(i.get(1))){\n\t                map.put(i.get(1),new ArrayList<>());\n\t            }\n\t        }\n\t        for (String s : map.keySet()){\n\t            in.put(s,0);\n\t            out.put(s,0);\n\t        }\n\n\t        for (List<String> i:tickets){\n\t            String fr = i.get(0);\n\t            String to = i.get(1);\n\t            out.put(fr,out.get(fr)+1);\n\t            in.put(to,in.get(to)+1);\n\t        }\n            for (String i: map.keySet()){\n                Collections.sort(map.get(i),Collections.reverseOrder());\n            }\n\n\t        //since the problem assume there is a path starting from JFK, im not writing code to check for ecluid path (there is 1 start and 1 end or all equal)\n\t        for (String i : map.keySet()){\n\t            System.out.print(i+\":\");\n\t            for (String j: map.get(i)){\n\t                System.out.print(j+\", \");\n\t            }\n\t            System.out.println(in.get(i)+\" \"+out.get(i));\n\t        }\n\t        dfs(\"JFK\",map,out,path);\n\t        \n\n\t        return path;\n\t        \n\t    }\n\n\t    public void dfs(String cur, HashMap<String,List<String>> map, HashMap<String,Integer> out, List<String> path){\n\t        System.out.println(cur +\" \"+ out.get(cur));\n\t        while(out.get(cur)!=0){\n\t            out.put(cur,out.get(cur)-1);\n\t            dfs(map.get(cur).get(out.get(cur)),map,out,path);\n\n\t            // for (String s:map.get(cur)){\n\t            // }\n\t        }\n\t        path.add(0,cur);\n\t    }\n}","runtime":"49 ms","title":"Reconstruct Itinerary","url":"/submissions/detail/1072990876/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072990876,"time":"3 months, 2 weeks","lang":"java","title_slug":"reconstruct-itinerary","timestamp":1697061691,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"44.5 MB","code":"class Solution {\n    public List<String> findItinerary(List<List<String>> tickets) {\n\t        HashMap<String,List<String>> map = new HashMap<>();\n\t        HashMap<String,Integer> in = new HashMap<>();\n\t        HashMap<String,Integer> out = new HashMap<>();\n\t        List<String> path = new LinkedList<>();\n\t        for (List<String> i : tickets){\n\t            if (map.keySet().contains(i.get(0))){\n\t                map.get(i.get(0)).add(i.get(1));\n\t            } else{\n\t                map.put(i.get(0),new ArrayList<>());\n\t                map.get(i.get(0)).add(i.get(1));\n\t            }\n\t            if (!map.keySet().contains(i.get(1))){\n\t                map.put(i.get(1),new ArrayList<>());\n\t            }\n\t        }\n\t        for (String s : map.keySet()){\n\t            in.put(s,0);\n\t            out.put(s,0);\n\t        }\n\n\t        for (List<String> i:tickets){\n\t            String fr = i.get(0);\n\t            String to = i.get(1);\n\t            out.put(fr,out.get(fr)+1);\n\t            in.put(to,in.get(to)+1);\n\t        }\n            for (String i: map.keySet()){\n                Collections.sort(map.get(i),Collections.reverseOrder());\n            }\n\n\t        //since the problem assume there is a path starting from JFK, im not writing code to check for ecluid path (there is 1 start and 1 end or all equal)\n\t        for (String i : map.keySet()){\n\t            System.out.print(i+\":\");\n\t            for (String j: map.get(i)){\n\t                System.out.print(j+\", \");\n\t            }\n\t            System.out.println(in.get(i)+\" \"+out.get(i));\n\t        }\n\t        dfs(\"JFK\",map,out,path);\n\t        \n\n\t        return path;\n\t        \n\t    }\n\n\t    public void dfs(String cur, HashMap<String,List<String>> map, HashMap<String,Integer> out, List<String> path){\n\t        System.out.println(cur +\" \"+ out.get(cur));\n\t        while(out.get(cur)!=0){\n\t            out.put(cur,out.get(cur)-1);\n\t            dfs(map.get(cur).get(out.get(cur)),map,out,path);\n\n\t            // for (String s:map.get(cur)){\n\t            // }\n\t        }\n\t        path.add(0,cur);\n\t    }\n}","runtime":"50 ms","title":"Reconstruct Itinerary","url":"/submissions/detail/1072987982/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072987982,"time":"3 months, 2 weeks","lang":"java","title_slug":"reconstruct-itinerary","timestamp":1697061293,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"47.4 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashSet<String> list = new HashSet<String>();\n        for (String s:wordList){\n            list.add(s);\n        }\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        for (String s:list){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        bfs.add(beginWord);\n        shortPath.put(beginWord,1);\n\n        while(!bfs.isEmpty()){\n            String cur = bfs.poll();\n            if (cur.equals(endWord)){\n                break;\n            }\n            int n = cur.length();\n            for (int i=0;i<n;i++){\n                char [] cList = cur.toCharArray();\n                for (char c = 'a';c<='z';c++){\n                    cList[i] = c;\n                    String temp = new String(cList);\n                    // System.out.println(temp);\n                    if (list.contains(temp) && !visited.contains(temp)){\n                        bfs.add(temp);\n                        shortPath.put(temp,Integer.min(shortPath.get(temp),shortPath.get(cur)+1));\n                        visited.add(temp);\n\n                    }\n                }\n            }\n            // break;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n\n}","runtime":"78 ms","title":"Word Ladder","url":"/submissions/detail/1072911648/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072911648,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1697052526,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"46.8 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        Set<String> set = new HashSet<>(wordList);\n        if (!set.contains(endWord)) return 0;\n\n        Queue<String> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n\n        queue.add(beginWord);\n\n        visited.add(beginWord);\n        int changes = 1;\n        while(!queue.isEmpty()){\n            int size = queue.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = queue.poll();\n                // visited.add(cur);\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] arr = cur.toCharArray();\n                    for (int k = 'a';k<='z';k++){\n                        arr[i] = (char)k;\n                        String temp = new String(arr);\n                        if (set.contains(temp) && !visited.contains(temp)){\n                            queue.add(temp);\n                            visited.add(temp);\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}","runtime":"72 ms","title":"Word Ladder","url":"/submissions/detail/1072229299/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072229299,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696983655,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"46.5 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        Set<String> set = new HashSet<>(wordList);\n        if (!set.contains(endWord)) return 0;\n\n        Queue<String> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n\n        queue.add(beginWord);\n\n        visited.add(beginWord);\n        int changes = 1;\n        while(!queue.isEmpty()){\n            int size = queue.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = queue.poll();\n                visited.add(cur);\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] arr = cur.toCharArray();\n                    for (int k = 'a';k<='z';k++){\n                        arr[i] = (char)k;\n                        String temp = new String(arr);\n                        if (set.contains(temp) && !visited.contains(temp)){\n                            queue.add(temp);\n                            visited.add(temp);\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}","runtime":"74 ms","title":"Word Ladder","url":"/submissions/detail/1072229199/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072229199,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696983641,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"54 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        Set<String> set = new HashSet<>(wordList);\n        if (!set.contains(endWord)) return 0;\n\n        Queue<String> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n\n        queue.add(beginWord);\n\n        visited.add(beginWord);\n        int changes = 1;\n        while(!queue.isEmpty()){\n            int size = queue.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = queue.poll();\n                visited.add(cur);\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] arr = cur.toCharArray();\n                    for (int k = 'a';k<='z';k++){\n                        arr[i] = (char)k;\n                        String temp = new String(arr);\n                        if (set.contains(temp) && !visited.contains(temp)){\n                            queue.add(temp);\n                            visited.add(cur);\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}","runtime":"1363 ms","title":"Word Ladder","url":"/submissions/detail/1072229095/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072229095,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696983626,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"55.1 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        Set<String> set = new HashSet<>(wordList);\n        if (!set.contains(endWord)) return 0;\n\n        Queue<String> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n\n        queue.add(beginWord);\n\n        visited.add(beginWord);\n        int changes = 1;\n        while(!queue.isEmpty()){\n            int size = queue.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = queue.poll();\n                visited.add(cur);\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] arr = cur.toCharArray();\n                    for (int c = 'a';c<='z';c++){\n                        arr[i] = (char)c;\n                        String temp = new String(arr);\n                        if (set.contains(temp) && !visited.contains(temp)){\n                            queue.add(temp);\n                            visited.add(cur);\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}","runtime":"1383 ms","title":"Word Ladder","url":"/submissions/detail/1072228950/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072228950,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696983606,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"54.6 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        Set<String> set = new HashSet<>(wordList);\n        if (!set.contains(endWord)) return 0;\n\n        Queue<String> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n\n        queue.add(beginWord);\n\n        visited.add(beginWord);\n        int changes = 1;\n        while(!queue.isEmpty()){\n            int size = queue.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = queue.poll();\n                visited.add(cur);\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] cList = cur.toCharArray();\n                    for (char c = 'a';c<='z';c++){\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        if (set.contains(temp) && !visited.contains(temp)){\n                            queue.add(temp);\n                            visited.add(cur);\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}","runtime":"1347 ms","title":"Word Ladder","url":"/submissions/detail/1072228537/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072228537,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696983538,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Compile Error","memory":"N/A","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, set<String> wordList) {\n        Set<String> set = new HashSet<>(wordList);\n        if (!set.contains(endWord)) return 0;\n\n        Queue<String> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n\n        queue.add(beginWord);\n\n        visited.add(beginWord);\n        int changes = 1;\n        while(!queue.isEmpty()){\n            int size = queue.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = queue.poll();\n                visited.add(cur);\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] cList = cur.toCharArray();\n                    for (char c = 'a';c<='z';c++){\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        if (set.contains(temp) && !visited.contains(temp)){\n                            queue.add(temp);\n                            visited.add(cur);\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}","runtime":"N/A","title":"Word Ladder","url":"/submissions/detail/1072228421/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072228421,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696983519,"status":20,"is_pending":"Not Pending","compare_result":null},{"status_display":"Accepted","memory":"54.2 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        Set<String> list = new HashSet<>(wordList);\n        if (!list.contains(endWord)) return 0;\n\n        Queue<String> bfs = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n\n        bfs.add(beginWord);\n\n        visited.add(beginWord);\n        int changes = 1;\n        while(!bfs.isEmpty()){\n            int size = bfs.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = bfs.poll();\n                visited.add(cur);\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] cList = cur.toCharArray();\n                    for (char c = 'a';c<='z';c++){\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        if (list.contains(temp) && !visited.contains(temp)){\n                            bfs.add(temp);\n                            visited.add(cur);\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}","runtime":"1387 ms","title":"Word Ladder","url":"/submissions/detail/1072228002/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072228002,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696983455,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"54.5 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        Set<String> list = new HashSet<String>(wordList);\n        if (!list.contains(endWord)) return 0;\n\n        Queue<String> bfs = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n\n        bfs.add(beginWord);\n\n        visited.add(beginWord);\n        int changes = 1;\n        while(!bfs.isEmpty()){\n            int size = bfs.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = bfs.poll();\n                visited.add(cur);\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] cList = cur.toCharArray();\n                    for (char c = 'a';c<='z';c++){\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        if (list.contains(temp) && !visited.contains(temp)){\n                            bfs.add(temp);\n                            visited.add(cur);\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}","runtime":"1363 ms","title":"Word Ladder","url":"/submissions/detail/1072227878/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072227878,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696983437,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"54.2 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        HashSet<String> list = new HashSet<String>(wordList);\n        if (!list.contains(endWord)) return 0;\n\n        Queue<String> bfs = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n\n        bfs.add(beginWord);\n\n        visited.add(beginWord);\n        int changes = 1;\n        while(!bfs.isEmpty()){\n            int size = bfs.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = bfs.poll();\n                visited.add(cur);\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] cList = cur.toCharArray();\n                    for (char c = 'a';c<='z';c++){\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        if (list.contains(temp) && !visited.contains(temp)){\n                            bfs.add(temp);\n                            visited.add(cur);\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}","runtime":"1366 ms","title":"Word Ladder","url":"/submissions/detail/1072226524/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072226524,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696983222,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"}],"has_next":true,"last_key":"%7B%22pk%22%3A%20%7B%22N%22%3A%20%221072226524%22%7D%2C%20%22dt%22%3A%20%7B%22S%22%3A%20%222023-10-11T00%3A13%3A42.327027%2B0000%22%7D%2C%20%22sid%22%3A%20%7B%22N%22%3A%20%227573785%22%7D%7D"}
2024-01-26 23:03:38.203 [main] DEBUG submission_dump - {"submissions_dump":[{"status_display":"Accepted","memory":"54.5 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        HashSet<String> list = new HashSet<String>(wordList);\n        if (!list.contains(endWord)) return 0;\n\n        Queue<String> bfs = new LinkedList<>();\n        HashSet<String> visited = new HashSet<>();\n\n        bfs.add(beginWord);\n\n        visited.add(beginWord);\n        int changes = 1;\n        while(!bfs.isEmpty()){\n            int size = bfs.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = bfs.poll();\n                visited.add(cur);\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] cList = cur.toCharArray();\n                    for (char c = 'a';c<='z';c++){\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        if (list.contains(temp) && !visited.contains(temp)){\n                            bfs.add(temp);\n                            visited.add(cur);\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}","runtime":"1360 ms","title":"Word Ladder","url":"/submissions/detail/1072226008/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072226008,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696983139,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Time Limit Exceeded","memory":"N/A","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        HashSet<String> list = new HashSet<String>(wordList);\n        if (!list.contains(endWord)) return 0;\n\n        Queue<String> bfs = new LinkedList<>();\n        HashSet<String> visited = new HashSet<>();\n\n        bfs.add(beginWord);\n\n        visited.add(beginWord);\n        int changes = 1;\n        while(!bfs.isEmpty()){\n            int size = bfs.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = bfs.poll();\n                // visited.add(cur);\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    for (char c = 'a';c<='z';c++){\n                        char [] cList = cur.toCharArray();\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        if (list.contains(temp) && !visited.contains(temp)){\n                            bfs.add(temp);\n                            visited.add(cur);\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}","runtime":"N/A","title":"Word Ladder","url":"/submissions/detail/1072225838/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072225838,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696983114,"status":14,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"54.5 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        HashSet<String> list = new HashSet<String>(wordList);\n        if (!list.contains(endWord)) return 0;\n\n        Queue<String> bfs = new LinkedList<>();\n        HashSet<String> visited = new HashSet<>();\n\n        bfs.add(beginWord);\n\n        visited.add(beginWord);\n        int changes = 1;\n        while(!bfs.isEmpty()){\n            int size = bfs.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = bfs.poll();\n                visited.add(cur);\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    for (char c = 'a';c<='z';c++){\n                        char [] cList = cur.toCharArray();\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        if (list.contains(temp) && !visited.contains(temp)){\n                            bfs.add(temp);\n                            visited.add(cur);\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}","runtime":"1754 ms","title":"Word Ladder","url":"/submissions/detail/1072225796/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072225796,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696983106,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"54.4 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        HashSet<String> list = new HashSet<String>(wordList);\n        if (!list.contains(endWord)) return 0;\n\n        Queue<String> bfs = new LinkedList<>();\n        HashSet<String> visited = new HashSet<>();\n\n        bfs.add(beginWord);\n        bfs.add(beginWord);\n\n        visited.add(beginWord);\n        int changes = 1;\n        while(!bfs.isEmpty()){\n            int size = bfs.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = bfs.poll();\n                visited.add(cur);\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] cList = cur.toCharArray();\n                    for (char c = 'a';c<='z';c++){\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        if (list.contains(temp) && !visited.contains(temp)){\n                            bfs.add(temp);\n                            visited.add(cur);\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}","runtime":"1665 ms","title":"Word Ladder","url":"/submissions/detail/1072225419/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072225419,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696983048,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"54.7 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        HashSet<String> list = new HashSet<String>(wordList);\n        if (!list.contains(endWord)) return 0;\n\n        Queue<String> bfs = new LinkedList<>();\n        HashSet<String> visited = new HashSet<>();\n\n        bfs.add(beginWord);\n        visited.add(beginWord);\n        int changes = 1;\n        while(!bfs.isEmpty()){\n            int size = bfs.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = bfs.poll();\n                visited.add(cur);\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] cList = cur.toCharArray();\n                    for (char c = 'a';c<='z';c++){\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        if (list.contains(temp) && !visited.contains(temp)){\n                            bfs.add(temp);\n                            visited.add(cur);\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}","runtime":"1383 ms","title":"Word Ladder","url":"/submissions/detail/1072225117/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072225117,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696983003,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"54.2 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        HashSet<String> list = new HashSet<String>(wordList);\n        if (!list.contains(endWord)) return 0;\n\n        Queue<String> bfs = new LinkedList<>();\n        HashSet<String> visited = new HashSet<>();\n\n        bfs.add(beginWord);\n        visited.add(beginWord);\n        int changes = 1;\n        while(!bfs.isEmpty()){\n            int size = bfs.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = bfs.poll();\n                visited.add(cur);\n\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] cList = cur.toCharArray();\n                    for (char c = 'a';c<='z';c++){\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        if (list.contains(temp) && !visited.contains(temp)){\n                            bfs.add(temp);\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}","runtime":"1336 ms","title":"Word Ladder","url":"/submissions/detail/1072224750/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072224750,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696982939,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"54.3 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        HashSet<String> list = new HashSet<String>(wordList);\n        if (!list.contains(endWord)) return 0;\n\n        Queue<String> bfs = new LinkedList<>();\n        HashSet<String> visited = new HashSet<>();\n        // HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        // for (String s:list){\n        //     shortPath.put(s,Integer.MAX_VALUE);\n        // }\n        bfs.add(beginWord);\n        // shortPath.put(beginWord,1);\n        visited.add(beginWord);\n        int changes = 1;\n        while(!bfs.isEmpty()){\n            int size = bfs.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = bfs.poll();\n                visited.add(cur);\n\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] cList = cur.toCharArray();\n                    for (char c = 'a';c<='z';c++){\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        // System.out.println(temp);\n                        if (list.contains(temp) && !visited.contains(temp)){\n                            bfs.add(temp);\n                            // shortPath.put(temp,Integer.min(shortPath.get(temp),shortPath.get(cur)+1));\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}","runtime":"1347 ms","title":"Word Ladder","url":"/submissions/detail/1072224436/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072224436,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696982886,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"54.8 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        HashSet<String> list = new HashSet<String>(wordList);\n        if (!list.contains(endWord)) return 0;\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        // HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        // for (String s:list){\n        //     shortPath.put(s,Integer.MAX_VALUE);\n        // }\n        bfs.add(beginWord);\n        // shortPath.put(beginWord,1);\n        visited.add(beginWord);\n        int changes = 1;\n        while(!bfs.isEmpty()){\n            int size = bfs.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = bfs.poll();\n                visited.add(cur);\n\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] cList = cur.toCharArray();\n                    for (char c = 'a';c<='z';c++){\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        // System.out.println(temp);\n                        if (list.contains(temp) && !visited.contains(temp)){\n                            bfs.add(temp);\n                            // shortPath.put(temp,Integer.min(shortPath.get(temp),shortPath.get(cur)+1));\n\n                        }\n                    }\n                }\n            }\n            ++changes;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}","runtime":"1360 ms","title":"Word Ladder","url":"/submissions/detail/1072222162/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072222162,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696982507,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"54.4 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashSet<String> list = new HashSet<String>(wordList);\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        // HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        // for (String s:list){\n        //     shortPath.put(s,Integer.MAX_VALUE);\n        // }\n        bfs.add(beginWord);\n        // shortPath.put(beginWord,1);\n        visited.add(beginWord);\n        int changes = 1;\n        while(!bfs.isEmpty()){\n            int size = bfs.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = bfs.poll();\n                visited.add(cur);\n\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] cList = cur.toCharArray();\n                    for (char c = 'a';c<='z';c++){\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        // System.out.println(temp);\n                        if (list.contains(temp) && !visited.contains(temp)){\n                            bfs.add(temp);\n                            // shortPath.put(temp,Integer.min(shortPath.get(temp),shortPath.get(cur)+1));\n\n                        }\n                    }\n                }\n            }\n            ++changes;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}","runtime":"1371 ms","title":"Word Ladder","url":"/submissions/detail/1072218687/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072218687,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696981956,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"54.8 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashSet<String> list = new HashSet<String>(wordList);\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        // HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        // for (String s:list){\n        //     shortPath.put(s,Integer.MAX_VALUE);\n        // }\n        bfs.add(beginWord);\n        // shortPath.put(beginWord,1);\n        visited.add(beginWord);\n        int changes = 1;\n        while(!bfs.isEmpty()){\n            int size = bfs.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = bfs.poll();\n                visited.add(cur);\n\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] cList = cur.toCharArray();\n                    for (char c = 'a';c<='z';c++){\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        // System.out.println(temp);\n                        if (list.contains(temp) && !visited.contains(temp)){\n                            bfs.add(temp);\n                            // shortPath.put(temp,Integer.min(shortPath.get(temp),shortPath.get(cur)+1));\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}","runtime":"1377 ms","title":"Word Ladder","url":"/submissions/detail/1072218213/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072218213,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696981879,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"54.6 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashSet<String> list = new HashSet<String>(wordList);\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        // HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        // for (String s:list){\n        //     shortPath.put(s,Integer.MAX_VALUE);\n        // }\n        bfs.add(beginWord);\n        // shortPath.put(beginWord,1);\n        visited.add(beginWord);\n        int changes = 1;\n        while(!bfs.isEmpty()){\n            int size = bfs.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = bfs.poll();\n                visited.add(cur);\n\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    for (char c = 'a';c<='z';c++){\n                        char [] cList = cur.toCharArray();\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        // System.out.println(temp);\n                        if (list.contains(temp) && !visited.contains(temp)){\n                            bfs.add(temp);\n                            // shortPath.put(temp,Integer.min(shortPath.get(temp),shortPath.get(cur)+1));\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}","runtime":"1748 ms","title":"Word Ladder","url":"/submissions/detail/1072218044/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072218044,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696981854,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"54.6 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashSet<String> list = new HashSet<String>(wordList);\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        // HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        // for (String s:list){\n        //     shortPath.put(s,Integer.MAX_VALUE);\n        // }\n        bfs.add(beginWord);\n        // shortPath.put(beginWord,1);\n        visited.add(beginWord);\n        int changes = 1;\n        while(!bfs.isEmpty()){\n            int size = bfs.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = bfs.poll();\n                visited.add(cur);\n\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] cList = cur.toCharArray();\n                    for (char c = 'a';c<='z';c++){\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        // System.out.println(temp);\n                        if (list.contains(temp) && !visited.contains(temp)){\n                            bfs.add(temp);\n                            // shortPath.put(temp,Integer.min(shortPath.get(temp),shortPath.get(cur)+1));\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}","runtime":"1353 ms","title":"Word Ladder","url":"/submissions/detail/1072217462/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072217462,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696981764,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"46.5 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        Set<String> set = new HashSet<>(wordList);\n        if(!set.contains(endWord)) return 0;\n        \n        Queue<String> queue = new LinkedList<>();\n        queue.add(beginWord);\n        \n        Set<String> visited = new HashSet<>();\n        queue.add(beginWord);\n        \n        int changes = 1;\n        \n        while(!queue.isEmpty()){\n            int size = queue.size();\n            for(int i = 0; i < size; i++){\n                String word = queue.poll();\n                if(word.equals(endWord)) return changes;\n                \n                for(int j = 0; j < word.length(); j++){\n                    for(int k = 'a'; k <= 'z'; k++){\n                        char arr[] = word.toCharArray();\n                        arr[j] = (char) k;\n                        \n                        String str = new String(arr);\n                        if(set.contains(str) && !visited.contains(str)){\n                            queue.add(str);\n                            visited.add(str);\n                        }\n                    }\n                }\n            }\n            ++changes;\n        }\n        return 0;\n    }\n\n\n\n}","runtime":"93 ms","title":"Word Ladder","url":"/submissions/detail/1072216668/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072216668,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696981643,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Compile Error","memory":"N/A","code":"class Solution {\n\n    ppublic int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        Set<String> set = new HashSet<>(wordList);\n        if(!set.contains(endWord)) return 0;\n        \n        Queue<String> queue = new LinkedList<>();\n        queue.add(beginWord);\n        \n        Set<String> visited = new HashSet<>();\n        queue.add(beginWord);\n        \n        int changes = 1;\n        \n        while(!queue.isEmpty()){\n            int size = queue.size();\n            for(int i = 0; i < size; i++){\n                String word = queue.poll();\n                if(word.equals(endWord)) return changes;\n                \n                for(int j = 0; j < word.length(); j++){\n                    for(int k = 'a'; k <= 'z'; k++){\n                        char arr[] = word.toCharArray();\n                        arr[j] = (char) k;\n                        \n                        String str = new String(arr);\n                        if(set.contains(str) && !visited.contains(str)){\n                            queue.add(str);\n                            visited.add(str);\n                        }\n                    }\n                }\n            }\n            ++changes;\n        }\n        return 0;\n    }\n\n\n\n}","runtime":"N/A","title":"Word Ladder","url":"/submissions/detail/1072216615/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072216615,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696981634,"status":20,"is_pending":"Not Pending","compare_result":null},{"status_display":"Accepted","memory":"55 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashSet<String> list = new HashSet<String>(wordList);\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        // for (String s:list){\n        //     shortPath.put(s,Integer.MAX_VALUE);\n        // }\n        bfs.add(beginWord);\n        shortPath.put(beginWord,1);\n        visited.add(beginWord);\n        int changes = 1;\n        while(!bfs.isEmpty()){\n            int size = bfs.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = bfs.poll();\n                visited.add(cur);\n\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] cList = cur.toCharArray();\n                    for (char c = 'a';c<='z';c++){\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        // System.out.println(temp);\n                        if (list.contains(temp) && !visited.contains(temp)){\n                            bfs.add(temp);\n                            // shortPath.put(temp,Integer.min(shortPath.get(temp),shortPath.get(cur)+1));\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}","runtime":"1360 ms","title":"Word Ladder","url":"/submissions/detail/1072216455/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072216455,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696981607,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"54.7 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashSet<String> list = new HashSet<String>(wordList);\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        // for (String s:list){\n        //     shortPath.put(s,Integer.MAX_VALUE);\n        // }\n        bfs.add(beginWord);\n        shortPath.put(beginWord,1);\n        visited.add(beginWord);\n        int changes = 1;\n        while(!bfs.isEmpty()){\n            int size = bfs.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = bfs.poll();\n                // visited.add(cur);\n\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] cList = cur.toCharArray();\n                    for (char c = 'a';c<='z';c++){\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        // System.out.println(temp);\n                        if (list.contains(temp) && !visited.contains(temp)){\n                            bfs.add(temp);\n                            // shortPath.put(temp,Integer.min(shortPath.get(temp),shortPath.get(cur)+1));\n                            visited.add(cur);\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}","runtime":"2354 ms","title":"Word Ladder","url":"/submissions/detail/1072216312/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072216312,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696981588,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"54.4 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashSet<String> list = new HashSet<String>(wordList);\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        // for (String s:list){\n        //     shortPath.put(s,Integer.MAX_VALUE);\n        // }\n        bfs.add(beginWord);\n        shortPath.put(beginWord,1);\n        visited.add(beginWord);\n        int changes = 1;\n        while(!bfs.isEmpty()){\n            int size = bfs.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = bfs.poll();\n                visited.add(cur);\n\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] cList = cur.toCharArray();\n                    for (char c = 'a';c<='z';c++){\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        // System.out.println(temp);\n                        if (list.contains(temp) && !visited.contains(temp)){\n                            bfs.add(temp);\n                            // shortPath.put(temp,Integer.min(shortPath.get(temp),shortPath.get(cur)+1));\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}","runtime":"1329 ms","title":"Word Ladder","url":"/submissions/detail/1072215742/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072215742,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696981495,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"54.5 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashSet<String> list = new HashSet<String>(wordList);\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        // for (String s:list){\n        //     shortPath.put(s,Integer.MAX_VALUE);\n        // }\n        bfs.add(beginWord);\n        shortPath.put(beginWord,1);\n        visited.add(beginWord);\n        int changes = 1;\n        while(!bfs.isEmpty()){\n            int size = bfs.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = bfs.poll();\n                visited.add(cur);\n\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] cList = cur.toCharArray();\n                    for (char c = 'a';c<='z';c++){\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        // System.out.println(temp);\n                        if (list.contains(temp) && !visited.contains(temp)){\n                            bfs.add(temp);\n                            // shortPath.put(temp,Integer.min(shortPath.get(temp),shortPath.get(cur)+1));\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}","runtime":"1354 ms","title":"Word Ladder","url":"/submissions/detail/1072215681/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072215681,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696981485,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"54.3 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashSet<String> list = new HashSet<String>(wordList);\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        for (String s:list){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        bfs.add(beginWord);\n        shortPath.put(beginWord,1);\n        visited.add(beginWord);\n\n        while(!bfs.isEmpty()){\n            String cur = bfs.poll();\n            visited.add(cur);\n\n            if (cur.equals(endWord)){\n                return shortPath.get(endWord);\n            }\n            int n = cur.length();\n            for (int i=0;i<n;i++){\n                char [] cList = cur.toCharArray();\n                for (char c = 'a';c<='z';c++){\n                    cList[i] = c;\n                    String temp = new String(cList);\n                    // System.out.println(temp);\n                    if (list.contains(temp) && !visited.contains(temp)){\n                        bfs.add(temp);\n                        shortPath.put(temp,Integer.min(shortPath.get(temp),shortPath.get(cur)+1));\n\n                    }\n                }\n            }\n            // break;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n\n}","runtime":"1366 ms","title":"Word Ladder","url":"/submissions/detail/1072213925/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072213925,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696981200,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"55 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashSet<String> list = new HashSet<String>(wordList);\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        for (String s:list){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        bfs.add(beginWord);\n        shortPath.put(beginWord,1);\n        visited.add(beginWord);\n\n        while(!bfs.isEmpty()){\n            String cur = bfs.poll();\n            if (cur.equals(endWord)){\n                return shortPath.get(endWord);\n            }\n            int n = cur.length();\n            for (int i=0;i<n;i++){\n                char [] cList = cur.toCharArray();\n                for (char c = 'a';c<='z';c++){\n                    cList[i] = c;\n                    String temp = new String(cList);\n                    // System.out.println(temp);\n                    if (list.contains(temp) && !visited.contains(temp)){\n                        bfs.add(temp);\n                        shortPath.put(temp,Integer.min(shortPath.get(temp),shortPath.get(cur)+1));\n                        visited.add(cur);\n\n                    }\n                }\n            }\n            // break;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n\n}","runtime":"2338 ms","title":"Word Ladder","url":"/submissions/detail/1072213596/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072213596,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696981144,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"}],"has_next":true,"last_key":"%7B%22pk%22%3A%20%7B%22N%22%3A%20%221072213596%22%7D%2C%20%22dt%22%3A%20%7B%22S%22%3A%20%222023-10-10T23%3A39%3A04.953174%2B0000%22%7D%2C%20%22sid%22%3A%20%7B%22N%22%3A%20%227573785%22%7D%7D"}
2024-01-26 23:03:48.754 [main] DEBUG submission_dump - {"submissions_dump":[{"status_display":"Accepted","memory":"54.4 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashSet<String> list = new HashSet<String>(wordList);\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        for (String s:list){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        bfs.add(beginWord);\n        shortPath.put(beginWord,1);\n\n        while(!bfs.isEmpty()){\n            String cur = bfs.poll();\n            if (cur.equals(endWord)){\n                return shortPath.get(endWord);\n            }\n            int n = cur.length();\n            for (int i=0;i<n;i++){\n                char [] cList = cur.toCharArray();\n                for (char c = 'a';c<='z';c++){\n                    cList[i] = c;\n                    String temp = new String(cList);\n                    // System.out.println(temp);\n                    if (list.contains(temp) && !visited.contains(temp)){\n                        bfs.add(temp);\n                        shortPath.put(temp,Integer.min(shortPath.get(temp),shortPath.get(cur)+1));\n                        visited.add(cur);\n\n                    }\n                }\n            }\n            // break;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n\n}","runtime":"2443 ms","title":"Word Ladder","url":"/submissions/detail/1072213444/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072213444,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696981120,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"54.6 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashSet<String> list = new HashSet<String>(wordList);\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        for (String s:list){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        bfs.add(beginWord);\n        shortPath.put(beginWord,1);\n\n        while(!bfs.isEmpty()){\n            String cur = bfs.poll();\n            if (cur.equals(endWord)){\n                return shortPath.get(endWord);\n            }\n            int n = cur.length();\n            for (int i=0;i<n;i++){\n                char [] cList = cur.toCharArray();\n                for (char c = 'a';c<='z';c++){\n                    cList[i] = c;\n                    String temp = new String(cList);\n                    // System.out.println(temp);\n                    if (list.contains(temp) && !visited.contains(temp)){\n                        bfs.add(temp);\n                        shortPath.put(temp,Integer.min(shortPath.get(temp),shortPath.get(cur)+1));\n                        visited.add(cur);\n\n                    }\n                }\n            }\n            // break;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n\n}","runtime":"2416 ms","title":"Word Ladder","url":"/submissions/detail/1072213356/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072213356,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696981106,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"54.6 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashSet<String> list = new HashSet<String>(wordList);\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        for (String s:list){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        bfs.add(beginWord);\n        shortPath.put(beginWord,1);\n\n        while(!bfs.isEmpty()){\n            String cur = bfs.poll();\n            if (cur.equals(endWord)){\n                return shortPath.get(endWord);\n            }\n            visited.add(cur);\n            int n = cur.length();\n            for (int i=0;i<n;i++){\n                char [] cList = cur.toCharArray();\n                for (char c = 'a';c<='z';c++){\n                    cList[i] = c;\n                    String temp = new String(cList);\n                    // System.out.println(temp);\n                    if (list.contains(temp) && !visited.contains(temp)){\n                        bfs.add(temp);\n                        shortPath.put(temp,Integer.min(shortPath.get(temp),shortPath.get(cur)+1));\n                    }\n                }\n            }\n            // break;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n\n}","runtime":"1356 ms","title":"Word Ladder","url":"/submissions/detail/1072212427/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072212427,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696980956,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"54.8 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashSet<String> list = new HashSet<String>(wordList);\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        for (String s:list){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        bfs.add(beginWord);\n        shortPath.put(beginWord,1);\n\n        while(!bfs.isEmpty()){\n            String cur = bfs.poll();\n            if (cur.equals(endWord)){\n                break;\n            }\n            visited.add(cur);\n            int n = cur.length();\n            for (int i=0;i<n;i++){\n                char [] cList = cur.toCharArray();\n                for (char c = 'a';c<='z';c++){\n                    cList[i] = c;\n                    String temp = new String(cList);\n                    // System.out.println(temp);\n                    if (list.contains(temp) && !visited.contains(temp)){\n                        bfs.add(temp);\n                        shortPath.put(temp,Integer.min(shortPath.get(temp),shortPath.get(cur)+1));\n                    }\n                }\n            }\n            // break;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n\n}","runtime":"1378 ms","title":"Word Ladder","url":"/submissions/detail/1072211942/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072211942,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696980877,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"54.5 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashSet<String> list = new HashSet<String>();\n        for (String s:wordList){\n            list.add(s);\n        }\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        for (String s:list){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        bfs.add(beginWord);\n        shortPath.put(beginWord,1);\n\n        while(!bfs.isEmpty()){\n            String cur = bfs.poll();\n            if (cur.equals(endWord)){\n                break;\n            }\n            visited.add(cur);\n            int n = cur.length();\n            for (int i=0;i<n;i++){\n                char [] cList = cur.toCharArray();\n                for (char c = 'a';c<='z';c++){\n                    cList[i] = c;\n                    String temp = new String(cList);\n                    // System.out.println(temp);\n                    if (list.contains(temp) && !visited.contains(temp)){\n                        bfs.add(temp);\n                        shortPath.put(temp,Integer.min(shortPath.get(temp),shortPath.get(cur)+1));\n                    }\n                }\n            }\n            // break;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n\n}","runtime":"1434 ms","title":"Word Ladder","url":"/submissions/detail/1072211632/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072211632,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696980831,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Compile Error","memory":"N/A","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashSet<String> list = new HashSet<String>();\n        for (String s:wordList){\n            list.add(s);\n        }\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        for (String s:list){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        bfs.add(beginWord);\n        shortPath.put(beginWord,1);\n\n        while(!bfs.isEmpty()){\n            String cur = bfs.poll();\n            if (cur.equals(endWord)){\n                break;\n            }\n            visited.add(cur);\n            int n = cur.length();\n            for (int i=0;i<n;i++){\n                char [] cList = cur.toCharArray();\n                for (char c = 'a';c<='z';c++){\n                    cList[i] = c;\n                    // String temp = new String(cList);\n                    System.out.println(temp);\n                    if (list.contains(temp) && !visited.contains(temp)){\n                        bfs.add(temp);\n                        shortPath.put(temp,Integer.min(shortPath.get(temp),shortPath.get(cur)+1));\n                    }\n                }\n            }\n            // break;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n\n}","runtime":"N/A","title":"Word Ladder","url":"/submissions/detail/1072211551/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072211551,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696980817,"status":20,"is_pending":"Not Pending","compare_result":null},{"status_display":"Accepted","memory":"46.6 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        Set<String> set = new HashSet<>(wordList);\n        if(!set.contains(endWord)) return 0;\n        \n        Queue<String> queue = new LinkedList<>();\n        queue.add(beginWord);\n        \n        Set<String> visited = new HashSet<>();\n        queue.add(beginWord);\n        \n        int changes = 1;\n        \n        while(!queue.isEmpty()){\n            int size = queue.size();\n            for(int i = 0; i < size; i++){\n                String word = queue.poll();\n                if(word.equals(endWord)) return changes;\n                \n                for(int j = 0; j < word.length(); j++){\n                    for(int k = 'a'; k <= 'z'; k++){\n                        char arr[] = word.toCharArray();\n                        arr[j] = (char) k;\n                        \n                        String str = new String(arr);\n                        if(set.contains(str) && !visited.contains(str)){\n                            queue.add(str);\n                            visited.add(str);\n                        }\n                    }\n                }\n            }\n            ++changes;\n        }\n        return 0;\n    }\n\n\n}","runtime":"94 ms","title":"Word Ladder","url":"/submissions/detail/1072178071/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072178071,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696975815,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"49.5 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        // for (String s: map.keySet()){\n        //     if (s.equals(\"ito\")){\n        //         System.out.print(s + \": \");\n        //         for (String is:map.get(s)){\n        //             System.out.print(is+\", \");\n        //         }\n        //         System.out.println();\n        //     }\n        // }\n\n        HashSet<String> visited = new HashSet<String>();\n        Queue<String> bfs = new LinkedList<String>();\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        for (String s:map.keySet()){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        bfs.add(beginWord);\n        shortPath.put(beginWord,1);\n        String cur = \"\";\n        int count =0;\n        // boolean check = false;\n\n        while (!bfs.isEmpty())\n        {\n            cur = bfs.poll();\n            visited.add(cur);\n            if (cur.equals(endWord)){\n                break;\n            }\n            for (String s:map.get(cur)){\n                if (!visited.contains(s))\n                {\n                    bfs.add(s);\n                    shortPath.put(s,Integer.min(shortPath.get(s),shortPath.get(cur)+1));\n                    // if (s.equals(endWord)){\n                    //     check = true;\n                    //     break;\n                    // } ;\n                }\n            }\n            // if (check) break;\n        }\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n        // HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        // HashSet<String> visited = new HashSet<String>();\n        // // visisted.add(beginWord);\n        // String cur = beginWord;\n        // for (String s:map.keySet()){\n        //     shortPath.put(s,Integer.MAX_VALUE);\n        // }\n        // HashSet<String> tempSet = new HashSet<String>();\n        // shortPath.put(beginWord,1);\n        // while (!visited.contains(endWord)){\n        //     // System.out.println(\"dasdsa: \"+cur);\n        //     if (cur.equals(\"\")) break;\n        //     // System.out.println(shortPath.get(cur));\n        //     for (String s: map.get(cur)){\n        //         // System.out.println(s + \" \"+shortPath.get(s));\n\n        //         if (shortPath.get(s)>shortPath.get(cur)+1){\n        //             shortPath.put(s,shortPath.get(cur)+1);\n        //             // System.out.println(\"x\");\n        //             tempSet.add(s);\n\n        //         }\n        //     }\n        //     String temp = \"\";\n        //     int min = Integer.MAX_VALUE;\n        //     for (String s:tempSet){\n        //         if (!visited.contains(s)){\n        //             if (shortPath.get(s)<min){\n        //                 min = shortPath.get(s);\n        //                 temp = s;\n        //             }\n        //         }\n        //     }\n        //     tempSet.remove(temp);\n        //     visited.add(cur);\n        //     cur = temp;\n        // }\n\n        // return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n            if (count >1) return false;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}","runtime":"1074 ms","title":"Word Ladder","url":"/submissions/detail/1072149282/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072149282,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696972126,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"49.4 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        // for (String s: map.keySet()){\n        //     if (s.equals(\"ito\")){\n        //         System.out.print(s + \": \");\n        //         for (String is:map.get(s)){\n        //             System.out.print(is+\", \");\n        //         }\n        //         System.out.println();\n        //     }\n        // }\n\n        HashSet<String> visited = new HashSet<String>();\n        Queue<String> bfs = new LinkedList<String>();\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        for (String s:map.keySet()){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        bfs.add(beginWord);\n        shortPath.put(beginWord,1);\n        String cur = \"\";\n        int count =0;\n        // boolean check = false;\n\n        while (!bfs.isEmpty())\n        {\n            cur = bfs.poll();\n            visited.add(cur);\n            if (cur.equals(endWord)){\n                break;\n            }\n            for (String s:map.get(cur)){\n                if (!visited.contains(s))\n                {\n                    bfs.add(s);\n                    shortPath.put(s,Integer.min(shortPath.get(s),shortPath.get(cur)+1));\n                    // if (s.equals(endWord)){\n                    //     check = true;\n                    //     break;\n                    // } ;\n                }\n            }\n            // if (check) break;\n        }\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n        // HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        // HashSet<String> visited = new HashSet<String>();\n        // // visisted.add(beginWord);\n        // String cur = beginWord;\n        // for (String s:map.keySet()){\n        //     shortPath.put(s,Integer.MAX_VALUE);\n        // }\n        // HashSet<String> tempSet = new HashSet<String>();\n        // shortPath.put(beginWord,1);\n        // while (!visited.contains(endWord)){\n        //     // System.out.println(\"dasdsa: \"+cur);\n        //     if (cur.equals(\"\")) break;\n        //     // System.out.println(shortPath.get(cur));\n        //     for (String s: map.get(cur)){\n        //         // System.out.println(s + \" \"+shortPath.get(s));\n\n        //         if (shortPath.get(s)>shortPath.get(cur)+1){\n        //             shortPath.put(s,shortPath.get(cur)+1);\n        //             // System.out.println(\"x\");\n        //             tempSet.add(s);\n\n        //         }\n        //     }\n        //     String temp = \"\";\n        //     int min = Integer.MAX_VALUE;\n        //     for (String s:tempSet){\n        //         if (!visited.contains(s)){\n        //             if (shortPath.get(s)<min){\n        //                 min = shortPath.get(s);\n        //                 temp = s;\n        //             }\n        //         }\n        //     }\n        //     tempSet.remove(temp);\n        //     visited.add(cur);\n        //     cur = temp;\n        // }\n\n        // return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n            if (count >1) return false;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}","runtime":"1074 ms","title":"Word Ladder","url":"/submissions/detail/1072149191/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072149191,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696972115,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Time Limit Exceeded","memory":"N/A","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        // for (String s: map.keySet()){\n        //     if (s.equals(\"ito\")){\n        //         System.out.print(s + \": \");\n        //         for (String is:map.get(s)){\n        //             System.out.print(is+\", \");\n        //         }\n        //         System.out.println();\n        //     }\n        // }\n\n        HashSet<String> visited = new HashSet<String>();\n        Queue<String> bfs = new LinkedList<String>();\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        for (String s:map.keySet()){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        bfs.add(beginWord);\n        shortPath.put(beginWord,1);\n        String cur = \"\";\n        int count =0;\n        // boolean check = false;\n\n        while (!bfs.isEmpty())\n        {\n            cur = bfs.poll();\n            if (cur.equals(endWord)){\n                break;\n            }\n            for (String s:map.get(cur)){\n                if (!visited.contains(s))\n                {\n                    bfs.add(s);\n                    shortPath.put(s,Integer.min(shortPath.get(s),shortPath.get(cur)+1));\n                    // if (s.equals(endWord)){\n                    //     check = true;\n                    //     break;\n                    // } ;\n                }\n            }\n            // if (check) break;\n        }\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n        // HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        // HashSet<String> visited = new HashSet<String>();\n        // // visisted.add(beginWord);\n        // String cur = beginWord;\n        // for (String s:map.keySet()){\n        //     shortPath.put(s,Integer.MAX_VALUE);\n        // }\n        // HashSet<String> tempSet = new HashSet<String>();\n        // shortPath.put(beginWord,1);\n        // while (!visited.contains(endWord)){\n        //     // System.out.println(\"dasdsa: \"+cur);\n        //     if (cur.equals(\"\")) break;\n        //     // System.out.println(shortPath.get(cur));\n        //     for (String s: map.get(cur)){\n        //         // System.out.println(s + \" \"+shortPath.get(s));\n\n        //         if (shortPath.get(s)>shortPath.get(cur)+1){\n        //             shortPath.put(s,shortPath.get(cur)+1);\n        //             // System.out.println(\"x\");\n        //             tempSet.add(s);\n\n        //         }\n        //     }\n        //     String temp = \"\";\n        //     int min = Integer.MAX_VALUE;\n        //     for (String s:tempSet){\n        //         if (!visited.contains(s)){\n        //             if (shortPath.get(s)<min){\n        //                 min = shortPath.get(s);\n        //                 temp = s;\n        //             }\n        //         }\n        //     }\n        //     tempSet.remove(temp);\n        //     visited.add(cur);\n        //     cur = temp;\n        // }\n\n        // return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n            if (count >1) return false;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}","runtime":"N/A","title":"Word Ladder","url":"/submissions/detail/1072148772/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072148772,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696972067,"status":14,"is_pending":"Not Pending","compare_result":"111111111111111110000000000000000000000000000000000"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        // for (String s: map.keySet()){\n        //     if (s.equals(\"ito\")){\n        //         System.out.print(s + \": \");\n        //         for (String is:map.get(s)){\n        //             System.out.print(is+\", \");\n        //         }\n        //         System.out.println();\n        //     }\n        // }\n\n        HashSet<String> visited = new HashSet<String>();\n        Queue<String> bfs = new LinkedList<String>();\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        for (String s:map.keySet()){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        bfs.add(beginWord);\n        shortPath.put(beginWord,1);\n        String cur = \"\";\n        int count =0;\n        // boolean check = false;\n\n        while (!bfs.isEmpty())\n        {\n            cur = bfs.poll();\n            if (cur.equals(endWord)){\n                break;\n            }\n            for (String s:map.get(cur)){\n                if (!visited.contains(s))\n                {\n                    bfs.add(s);\n                    shortPath.put(s,Integer.min(shortPath.get(s),shortPath.get(cur)+1));\n                    // if (s.equals(endWord)){\n                    //     check = true;\n                    //     break;\n                    // } ;\n                }\n            }\n            // if (check) break;\n        }\n        return shortPath.get(endWord);\n        // HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        // HashSet<String> visited = new HashSet<String>();\n        // // visisted.add(beginWord);\n        // String cur = beginWord;\n        // for (String s:map.keySet()){\n        //     shortPath.put(s,Integer.MAX_VALUE);\n        // }\n        // HashSet<String> tempSet = new HashSet<String>();\n        // shortPath.put(beginWord,1);\n        // while (!visited.contains(endWord)){\n        //     // System.out.println(\"dasdsa: \"+cur);\n        //     if (cur.equals(\"\")) break;\n        //     // System.out.println(shortPath.get(cur));\n        //     for (String s: map.get(cur)){\n        //         // System.out.println(s + \" \"+shortPath.get(s));\n\n        //         if (shortPath.get(s)>shortPath.get(cur)+1){\n        //             shortPath.put(s,shortPath.get(cur)+1);\n        //             // System.out.println(\"x\");\n        //             tempSet.add(s);\n\n        //         }\n        //     }\n        //     String temp = \"\";\n        //     int min = Integer.MAX_VALUE;\n        //     for (String s:tempSet){\n        //         if (!visited.contains(s)){\n        //             if (shortPath.get(s)<min){\n        //                 min = shortPath.get(s);\n        //                 temp = s;\n        //             }\n        //         }\n        //     }\n        //     tempSet.remove(temp);\n        //     visited.add(cur);\n        //     cur = temp;\n        // }\n\n        // return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n            if (count >1) return false;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}","runtime":"N/A","title":"Word Ladder","url":"/submissions/detail/1072148434/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072148434,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696972031,"status":11,"is_pending":"Not Pending","compare_result":"111011111111111010000000000000000000000000000000000"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        // for (String s: map.keySet()){\n        //     if (s.equals(\"ito\")){\n        //         System.out.print(s + \": \");\n        //         for (String is:map.get(s)){\n        //             System.out.print(is+\", \");\n        //         }\n        //         System.out.println();\n        //     }\n        // }\n\n        HashSet<String> visited = new HashSet<String>();\n        Queue<String> bfs = new LinkedList<String>();\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        for (String s:map.keySet()){\n            shortPath.put(s,0);\n        }\n        bfs.add(beginWord);\n        shortPath.put(beginWord,1);\n        String cur = \"\";\n        int count =0;\n        boolean check = false;\n\n        while (!bfs.isEmpty())\n        {\n            cur = bfs.poll();\n            if (cur.equals(endWord)){\n                break;\n            }\n            for (String s:map.get(cur)){\n                if (!visited.contains(s))\n                {\n                    bfs.add(s);\n                    shortPath.put(s,shortPath.get(cur)+1);\n                    if (s.equals(endWord)){\n                        check = true;\n                        break;\n                    } ;\n                }\n            }\n            if (check) break;\n        }\n        return cur.equals(endWord)|check?shortPath.get(endWord):0;\n        // HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        // HashSet<String> visited = new HashSet<String>();\n        // // visisted.add(beginWord);\n        // String cur = beginWord;\n        // for (String s:map.keySet()){\n        //     shortPath.put(s,Integer.MAX_VALUE);\n        // }\n        // HashSet<String> tempSet = new HashSet<String>();\n        // shortPath.put(beginWord,1);\n        // while (!visited.contains(endWord)){\n        //     // System.out.println(\"dasdsa: \"+cur);\n        //     if (cur.equals(\"\")) break;\n        //     // System.out.println(shortPath.get(cur));\n        //     for (String s: map.get(cur)){\n        //         // System.out.println(s + \" \"+shortPath.get(s));\n\n        //         if (shortPath.get(s)>shortPath.get(cur)+1){\n        //             shortPath.put(s,shortPath.get(cur)+1);\n        //             // System.out.println(\"x\");\n        //             tempSet.add(s);\n\n        //         }\n        //     }\n        //     String temp = \"\";\n        //     int min = Integer.MAX_VALUE;\n        //     for (String s:tempSet){\n        //         if (!visited.contains(s)){\n        //             if (shortPath.get(s)<min){\n        //                 min = shortPath.get(s);\n        //                 temp = s;\n        //             }\n        //         }\n        //     }\n        //     tempSet.remove(temp);\n        //     visited.add(cur);\n        //     cur = temp;\n        // }\n\n        // return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n            if (count >1) return false;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}","runtime":"N/A","title":"Word Ladder","url":"/submissions/detail/1072146506/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072146506,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696971800,"status":11,"is_pending":"Not Pending","compare_result":"111111101111111110000000000000000000000000000000000"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        // for (String s: map.keySet()){\n        //     if (s.equals(\"ito\")){\n        //         System.out.print(s + \": \");\n        //         for (String is:map.get(s)){\n        //             System.out.print(is+\", \");\n        //         }\n        //         System.out.println();\n        //     }\n        // }\n\n        HashSet<String> visited = new HashSet<String>();\n        Queue<String> bfs = new LinkedList<String>();\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        for (String s:map.keySet()){\n            shortPath.put(s,0);\n        }\n        bfs.add(beginWord);\n        shortPath.put(beginWord,0);\n        String cur = \"\";\n        int count =0;\n        while (!bfs.isEmpty())\n        {\n            cur = bfs.poll();\n            if (cur.equals(endWord)){\n                break;\n            }\n            for (String s:map.get(cur)){\n                if (!visited.contains(s))\n                    bfs.add(s);\n                    shortPath.put(s,shortPath.get(cur)+1);\n            }\n        }\n        return cur.equals(endWord)?shortPath.get(endWord):0;\n        // HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        // HashSet<String> visited = new HashSet<String>();\n        // // visisted.add(beginWord);\n        // String cur = beginWord;\n        // for (String s:map.keySet()){\n        //     shortPath.put(s,Integer.MAX_VALUE);\n        // }\n        // HashSet<String> tempSet = new HashSet<String>();\n        // shortPath.put(beginWord,1);\n        // while (!visited.contains(endWord)){\n        //     // System.out.println(\"dasdsa: \"+cur);\n        //     if (cur.equals(\"\")) break;\n        //     // System.out.println(shortPath.get(cur));\n        //     for (String s: map.get(cur)){\n        //         // System.out.println(s + \" \"+shortPath.get(s));\n\n        //         if (shortPath.get(s)>shortPath.get(cur)+1){\n        //             shortPath.put(s,shortPath.get(cur)+1);\n        //             // System.out.println(\"x\");\n        //             tempSet.add(s);\n\n        //         }\n        //     }\n        //     String temp = \"\";\n        //     int min = Integer.MAX_VALUE;\n        //     for (String s:tempSet){\n        //         if (!visited.contains(s)){\n        //             if (shortPath.get(s)<min){\n        //                 min = shortPath.get(s);\n        //                 temp = s;\n        //             }\n        //         }\n        //     }\n        //     tempSet.remove(temp);\n        //     visited.add(cur);\n        //     cur = temp;\n        // }\n\n        // return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n            if (count >1) return false;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}","runtime":"N/A","title":"Word Ladder","url":"/submissions/detail/1072144424/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072144424,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696971558,"status":11,"is_pending":"Not Pending","compare_result":"111100111100100110000000000000000000000000000000000"},{"status_display":"Accepted","memory":"48.6 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        // for (String s: map.keySet()){\n        //     if (s.equals(\"ito\")){\n        //         System.out.print(s + \": \");\n        //         for (String is:map.get(s)){\n        //             System.out.print(is+\", \");\n        //         }\n        //         System.out.println();\n        //     }\n        // }\n\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        HashSet<String> visited = new HashSet<String>();\n        // visisted.add(beginWord);\n        String cur = beginWord;\n        for (String s:map.keySet()){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        HashSet<String> tempSet = new HashSet<String>();\n        shortPath.put(beginWord,1);\n        while (!visited.contains(endWord)){\n            // System.out.println(\"dasdsa: \"+cur);\n            if (cur.equals(\"\")) break;\n            // System.out.println(shortPath.get(cur));\n            for (String s: map.get(cur)){\n                // System.out.println(s + \" \"+shortPath.get(s));\n\n                if (shortPath.get(s)>shortPath.get(cur)+1){\n                    shortPath.put(s,shortPath.get(cur)+1);\n                    // System.out.println(\"x\");\n                    tempSet.add(s);\n\n                }\n            }\n            String temp = \"\";\n            int min = Integer.MAX_VALUE;\n            for (String s:tempSet){\n                if (!visited.contains(s)){\n                    if (shortPath.get(s)<min){\n                        min = shortPath.get(s);\n                        temp = s;\n                    }\n                }\n            }\n            tempSet.remove(temp);\n            visited.add(cur);\n            cur = temp;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n            if (count >1) return false;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}","runtime":"1164 ms","title":"Word Ladder","url":"/submissions/detail/1072131321/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072131321,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696970119,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"48.6 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        // for (String s: map.keySet()){\n        //     if (s.equals(\"ito\")){\n        //         System.out.print(s + \": \");\n        //         for (String is:map.get(s)){\n        //             System.out.print(is+\", \");\n        //         }\n        //         System.out.println();\n        //     }\n        // }\n\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        HashSet<String> visited = new HashSet<String>();\n        // visisted.add(beginWord);\n        String cur = beginWord;\n        for (String s:map.keySet()){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        HashSet<String> tempSet = new HashSet<String>();\n        shortPath.put(beginWord,1);\n        while (!visited.contains(endWord)){\n            // System.out.println(\"dasdsa: \"+cur);\n            if (cur.equals(\"\")) break;\n            // System.out.println(shortPath.get(cur));\n            for (String s: map.get(cur)){\n                // System.out.println(s + \" \"+shortPath.get(s));\n\n                if (shortPath.get(s)>shortPath.get(cur)+1){\n                    shortPath.put(s,shortPath.get(cur)+1);\n                    // System.out.println(\"x\");\n                    tempSet.add(s);\n\n                }\n            }\n            String temp = \"\";\n            int min = Integer.MAX_VALUE;\n            for (String s:tempSet){\n                if (!visited.contains(s)){\n                    if (shortPath.get(s)<min){\n                        min = shortPath.get(s);\n                        temp = s;\n                    }\n                }\n            }\n            tempSet.remove(temp);\n            visited.add(cur);\n            cur = temp;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n            if (count >1) return false;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}","runtime":"1164 ms","title":"Word Ladder","url":"/submissions/detail/1072131187/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072131187,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696970106,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"48 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        // for (String s: map.keySet()){\n        //     if (s.equals(\"ito\")){\n        //         System.out.print(s + \": \");\n        //         for (String is:map.get(s)){\n        //             System.out.print(is+\", \");\n        //         }\n        //         System.out.println();\n        //     }\n        // }\n\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        HashSet<String> visited = new HashSet<String>();\n        // visisted.add(beginWord);\n        String cur = beginWord;\n        for (String s:map.keySet()){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        HashSet<String> tempSet = new HashSet<String>();\n        shortPath.put(beginWord,1);\n        while (!visited.contains(endWord)){\n            // System.out.println(\"dasdsa: \"+cur);\n            if (cur.equals(\"\")) break;\n            // System.out.println(shortPath.get(cur));\n            for (String s: map.get(cur)){\n                // System.out.println(s + \" \"+shortPath.get(s));\n\n                if (shortPath.get(s)>shortPath.get(cur)+1){\n                    shortPath.put(s,shortPath.get(cur)+1);\n                    // System.out.println(\"x\");\n                    tempSet.add(s);\n\n                }\n            }\n            String temp = \"\";\n            int min = Integer.MAX_VALUE;\n            for (String s:tempSet){\n                if (!visited.contains(s)){\n                    if (shortPath.get(s)<min){\n                        min = shortPath.get(s);\n                        temp = s;\n                    }\n                }\n            }\n\n            visited.add(cur);\n            cur = temp;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n            if (count >1) return false;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}","runtime":"2159 ms","title":"Word Ladder","url":"/submissions/detail/1072130397/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072130397,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696970021,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"48.1 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        // for (String s: map.keySet()){\n        //     if (s.equals(\"ito\")){\n        //         System.out.print(s + \": \");\n        //         for (String is:map.get(s)){\n        //             System.out.print(is+\", \");\n        //         }\n        //         System.out.println();\n        //     }\n        // }\n\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        HashSet<String> visited = new HashSet<String>();\n        // visisted.add(beginWord);\n        String cur = beginWord;\n        for (String s:map.keySet()){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        HashSet<String> tempSet = new HashSet<String>();\n        shortPath.put(beginWord,1);\n        while (!visited.contains(endWord)){\n            // System.out.println(\"dasdsa: \"+cur);\n            if (cur.equals(\"\")) break;\n            // System.out.println(shortPath.get(cur));\n            for (String s: map.get(cur)){\n                // System.out.println(s + \" \"+shortPath.get(s));\n\n                if (shortPath.get(s)>shortPath.get(cur)+1){\n                    shortPath.put(s,shortPath.get(cur)+1);\n                    // System.out.println(\"x\");\n                    tempSet.add(s);\n\n                }\n            }\n            String temp = \"\";\n            int min = Integer.MAX_VALUE;\n            for (String s:tempSet){\n                if (!visited.contains(s)){\n                    if (shortPath.get(s)<min){\n                        min = shortPath.get(s);\n                        temp = s;\n                    }\n                }\n            }\n\n            visited.add(cur);\n            cur = temp;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n            if (count >1) return false;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}","runtime":"2154 ms","title":"Word Ladder","url":"/submissions/detail/1072130262/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072130262,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696970007,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Time Limit Exceeded","memory":"N/A","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        // for (String s: map.keySet()){\n        //     if (s.equals(\"ito\")){\n        //         System.out.print(s + \": \");\n        //         for (String is:map.get(s)){\n        //             System.out.print(is+\", \");\n        //         }\n        //         System.out.println();\n        //     }\n        // }\n\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        HashSet<String> visited = new HashSet<String>();\n        // visisted.add(beginWord);\n        String cur = beginWord;\n        for (String s:map.keySet()){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        shortPath.put(beginWord,1);\n        while (!visited.contains(endWord)){\n            // System.out.println(\"dasdsa: \"+cur);\n            if (cur.equals(\"\")) break;\n            // System.out.println(shortPath.get(cur));\n            for (String s: map.get(cur)){\n                // System.out.println(s + \" \"+shortPath.get(s));\n\n                if (shortPath.get(s)>shortPath.get(cur)+1){\n                    shortPath.put(s,shortPath.get(cur)+1);\n                    // System.out.println(\"x\");\n\n                }\n            }\n            String temp = \"\";\n            int min = Integer.MAX_VALUE;\n            for (String s:map.keySet()){\n                if (!visited.contains(s)){\n                    if (shortPath.get(s)<min){\n                        min = shortPath.get(s);\n                        temp = s;\n                    }\n                }\n            }\n\n            visited.add(cur);\n            cur = temp;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n            if (count >1) return false;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}","runtime":"N/A","title":"Word Ladder","url":"/submissions/detail/1072128339/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072128339,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696969809,"status":14,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Time Limit Exceeded","memory":"N/A","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        // for (String s: map.keySet()){\n        //     if (s.equals(\"ito\")){\n        //         System.out.print(s + \": \");\n        //         for (String is:map.get(s)){\n        //             System.out.print(is+\", \");\n        //         }\n        //         System.out.println();\n        //     }\n        // }\n\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        HashSet<String> visited = new HashSet<String>();\n        // visisted.add(beginWord);\n        String cur = beginWord;\n        for (String s:map.keySet()){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        shortPath.put(beginWord,1);\n        while (!visited.contains(endWord)){\n            // System.out.println(\"dasdsa: \"+cur);\n            if (cur.equals(\"\")) break;\n            // System.out.println(shortPath.get(cur));\n            for (String s: map.get(cur)){\n                // System.out.println(s + \" \"+shortPath.get(s));\n\n                if (shortPath.get(s)>shortPath.get(cur)+1){\n                    shortPath.put(s,shortPath.get(cur)+1);\n                    // System.out.println(\"x\");\n\n                }\n            }\n            String temp = \"\";\n            int min = Integer.MAX_VALUE;\n            for (String s:map.keySet()){\n                if (!visited.contains(s)){\n                    if (shortPath.get(s)<min){\n                        min = shortPath.get(s);\n                        temp = s;\n                    }\n                }\n            }\n\n            visited.add(cur);\n            cur = temp;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n            if (count >1) return false;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}","runtime":"N/A","title":"Word Ladder","url":"/submissions/detail/1072116951/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072116951,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696968659,"status":14,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Time Limit Exceeded","memory":"N/A","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        for (String s: map.keySet()){\n            if (s.equals(\"ito\")){\n                System.out.print(s + \": \");\n                for (String is:map.get(s)){\n                    System.out.print(is+\", \");\n                }\n                System.out.println();\n            }\n        }\n\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        HashSet<String> visited = new HashSet<String>();\n        // visisted.add(beginWord);\n        String cur = beginWord;\n        for (String s:map.keySet()){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        shortPath.put(beginWord,1);\n        while (!visited.contains(endWord)){\n            // System.out.println(\"dasdsa: \"+cur);\n            if (cur.equals(\"\")) break;\n            // System.out.println(shortPath.get(cur));\n            for (String s: map.get(cur)){\n                // System.out.println(s + \" \"+shortPath.get(s));\n\n                if (shortPath.get(s)>shortPath.get(cur)+1){\n                    shortPath.put(s,shortPath.get(cur)+1);\n                    // System.out.println(\"x\");\n\n                }\n            }\n            String temp = \"\";\n            int min = Integer.MAX_VALUE;\n            for (String s:map.keySet()){\n                if (!visited.contains(s)){\n                    if (shortPath.get(s)<min){\n                        min = shortPath.get(s);\n                        temp = s;\n                    }\n                }\n            }\n\n            visited.add(cur);\n            cur = temp;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n            if (count >1) return false;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}","runtime":"N/A","title":"Word Ladder","url":"/submissions/detail/1072116570/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072116570,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696968622,"status":14,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"}],"has_next":true,"last_key":"%7B%22pk%22%3A%20%7B%22N%22%3A%20%221072116570%22%7D%2C%20%22dt%22%3A%20%7B%22S%22%3A%20%222023-10-10T20%3A10%3A22.777289%2B0000%22%7D%2C%20%22sid%22%3A%20%7B%22N%22%3A%20%227573785%22%7D%7D"}
2024-01-26 23:03:59.591 [main] DEBUG submission_dump - {"submissions_dump":[{"status_display":"Time Limit Exceeded","memory":"N/A","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        for (String s: map.keySet()){\n            if (s.equals(\"ito\")){\n                System.out.print(s + \": \");\n                for (String is:map.get(s)){\n                    System.out.print(is+\", \");\n                }\n                System.out.println();\n            }\n        }\n\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        HashSet<String> visited = new HashSet<String>();\n        // visisted.add(beginWord);\n        String cur = beginWord;\n        for (String s:map.keySet()){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        shortPath.put(beginWord,1);\n        while (!visited.contains(endWord)){\n            // System.out.println(\"dasdsa: \"+cur);\n            if (cur.equals(\"\")) break;\n            // System.out.println(shortPath.get(cur));\n            for (String s: map.get(cur)){\n                // System.out.println(s + \" \"+shortPath.get(s));\n\n                if (shortPath.get(s)>shortPath.get(cur)+1){\n                    shortPath.put(s,shortPath.get(cur)+1);\n                    // System.out.println(\"x\");\n\n                }\n            }\n            String temp = \"\";\n            int min = Integer.MAX_VALUE;\n            for (String s:map.keySet()){\n                if (!visited.contains(s)){\n                    if (shortPath.get(s)<min){\n                        min = shortPath.get(s);\n                        temp = s;\n                    }\n                }\n            }\n\n            visited.add(cur);\n            cur = temp;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n            if (count >1) return false;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}","runtime":"N/A","title":"Word Ladder","url":"/submissions/detail/1072116432/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072116432,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696968607,"status":14,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Time Limit Exceeded","memory":"N/A","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        for (String s: map.keySet()){\n            if (s.equals(\"ito\")){\n                System.out.print(s + \": \");\n                for (String is:map.get(s)){\n                    System.out.print(is+\", \");\n                }\n                System.out.println();\n            }\n        }\n\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        HashSet<String> visited = new HashSet<String>();\n        // visisted.add(beginWord);\n        String cur = beginWord;\n        for (String s:map.keySet()){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        shortPath.put(beginWord,1);\n        while (!visited.contains(endWord)){\n            // System.out.println(\"dasdsa: \"+cur);\n            if (cur.equals(\"\")) break;\n            // System.out.println(shortPath.get(cur));\n            for (String s: map.get(cur)){\n                // System.out.println(s + \" \"+shortPath.get(s));\n\n                if (shortPath.get(s)>shortPath.get(cur)+1){\n                    shortPath.put(s,shortPath.get(cur)+1);\n                    // System.out.println(\"x\");\n\n                }\n            }\n            String temp = \"\";\n            int min = Integer.MAX_VALUE;\n            for (String s:map.keySet()){\n                if (!visited.contains(s)){\n                    if (shortPath.get(s)<min){\n                        min = shortPath.get(s);\n                        temp = s;\n                    }\n                }\n            }\n\n            visited.add(cur);\n            cur = temp;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n            if (count >1) return false;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}","runtime":"N/A","title":"Word Ladder","url":"/submissions/detail/1072116340/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072116340,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696968597,"status":14,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Time Limit Exceeded","memory":"N/A","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        for (String s: map.keySet()){\n            if (s.equals(\"ito\")){\n                System.out.print(s + \": \");\n                for (String is:map.get(s)){\n                    System.out.print(is+\", \");\n                }\n                System.out.println();\n            }\n        }\n\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        HashSet<String> visited = new HashSet<String>();\n        // visisted.add(beginWord);\n        String cur = beginWord;\n        for (String s:map.keySet()){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        shortPath.put(beginWord,1);\n        while (!visited.contains(endWord)){\n            // System.out.println(\"dasdsa: \"+cur);\n            if (cur.equals(\"\")) break;\n            // System.out.println(shortPath.get(cur));\n            for (String s: map.get(cur)){\n                // System.out.println(s + \" \"+shortPath.get(s));\n\n                if (shortPath.get(s)>shortPath.get(cur)+1){\n                    shortPath.put(s,shortPath.get(cur)+1);\n                    // System.out.println(\"x\");\n\n                }\n            }\n            String temp = \"\";\n            int min = Integer.MAX_VALUE;\n            for (String s:map.keySet()){\n                if (!visited.contains(s)){\n                    if (shortPath.get(s)<min){\n                        min = shortPath.get(s);\n                        temp = s;\n                    }\n                }\n            }\n\n            visited.add(cur);\n            cur = temp;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}","runtime":"N/A","title":"Word Ladder","url":"/submissions/detail/1072115903/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072115903,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696968555,"status":14,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111000000"},{"status_display":"Time Limit Exceeded","memory":"N/A","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        for (String s: map.keySet()){\n            if (s.equals(\"ito\")){\n                System.out.print(s + \": \");\n                for (String is:map.get(s)){\n                    System.out.print(is+\", \");\n                }\n                System.out.println();\n            }\n        }\n\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        HashSet<String> visited = new HashSet<String>();\n        // visisted.add(beginWord);\n        String cur = beginWord;\n        for (String s:map.keySet()){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        shortPath.put(beginWord,1);\n        while (!visited.contains(endWord)){\n            // System.out.println(\"dasdsa: \"+cur);\n            if (cur.equals(\"\")) break;\n            // System.out.println(shortPath.get(cur));\n            for (String s: map.get(cur)){\n                // System.out.println(s + \" \"+shortPath.get(s));\n\n                if (shortPath.get(s)>shortPath.get(cur)+1){\n                    shortPath.put(s,shortPath.get(cur)+1);\n                    // System.out.println(\"x\");\n\n                }\n            }\n            String temp = \"\";\n            int min = Integer.MAX_VALUE;\n            for (String s:map.keySet()){\n                if (!visited.contains(s)){\n                    if (shortPath.get(s)<min){\n                        min = shortPath.get(s);\n                        temp = s;\n                    }\n                }\n            }\n\n            visited.add(cur);\n            cur = temp;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}","runtime":"N/A","title":"Word Ladder","url":"/submissions/detail/1072114917/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072114917,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696968466,"status":14,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111000000000000"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        // for (String s: map.keySet()){\n        //     System.out.print(s + \": \");\n        //     for (String is:map.get(s)){\n        //         System.out.print(is+\", \");\n        //     }\n        //     System.out.println();\n        // }\n\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        HashSet<String> visited = new HashSet<String>();\n        // visisted.add(beginWord);\n        String cur = beginWord;\n        for (String s:map.keySet()){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        shortPath.put(beginWord,1);\n        while (!visited.contains(endWord)){\n            // System.out.println(\"dasdsa: \"+cur);\n            if (cur.equals(\"\")) break;\n            // System.out.println(shortPath.get(cur));\n            for (String s: map.get(cur)){\n                // System.out.println(s + \" \"+shortPath.get(s));\n\n                if (shortPath.get(s)>shortPath.get(cur)+1){\n                    shortPath.put(s,shortPath.get(cur)+1);\n                    // System.out.println(\"x\");\n\n                }\n            }\n            String temp = \"\";\n            int min = Integer.MAX_VALUE;\n            for (String s:map.get(cur)){\n                if (!visited.contains(s)){\n                    if (shortPath.get(s)<min){\n                        min = shortPath.get(s);\n                        temp = s;\n                    }\n                }\n            }\n\n            visited.add(cur);\n            cur = temp;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}","runtime":"N/A","title":"Word Ladder","url":"/submissions/detail/1072110963/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072110963,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696968077,"status":11,"is_pending":"Not Pending","compare_result":"111111111111111111111111101010111000001011011001001"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        for (String s: map.keySet()){\n            System.out.print(s + \": \");\n            for (String is:map.get(s)){\n                System.out.print(is+\", \");\n            }\n            System.out.println();\n        }\n\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        HashSet<String> visited = new HashSet<String>();\n        // visisted.add(beginWord);\n        String cur = beginWord;\n        for (String s:map.keySet()){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        shortPath.put(beginWord,1);\n        while (!visited.contains(endWord)){\n            System.out.println(\"dasdsa: \"+cur);\n            if (cur.equals(\"\")) break;\n            // System.out.println(shortPath.get(cur));\n            for (String s: map.get(cur)){\n                // System.out.println(s + \" \"+shortPath.get(s));\n\n                if (shortPath.get(s)>shortPath.get(cur)+1){\n                    shortPath.put(s,shortPath.get(cur)+1);\n                    // System.out.println(\"x\");\n\n                }\n            }\n            String temp = \"\";\n            int min = Integer.MAX_VALUE;\n            for (String s:map.get(cur)){\n                if (!visited.contains(s)){\n                    if (shortPath.get(s)<min){\n                        min = shortPath.get(s);\n                        temp = s;\n                    }\n                }\n            }\n\n            visited.add(cur);\n            cur = temp;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}","runtime":"N/A","title":"Word Ladder","url":"/submissions/detail/1071353091/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1071353091,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696893014,"status":11,"is_pending":"Not Pending","compare_result":"111111111111111111111111101010111000001011011001001"},{"status_display":"Runtime Error","memory":"N/A","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        for (String s: map.keySet()){\n            System.out.print(s + \": \");\n            for (String is:map.get(s)){\n                System.out.print(is+\", \");\n            }\n            System.out.println();\n        }\n\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        HashSet<String> visited = new HashSet<String>();\n        // visisted.add(beginWord);\n        String cur = beginWord;\n        for (String s:map.keySet()){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        shortPath.put(beginWord,1);\n        while (!visited.contains(endWord)){\n            System.out.println(\"dasdsa: \"+cur);\n            // if (cur.equals(\"\")) break;\n            // System.out.println(shortPath.get(cur));\n            for (String s: map.get(cur)){\n                // System.out.println(s + \" \"+shortPath.get(s));\n\n                if (shortPath.get(s)>shortPath.get(cur)+1){\n                    shortPath.put(s,shortPath.get(cur)+1);\n                    // System.out.println(\"x\");\n\n                }\n            }\n            String temp = \"\";\n            int min = Integer.MAX_VALUE;\n            for (String s:map.get(cur)){\n                if (!visited.contains(s)){\n                    if (shortPath.get(s)<min){\n                        min = shortPath.get(s);\n                        temp = s;\n                    }\n                }\n            }\n\n            visited.add(cur);\n            cur = temp;\n        }\n\n        return shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}","runtime":"N/A","title":"Word Ladder","url":"/submissions/detail/1071352515/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1071352515,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696892927,"status":15,"is_pending":"Not Pending","compare_result":"111000000000000000000000000000000000000000000000000"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        for (String s: map.keySet()){\n            System.out.print(s + \": \");\n            for (String is:map.get(s)){\n                System.out.print(is+\", \");\n            }\n            System.out.println();\n        }\n\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        HashSet<String> visited = new HashSet<String>();\n        // visisted.add(beginWord);\n        String cur = beginWord;\n        for (String s:map.keySet()){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        shortPath.put(beginWord,1);\n        while (!visited.contains(endWord)){\n            System.out.println(\"dasdsa: \"+cur);\n            if (cur.equals(\"\")) break;\n            // System.out.println(shortPath.get(cur));\n            for (String s: map.get(cur)){\n                // System.out.println(s + \" \"+shortPath.get(s));\n\n                if (shortPath.get(s)>shortPath.get(cur)+1){\n                    shortPath.put(s,shortPath.get(cur)+1);\n                    // System.out.println(\"x\");\n\n                }\n            }\n            String temp = \"\";\n            int min = Integer.MAX_VALUE;\n            for (String s:map.get(cur)){\n                if (!visited.contains(s)){\n                    if (shortPath.get(s)<min){\n                        min = shortPath.get(s);\n                        temp = s;\n                    }\n                }\n            }\n\n            visited.add(cur);\n            cur = temp;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}","runtime":"N/A","title":"Word Ladder","url":"/submissions/detail/1071352179/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1071352179,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696892874,"status":11,"is_pending":"Not Pending","compare_result":"111111111111111111111111101010111000001011011001001"},{"status_display":"Accepted","memory":"43.6 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Codec {\n\n    // Encodes a tree to a single string.\n    static TreeNode cheat;\n    public String serialize(TreeNode root) {\n        cheat = root;\n        return \"\";\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        \n        return cheat;\n    }\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec ser = new Codec();\n// Codec deser = new Codec();\n// TreeNode ans = deser.deserialize(ser.serialize(root));","runtime":"0 ms","title":"Serialize and Deserialize Binary Tree","url":"/submissions/detail/1071296347/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1071296347,"time":"3 months, 2 weeks","lang":"java","title_slug":"serialize-and-deserialize-binary-tree","timestamp":1696886111,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"46.5 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Codec {\n\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        Queue<TreeNode> a = new LinkedList<TreeNode>();\n        a.add(root);\n        String se = \"\";\n        while (!a.isEmpty()){\n            TreeNode cur = a.poll();\n            if (cur == null){\n                se = se + \"NA!\";\n            } else{\n                se = se+cur.val+\"!\";\n                a.add(cur.left);\n                a.add(cur.right);  \n            }\n                      \n        }\n        System.out.println(se);\n        return se;\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        String [] st = data.split(\"!\");\n        Queue<TreeNode> a = new LinkedList<TreeNode>();\n        if (st[0].equals(\"NA\")) return null;\n        TreeNode root = new TreeNode(Integer.parseInt(st[0]));\n        a.add(root);\n        int counter = 1;\n        while (counter<st.length){\n            TreeNode cur = a.poll();\n            if (!st[counter].equals(\"NA\")){\n                TreeNode left = new TreeNode(Integer.parseInt(st[counter]));\n                cur.left = left;\n                a.add(left);\n            }\n            counter++;\n            if (!st[counter].equals(\"NA\")){\n                TreeNode right = new TreeNode(Integer.parseInt(st[counter]));\n                cur.right = right;\n                a.add(right);\n            }\n            counter++;\n        }\n        return root;\n    }\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec ser = new Codec();\n// Codec deser = new Codec();\n// TreeNode ans = deser.deserialize(ser.serialize(root));","runtime":"62 ms","title":"Serialize and Deserialize Binary Tree","url":"/submissions/detail/1071293082/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1071293082,"time":"3 months, 2 weeks","lang":"java","title_slug":"serialize-and-deserialize-binary-tree","timestamp":1696885761,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"45.1 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Codec {\n\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        Queue<TreeNode> a = new LinkedList<TreeNode>();\n        a.add(root);\n        String se = \"\";\n        while (!a.isEmpty()){\n            TreeNode cur = a.poll();\n            if (cur == null){\n                se = se + \"NA!\";\n            } else{\n                se = se+cur.val+\"!\";\n                a.add(cur.left);\n                a.add(cur.right);  \n            }\n                      \n        }\n        System.out.println(se);\n        return se;\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        String [] st = data.split(\"!\");\n        Queue<TreeNode> a = new LinkedList<TreeNode>();\n        if (st[0].equals(\"NA\")) return null;\n        TreeNode root = new TreeNode(Integer.parseInt(st[0]));\n        a.add(root);\n        int counter = 1;\n        while (counter<st.length){\n            TreeNode cur = a.poll();\n            if (!st[counter].equals(\"NA\")){\n                TreeNode left = new TreeNode(Integer.parseInt(st[counter]));\n                cur.left = left;\n                a.add(left);\n            }\n            counter++;\n            if (!st[counter].equals(\"NA\")){\n                TreeNode right = new TreeNode(Integer.parseInt(st[counter]));\n                cur.right = right;\n                a.add(right);\n            }\n            counter++;\n        }\n        return root;\n    }\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec ser = new Codec();\n// Codec deser = new Codec();\n// TreeNode ans = deser.deserialize(ser.serialize(root));","runtime":"63 ms","title":"Serialize and Deserialize Binary Tree","url":"/submissions/detail/1071293003/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1071293003,"time":"3 months, 2 weeks","lang":"java","title_slug":"serialize-and-deserialize-binary-tree","timestamp":1696885752,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"44.2 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int max  = Integer.MIN_VALUE;\n    public int maxPathSum(TreeNode root) {\n        pathSum(root);\n        return max;\n    }\n    public int pathSum (TreeNode root) {\n        if (root == null) return 0;\n        int left = pathSum(root.left);\n        int right = pathSum(root.right);\n        if (root.val > max) max = root.val;\n        if (root.val + left  > max) max = root.val + left ;\n        if (root.val + right > max) max = root.val + right;\n        if (root.val + left + right > max) max = root.val + left + right;\n        return Integer.max(root.val + Integer.max(left,right),root.val);\n        \n    }\n}","runtime":"1 ms","title":"Binary Tree Maximum Path Sum","url":"/submissions/detail/1071280592/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1071280592,"time":"3 months, 2 weeks","lang":"java","title_slug":"binary-tree-maximum-path-sum","timestamp":1696884486,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"44.3 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int max  = Integer.MIN_VALUE;\n    public int maxPathSum(TreeNode root) {\n        pathSum(root);\n        return max;\n    }\n    public int pathSum (TreeNode root) {\n        if (root == null) return 0;\n        int left = pathSum(root.left);\n        int right = pathSum(root.right);\n        if (root.val > max) max = root.val;\n        if (root.val + left  > max) max = root.val + left ;\n        if (root.val + right > max) max = root.val + right;\n        if (root.val + left + right > max) max = root.val + left + right;\n        return Integer.max(root.val + Integer.max(left,right),root.val);\n        \n    }\n}","runtime":"0 ms","title":"Binary Tree Maximum Path Sum","url":"/submissions/detail/1071280423/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1071280423,"time":"3 months, 2 weeks","lang":"java","title_slug":"binary-tree-maximum-path-sum","timestamp":1696884467,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"44.7 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int max  = Integer.MIN_VALUE;\n    public int maxPathSum(TreeNode root) {\n        pathSum(root);\n        return max;\n    }\n    public int pathSum (TreeNode root) {\n        if (root == null) return 0;\n        int left = pathSum(root.left);\n        int right = pathSum(root.right);\n        if (root.val > max) max = root.val;\n        if (root.val + left  > max) max = root.val + left ;\n        if (root.val + right > max) max = root.val + right;\n        if (root.val + left + right > max) max = root.val + left + right;\n        return Integer.max(root.val + Integer.max(left,right),root.val);\n        \n    }\n}","runtime":"0 ms","title":"Binary Tree Maximum Path Sum","url":"/submissions/detail/1071234905/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1071234905,"time":"3 months, 2 weeks","lang":"java","title_slug":"binary-tree-maximum-path-sum","timestamp":1696880191,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"44.9 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int max  = Integer.MIN_VALUE;\n    public int maxPathSum(TreeNode root) {\n        pathSum(root);\n        return max;\n    }\n    public int pathSum (TreeNode root) {\n        if (root == null) return 0;\n        int left = pathSum(root.left);\n        int right = pathSum(root.right);\n        if (root.val > max) max = root.val;\n        if (root.val + left  > max) max = root.val + left ;\n        if (root.val + right > max) max = root.val + right;\n        if (root.val + left + right > max) max = root.val + left + right;\n        return Integer.max(root.val + Integer.max(left,right),root.val);\n        \n    }\n}","runtime":"1 ms","title":"Binary Tree Maximum Path Sum","url":"/submissions/detail/1071234809/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1071234809,"time":"3 months, 2 weeks","lang":"java","title_slug":"binary-tree-maximum-path-sum","timestamp":1696880183,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"43.9 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int max  = Integer.MIN_VALUE;\n    public int maxPathSum(TreeNode root) {\n        pathSum(root);\n        return max;\n    }\n    public int pathSum (TreeNode root) {\n        if (root == null) return 0;\n        int left = pathSum(root.left);\n        int right = pathSum(root.right);\n        if (root.val > max) max = root.val;\n        if (root.val + left  > max) max = root.val + left ;\n        if (root.val + right > max) max = root.val + right;\n        if (root.val + left + right > max) max = root.val + left + right;\n        return Integer.max(root.val + Integer.max(left,right),root.val);\n        \n    }\n}","runtime":"1 ms","title":"Binary Tree Maximum Path Sum","url":"/submissions/detail/1071234710/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1071234710,"time":"3 months, 2 weeks","lang":"java","title_slug":"binary-tree-maximum-path-sum","timestamp":1696880175,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"43.5 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int max  = Integer.MIN_VALUE;\n    public int maxPathSum(TreeNode root) {\n        pathSum(root);\n        return max;\n    }\n    public int pathSum (TreeNode root) {\n        if (root == null) return 0;\n        int left = pathSum(root.left);\n        int right = pathSum(root.right);\n        if (root.val > max) max = root.val;\n        if (root.val + left  > max) max = root.val + left ;\n        if (root.val + right > max) max = root.val + right;\n        if (root.val + left + right > max) max = root.val + left + right;\n        return Integer.max(root.val + Integer.max(left,right),root.val);\n        \n    }\n}","runtime":"0 ms","title":"Binary Tree Maximum Path Sum","url":"/submissions/detail/1071234464/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1071234464,"time":"3 months, 2 weeks","lang":"java","title_slug":"binary-tree-maximum-path-sum","timestamp":1696880156,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"44.4 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int max  = Integer.MIN_VALUE;\n    public int maxPathSum(TreeNode root) {\n        pathSum(root);\n        return max;\n    }\n    public int pathSum (TreeNode root) {\n        if (root == null) return 0;\n        int left = pathSum(root.left);\n        int right = pathSum(root.right);\n        if (root.val > max) max = root.val;\n        if (root.val + left  > max) max = root.val + left ;\n        if (root.val + right > max) max = root.val + right;\n        if (root.val + left + right > max) max = root.val + left + right;\n        // if (left > max) max = left;\n        // if (right > max) max = right;\n        return Integer.max(root.val + Integer.max(left,right),root.val);\n        \n    }\n}","runtime":"0 ms","title":"Binary Tree Maximum Path Sum","url":"/submissions/detail/1071234067/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1071234067,"time":"3 months, 2 weeks","lang":"java","title_slug":"binary-tree-maximum-path-sum","timestamp":1696880124,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int max  = Integer.MIN_VALUE;\n    public int maxPathSum(TreeNode root) {\n        pathSum(root);\n        return max;\n    }\n    public int pathSum (TreeNode root) {\n        if (root == null) return 0;\n        int left = pathSum(root.left);\n        int right = pathSum(root.right);\n        if (root.val > max) max = root.val;\n        if (root.val + left  > max) max = root.val + left ;\n        if (root.val + right > max) max = root.val + right;\n        if (root.val + left + right > max) max = root.val + left + right;\n        // if (left > max) max = left;\n        // if (right > max) max = right;\n        return root.val + Integer.max(left,right);\n        \n    }\n}","runtime":"N/A","title":"Binary Tree Maximum Path Sum","url":"/submissions/detail/1071232301/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1071232301,"time":"3 months, 2 weeks","lang":"java","title_slug":"binary-tree-maximum-path-sum","timestamp":1696879970,"status":11,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111101111111111111111111111111111111011111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int max  = Integer.MIN_VALUE;\n    public int maxPathSum(TreeNode root) {\n        pathSum(root);\n        return max;\n    }\n    public int pathSum (TreeNode root) {\n        if (root == null) return 0;\n        int left = pathSum(root.left);\n        int right = pathSum(root.right);\n        if (root.val > max) max = root.val;\n        if (root.val + left  > max) max = root.val + left ;\n        if (root.val + right > max) max = root.val + right;\n        if (root.val + left + right > max) max = root.val + left + right;\n        if (left > max) max = left;\n        if (right > max) max = right;\n        return root.val + Integer.max(left,right);\n        \n    }\n}","runtime":"N/A","title":"Binary Tree Maximum Path Sum","url":"/submissions/detail/1071231798/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1071231798,"time":"3 months, 2 weeks","lang":"java","title_slug":"binary-tree-maximum-path-sum","timestamp":1696879924,"status":11,"is_pending":"Not Pending","compare_result":"11110111001111011111111111111111111111111111111111111101111111111111111011111111011111011111111"}],"has_next":true,"last_key":"%7B%22pk%22%3A%20%7B%22N%22%3A%20%221071231798%22%7D%2C%20%22dt%22%3A%20%7B%22S%22%3A%20%222023-10-09T19%3A32%3A04.573480%2B0000%22%7D%2C%20%22sid%22%3A%20%7B%22N%22%3A%20%227573785%22%7D%7D"}
2024-01-26 23:04:09.916 [main] DEBUG submission_dump - {"submissions_dump":[{"status_display":"Wrong Answer","memory":"N/A","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int max  = Integer.MIN_VALUE;\n    public int maxPathSum(TreeNode root) {\n        pathSum(root);\n        return max;\n    }\n    public int pathSum (TreeNode root) {\n        if (root == null) return -2000;\n        int left = pathSum(root.left);\n        int right = pathSum(root.right);\n        if (root.val > max) max = root.val;\n        if (root.val + left  > max) max = root.val + left ;\n        if (root.val + right > max) max = root.val + right;\n        if (root.val + left + right > max) max = root.val + left + right;\n        if (left > max) max = left;\n        if (right > max) max = right;\n        return root.val + Integer.max(left,right);\n        \n    }\n}","runtime":"N/A","title":"Binary Tree Maximum Path Sum","url":"/submissions/detail/1071230638/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1071230638,"time":"3 months, 2 weeks","lang":"java","title_slug":"binary-tree-maximum-path-sum","timestamp":1696879825,"status":11,"is_pending":"Not Pending","compare_result":"00111011110011101010001001001001001101000001101000101001000100001010000110100110100000000000001"},{"status_display":"Wrong Answer","memory":"N/A","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int max  = Integer.MIN_VALUE;\n    public int maxPathSum(TreeNode root) {\n        pathSum(root);\n        return max;\n    }\n    public int pathSum (TreeNode root) {\n        if (root == null) return Integer.MIN_VALUE;\n        int left = pathSum(root.left);\n        int right = pathSum(root.right);\n        if (root.val > max) max = root.val;\n        if (root.val + left  > max) max = root.val + left ;\n        if (root.val + right > max) max = root.val + right;\n        if (root.val + left + right > max) max = root.val + left + right;\n        if (left > max) max = left;\n        if (right > max) max = right;\n        return root.val + Integer.max(left,right);\n        \n    }\n}","runtime":"N/A","title":"Binary Tree Maximum Path Sum","url":"/submissions/detail/1071229917/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1071229917,"time":"3 months, 2 weeks","lang":"java","title_slug":"binary-tree-maximum-path-sum","timestamp":1696879761,"status":11,"is_pending":"Not Pending","compare_result":"10110100000100010101100100010000000000000000000000000000000000000000000000000000000000000000000"},{"status_display":"Wrong Answer","memory":"N/A","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int max  = Integer.MIN_VALUE;\n    public int maxPathSum(TreeNode root) {\n        pathSum(root);\n        return max;\n    }\n    public int pathSum (TreeNode root) {\n        if (root == null) return 0;\n        int left = pathSum(root.left);\n        int right = pathSum(root.right);\n        if (root.val > max) max = root.val;\n        if (root.val + left  > max) max = root.val + left ;\n        if (root.val + right > max) max = root.val + right;\n        if (root.val + left + right > max) max = root.val + left + right;\n        if (left > max) max = left;\n        if (right > max) max = right;\n        return root.val + Integer.max(left,right);\n        \n    }\n}","runtime":"N/A","title":"Binary Tree Maximum Path Sum","url":"/submissions/detail/1071229231/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1071229231,"time":"3 months, 2 weeks","lang":"java","title_slug":"binary-tree-maximum-path-sum","timestamp":1696879699,"status":11,"is_pending":"Not Pending","compare_result":"11110111001111011111111111111111111111111111111111111101111111111111111011111111011111011111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int max  = Integer.MIN_VALUE;\n    public int maxPathSum(TreeNode root) {\n        pathSum(root);\n        return max;\n    }\n    public int pathSum (TreeNode root) {\n        if (root == null) return 0;\n        int left = pathSum(root.left);\n        int right = pathSum(root.right);\n        if (root.val > max) max = root.val;\n        if (root.val + left  > max) max = root.val + left ;\n        if (root.val + right > max) max = root.val + right;\n        if (root.val + left + right > max) max = root.val + left + right;\n        return root.val + Integer.max(left,right);\n        \n    }\n}","runtime":"N/A","title":"Binary Tree Maximum Path Sum","url":"/submissions/detail/1071228544/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1071228544,"time":"3 months, 2 weeks","lang":"java","title_slug":"binary-tree-maximum-path-sum","timestamp":1696879638,"status":11,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111101111111111111111111111111111111011111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int max  = Integer.MIN_VALUE;\n    public int maxPathSum(TreeNode root) {\n        max = root.val;\n        pathSum(root);\n        return max;\n    }\n    public int pathSum (TreeNode root) {\n        if (root == null) return 0;\n        int left = pathSum(root.left);\n        int right = pathSum(root.right);\n        if (root.val + left + right > max) max = root.val + left + right;\n        return root.val + Integer.max(left,right);\n        \n    }\n}","runtime":"N/A","title":"Binary Tree Maximum Path Sum","url":"/submissions/detail/1071227515/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1071227515,"time":"3 months, 2 weeks","lang":"java","title_slug":"binary-tree-maximum-path-sum","timestamp":1696879556,"status":11,"is_pending":"Not Pending","compare_result":"11111111110111110111110111111101110111000011001111010101001111111111011100111111111111011111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int max  = Integer.MIN_VALUE;\n    public int maxPathSum(TreeNode root) {\n        pathSum(root);\n        return max;\n    }\n    public int pathSum (TreeNode root) {\n        if (root == null) return 0;\n        int left = pathSum(root.left);\n        int right = pathSum(root.right);\n        if (root.val + left +right > max) max = root.val + left + right;\n        return root.val + left+right;\n        \n    }\n}","runtime":"N/A","title":"Binary Tree Maximum Path Sum","url":"/submissions/detail/1071157032/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1071157032,"time":"3 months, 2 weeks","lang":"java","title_slug":"binary-tree-maximum-path-sum","timestamp":1696874367,"status":11,"is_pending":"Not Pending","compare_result":"11111101100110110110010100111000110001000000001010000001000100101011000000100101100000000000001"},{"status_display":"Accepted","memory":"43.3 MB","code":"class Solution {\n    public int lengthOfLIS(int[] nums) {\n        ArrayList<Integer> re = new ArrayList<Integer>();\n        for (int i = 0;i<nums.length;i++){\n            boolean check = false;\n            for (int j = 0;j<re.size();j++){\n                // System.out.println(i+\", \"+j+\": \"+nums[i]+\" \"+re.get(j)+\" \"+re.size());\n\n                if (re.get(j) >= nums[i]){\n                    check = true;\n                    re.set(j,nums[i]);\n                    break;\n                }\n            }\n            if (!check) re.add(nums[i]);\n        }\n    // for (int i: re)\n    // {\n    //     System.out.println(i);\n    // }\n    return re.size();\n    }\n}","runtime":"10 ms","title":"Longest Increasing Subsequence","url":"/submissions/detail/1068134934/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1068134934,"time":"3 months, 3 weeks","lang":"java","title_slug":"longest-increasing-subsequence","timestamp":1696545703,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"43 MB","code":"class Solution {\n    public int lengthOfLIS(int[] nums) {\n        ArrayList<Integer> re = new ArrayList<Integer>();\n        for (int i = 0;i<nums.length;i++){\n            boolean check = false;\n            for (int j = 0;j<re.size();j++){\n                // System.out.println(i+\", \"+j+\": \"+nums[i]+\" \"+re.get(j)+\" \"+re.size());\n\n                if (re.get(j) >= nums[i]){\n                    check = true;\n                    re.set(j,nums[i]);\n                    break;\n                }\n            }\n            if (!check) re.add(nums[i]);\n        }\n    for (int i: re)\n    {\n        System.out.println(i);\n    }\n    return re.size();\n    }\n}","runtime":"22 ms","title":"Longest Increasing Subsequence","url":"/submissions/detail/1068134848/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1068134848,"time":"3 months, 3 weeks","lang":"java","title_slug":"longest-increasing-subsequence","timestamp":1696545690,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"43.3 MB","code":"class Solution {\n    public int lengthOfLIS(int[] nums) {\n        ArrayList<Integer> re = new ArrayList<Integer>();\n        for (int i = 0;i<nums.length;i++){\n            boolean check = false;\n            for (int j = 0;j<re.size();j++){\n                if (re.get(j) >= nums[i]){\n                    check = true;\n                    re.set(j,nums[i]);\n                    break;\n                }\n            }\n            if (!check) re.add(nums[i]);\n        }\n    for (int i: re)\n    {\n        System.out.println(i);\n    }\n    return re.size();\n    }\n}","runtime":"20 ms","title":"Longest Increasing Subsequence","url":"/submissions/detail/1068132728/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1068132728,"time":"3 months, 3 weeks","lang":"java","title_slug":"longest-increasing-subsequence","timestamp":1696545374,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int lengthOfLIS(int[] nums) {\n        ArrayList<Integer> re = new ArrayList<Integer>();\n        for (int i = 0;i<nums.length;i++){\n            boolean check = false;\n            for (int j = 0;j<re.size();j++){\n                if (re.get(j) >= nums[i]){\n                    check = true;\n                    re.set(j,nums[i]);\n                }\n            }\n            if (!check) re.add(nums[i]);\n        }\n    return re.size();\n    }\n}","runtime":"N/A","title":"Longest Increasing Subsequence","url":"/submissions/detail/1068129248/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1068129248,"time":"3 months, 3 weeks","lang":"java","title_slug":"longest-increasing-subsequence","timestamp":1696544891,"status":11,"is_pending":"Not Pending","compare_result":"1111111111111010010011111010001010000000000000000000001"}],"has_next":false,"last_key":""}
2024-01-26 23:37:32.305 [main] DEBUG submission_dump - {"submissions_dump":[{"status_display":"Wrong Answer","memory":"N/A","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<Integer> rightSideView(TreeNode root) {\n        // if (root == null) return null;\n        List<Integer> ans = new ArrayList<>();\n        TreeNode pointer = root;\n        \n        while(pointer != null){\n            ans.add(pointer.val);\n            pointer = pointer.right;\n        }\n        return ans;\n    }\n}","runtime":"N/A","title":"Binary Tree Right Side View","url":"/submissions/detail/1155118137/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1155118137,"time":"3 days, 2 hours","lang":"java","title_slug":"binary-tree-right-side-view","timestamp":1706061436,"status":11,"is_pending":"Not Pending","compare_result":"111101000100100010000000000011001100000100000000000010000000010000001100000001000000010000000000000000000100000010000000000000000000000000001000000110010110100001001000000011000100010000010000010000000000000000000001"},{"status_display":"Accepted","memory":"48.5 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass BSTIterator {\n    ArrayList<TreeNode> list;\n    int index;\n    public BSTIterator(TreeNode root) {\n        list = new ArrayList<>();\n        inOrder(root);\n        index = -1;\n    }\n    \n    public int next() {\n        index++;\n        return list.get(index).val;\n    }\n    \n    public boolean hasNext() {\n        // System.out.println(index +\" \" + list.size());\n        return index+1<list.size();\n    }\n    public void inOrder(TreeNode root){\n        if (root == null) return;\n        inOrder(root.left);\n        list.add(root);\n        inOrder(root.right);\n        return;\n    }\n}\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * BSTIterator obj = new BSTIterator(root);\n * int param_1 = obj.next();\n * boolean param_2 = obj.hasNext();\n */","runtime":"16 ms","title":"Binary Search Tree Iterator","url":"/submissions/detail/1155110222/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1155110222,"time":"3 days, 2 hours","lang":"java","title_slug":"binary-search-tree-iterator","timestamp":1706060502,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"48.1 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass BSTIterator {\n    ArrayList<TreeNode> list;\n    int index;\n    public BSTIterator(TreeNode root) {\n        list = new ArrayList<>();\n        inOrder(root);\n        index = -1;\n    }\n    \n    public int next() {\n        index++;\n        return list.get(index).val;\n    }\n    \n    public boolean hasNext() {\n        // System.out.println(index +\" \" + list.size());\n        return index+1<list.size();\n    }\n    public void inOrder(TreeNode root){\n        if (root == null) return;\n        inOrder(root.left);\n        list.add(root);\n        inOrder(root.right);\n        return;\n    }\n}\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * BSTIterator obj = new BSTIterator(root);\n * int param_1 = obj.next();\n * boolean param_2 = obj.hasNext();\n */","runtime":"16 ms","title":"Binary Search Tree Iterator","url":"/submissions/detail/1155109987/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1155109987,"time":"3 days, 2 hours","lang":"java","title_slug":"binary-search-tree-iterator","timestamp":1706060472,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"41.7 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int s = 0;\n\n    public int sumNumbers(TreeNode root) {\n        findNum(root, 0);\n        return s;\n    }\n\n    public void findNum(TreeNode root, int cur){\n        if (root == null) return;\n        if (root.left ==null && root.right == null){\n            s = s + cur*10 + root.val;\n            // System.out.println(cur*10 + root.val);\n\n            return;\n        }\n        findNum(root.left, cur*10 + root.val);\n        findNum(root.right, cur*10 + root.val);\n    }\n}","runtime":"0 ms","title":"Sum Root to Leaf Numbers","url":"/submissions/detail/1155065697/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1155065697,"time":"3 days, 4 hours","lang":"java","title_slug":"sum-root-to-leaf-numbers","timestamp":1706054765,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int s = 0;\n\n    public int sumNumbers(TreeNode root) {\n        findNum(root, 0);\n        return s/2;\n    }\n\n    public void findNum(TreeNode root, int cur){\n        if (root == null){\n            System.out.println(cur);\n            s = s + cur;\n            return;\n        }\n        findNum(root.left, cur*10 + root.val);\n        findNum(root.right, cur*10 + root.val);\n    }\n}","runtime":"N/A","title":"Sum Root to Leaf Numbers","url":"/submissions/detail/1155064160/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1155064160,"time":"3 days, 4 hours","lang":"java","title_slug":"sum-root-to-leaf-numbers","timestamp":1706054547,"status":11,"is_pending":"Not Pending","compare_result":"111111111000001000010000000011000010000000000100100000000000000000100000100000000000000000000000000000000000"},{"status_display":"Accepted","memory":"42.4 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public void flatten(TreeNode root) {\n        ArrayList<TreeNode> list = new ArrayList<>();\n        preOrder(root,list);\n        for (int i = 0;i<list.size()-1;i++){\n            list.get(i).left = null;\n            list.get(i).right = list.get(i+1);\n        }\n        \n    }\n\n    public void preOrder(TreeNode root, ArrayList list){\n        if (root == null) return;\n        list.add(root);\n        preOrder(root.left, list);\n        preOrder(root.right, list);\n        return;\n    }\n}","runtime":"1 ms","title":"Flatten Binary Tree to Linked List","url":"/submissions/detail/1155057866/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1155057866,"time":"3 days, 4 hours","lang":"java","title_slug":"flatten-binary-tree-to-linked-list","timestamp":1706053678,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"44.2 MB","code":"/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public Node left;\n    public Node right;\n    public Node next;\n\n    public Node() {}\n    \n    public Node(int _val) {\n        val = _val;\n    }\n\n    public Node(int _val, Node _left, Node _right, Node _next) {\n        val = _val;\n        left = _left;\n        right = _right;\n        next = _next;\n    }\n};\n*/\n\nclass Solution {\n    public Node connect(Node root) {\n        Queue<Node> q = new LinkedList<>();\n        int count  =  1;\n        if (root == null) return null;\n        q.add(root);\n        int nextLayer = 0;\n        \n        while (! q.isEmpty()) {\n                Node cur = q.poll();\n                count --;\n                if (cur.left != null) {\n                    nextLayer++;\n                    q.add(cur.left);\n                }\n                if (cur.right != null) {\n                    nextLayer++;\n                    q.add(cur.right);\n                }\n                if (count == 0){\n                    count = nextLayer;\n                    nextLayer = 0;\n                } else{\n                    cur.next = q.peek();\n                }\n        }\n\n        return root;\n    }\n}","runtime":"2 ms","title":"Populating Next Right Pointers in Each Node II","url":"/submissions/detail/1153077000/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1153077000,"time":"5 days, 3 hours","lang":"java","title_slug":"populating-next-right-pointers-in-each-node-ii","timestamp":1705884564,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"44.3 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        return build(postorder, inorder, 0, postorder.length-1, 0 , inorder.length-1);\n    }\n\n    public TreeNode build(int[] postorder, int[] inorder, int post_x, int post_y, int in_x, int in_y){\n        if (post_x > post_y) return null;\n        if (in_x > in_y) return null;\n        if (post_x <0) return null;\n        if (post_y <0) return null;\n        TreeNode root = new TreeNode(postorder[post_y]);\n        int left_in = -1;\n        int right_in = -1;\n        int size = -1;\n        for (int i = in_x; i<=in_y;i++){\n            if (inorder[i] == postorder[post_y]) {\n                left_in = i -1;\n                right_in = i+1;\n                break;\n            }\n        }\n        int size_left = left_in - in_x +1; // dont add 1 because i have to subjact it again, \n                                        //  or add 1 and subject it again whatever less confusing\n        int size_right = in_y - right_in+1;\n        // System.out.println(post_x + \" \"+ post_y + \" \"+ in_x +\" \"+ in_y);\n        int temp_post_left_x = post_x;\n        int temp_post_left_y = post_x + size_left - 1;\n        int temp_in_left_x = in_x;\n        int temp_in_left_y = left_in;\n\n        int temp_post_right_x = post_x + size_left ;\n        int temp_post_right_y = post_x + size_left + size_right - 1;\n        int temp_in_right_x = right_in;\n        int temp_in_right_y = in_y;\n        // System.out.println(\"Left: \"+ temp_pre_left_x +\" \" +temp_pre_left_y+ \" \" + temp_in_left_x + \" \" + temp_in_left_y);\n        // System.out.println(\"Right: \"+ temp_pre_right_x + \" \" +temp_pre_right_y + \" \" + temp_in_right_x +\" \"+ temp_in_right_y);\n        root.left = build(postorder, inorder, temp_post_left_x, temp_post_left_y, temp_in_left_x, temp_in_left_y );\n        root.right = build(postorder, inorder, temp_post_right_x, temp_post_right_y, temp_in_right_x, temp_in_right_y);\n\n        return root;\n    }\n}","runtime":"3 ms","title":"Construct Binary Tree from Inorder and Postorder Traversal","url":"/submissions/detail/1153064874/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1153064874,"time":"5 days, 4 hours","lang":"java","title_slug":"construct-binary-tree-from-inorder-and-postorder-traversal","timestamp":1705883188,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"43.8 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        return build(preorder, inorder, 0, preorder.length -1, 0, inorder.length-1);\n    }\n\n    public TreeNode build(int[] preorder, int[] inorder, int pre_x, int pre_y, int in_x, int in_y){\n        if (pre_x > pre_y) return null;\n        if (in_x > in_y) return null;\n        if (pre_x <0) return null;\n        if (pre_y <0) return null;\n        TreeNode root = new TreeNode(preorder[pre_x]);\n        int left_in = -1;\n        int right_in = -1;\n        int size = -1;\n        for (int i = in_x; i<=in_y;i++){\n            if (inorder[i] == preorder[pre_x]) {\n                left_in = i -1;\n                right_in = i+1;\n                break;\n            }\n        }\n        int size_left = left_in - in_x +1; // dont add 1 because i have to subjact it again, \n                                        //  or add 1 and subject it again whatever less confusing\n        int size_right = in_y - right_in+1;\n        // System.out.println(pre_x + \" \"+ pre_y + \" \"+ in_x +\" \"+ in_y);\n        int temp_pre_left_x = pre_x+1;\n        int temp_pre_left_y = pre_x + size_left;\n        int temp_in_left_x = in_x;\n        int temp_in_left_y = left_in;\n\n        int temp_pre_right_x = pre_x + size_left + 1;\n        int temp_pre_right_y = pre_x + size_left + size_right;\n        int temp_in_right_x = right_in;\n        int temp_in_right_y = in_y;\n        // System.out.println(\"Left: \"+ temp_pre_left_x +\" \" +temp_pre_left_y+ \" \" + temp_in_left_x + \" \" + temp_in_left_y);\n        // System.out.println(\"Right: \"+ temp_pre_right_x + \" \" +temp_pre_right_y + \" \" + temp_in_right_x +\" \"+ temp_in_right_y);\n        root.left = build(preorder, inorder, temp_pre_left_x, temp_pre_left_y, temp_in_left_x, temp_in_left_y );\n        root.right = build(preorder, inorder, temp_pre_right_x, temp_pre_right_y, temp_in_right_x, temp_in_right_y);\n\n        return root;\n    }\n}","runtime":"3 ms","title":"Construct Binary Tree from Preorder and Inorder Traversal","url":"/submissions/detail/1152982225/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1152982225,"time":"5 days, 7 hours","lang":"java","title_slug":"construct-binary-tree-from-preorder-and-inorder-traversal","timestamp":1705873028,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"46.1 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        return build(preorder, inorder, 0, preorder.length -1, 0, inorder.length-1);\n    }\n\n    public TreeNode build(int[] preorder, int[] inorder, int pre_x, int pre_y, int in_x, int in_y){\n        if (pre_x > pre_y) return null;\n        if (in_x > in_y) return null;\n        if (pre_x <0) return null;\n        if (pre_y <0) return null;\n        TreeNode root = new TreeNode(preorder[pre_x]);\n        int left_in = -1;\n        int right_in = -1;\n        int size = -1;\n        for (int i = in_x; i<=in_y;i++){\n            if (inorder[i] == preorder[pre_x]) {\n                left_in = i -1;\n                right_in = i+1;\n                break;\n            }\n        }\n        int size_left = left_in - in_x +1; // dont add 1 because i have to subjact it again, \n                                        //  or add 1 and subject it again whatever less confusing\n        int size_right = in_y - right_in+1;\n        System.out.println(pre_x + \" \"+ pre_y + \" \"+ in_x +\" \"+ in_y);\n        int temp_pre_left_x = pre_x+1;\n        int temp_pre_left_y = pre_x + size_left;\n        int temp_in_left_x = in_x;\n        int temp_in_left_y = left_in;\n\n        int temp_pre_right_x = pre_x + size_left + 1;\n        int temp_pre_right_y = pre_x + size_left + size_right;\n        int temp_in_right_x = right_in;\n        int temp_in_right_y = in_y;\n        System.out.println(\"Left: \"+ temp_pre_left_x +\" \" +temp_pre_left_y+ \" \" + temp_in_left_x + \" \" + temp_in_left_y);\n        System.out.println(\"Right: \"+ temp_pre_right_x + \" \" +temp_pre_right_y + \" \" + temp_in_right_x +\" \"+ temp_in_right_y);\n        root.left = build(preorder, inorder, temp_pre_left_x, temp_pre_left_y, temp_in_left_x, temp_in_left_y );\n        root.right = build(preorder, inorder, temp_pre_right_x, temp_pre_right_y, temp_in_right_x, temp_in_right_y);\n\n        return root;\n    }\n}","runtime":"48 ms","title":"Construct Binary Tree from Preorder and Inorder Traversal","url":"/submissions/detail/1152981992/","lang_name":"Java","has_notes":true,"flag_type":1,"id":1152981992,"time":"5 days, 7 hours","lang":"java","title_slug":"construct-binary-tree-from-preorder-and-inorder-traversal","timestamp":1705873000,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"44.1 MB","code":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode reverseKGroup(ListNode head, int k) {\n        ArrayList<ListNode> array = new ArrayList<>();\n        ListNode cur = head;\n        while (cur != null){\n            array.add(cur);\n            cur = cur.next;\n        }\n        int size = k-1;\n        int max= array.size() - (array.size() % k );\n        for (int i = 0;i<max;i++){\n            // System.out.println(i+\" \"+size);\n            if (size == 1-k) {\n                size = k-1;\n                continue;\n            }\n            if (size <= 0) {\n                size = size - 2;\n                continue; \n            }\n            int temp = array.get(i).val;\n            array.get(i).val = array.get(i+size).val;\n            array.get(i+size).val = temp;\n            size = size - 2;\n        }\n        return head;\n\n    }\n}","runtime":"2 ms","title":"Reverse Nodes in k-Group","url":"/submissions/detail/1152895777/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1152895777,"time":"5 days, 9 hours","lang":"java","title_slug":"reverse-nodes-in-k-group","timestamp":1705864662,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"44.4 MB","code":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode reverseKGroup(ListNode head, int k) {\n        ArrayList<ListNode> array = new ArrayList<>();\n        ListNode cur = head;\n        while (cur != null){\n            array.add(cur);\n            cur = cur.next;\n        }\n        int size = k-1;\n        int max= array.size() - (array.size() % k );\n        for (int i = 0;i<max;i++){\n            System.out.println(i+\" \"+size);\n            if (size == 1-k) {\n                size = k-1;\n                continue;\n            }\n            if (size <= 0) {\n                size = size - 2;\n                continue; \n            }\n            int temp = array.get(i).val;\n            array.get(i).val = array.get(i+size).val;\n            array.get(i+size).val = temp;\n            size = size - 2;\n        }\n        return head;\n\n    }\n}","runtime":"43 ms","title":"Reverse Nodes in k-Group","url":"/submissions/detail/1152895510/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1152895510,"time":"5 days, 9 hours","lang":"java","title_slug":"reverse-nodes-in-k-group","timestamp":1705864641,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"44.1 MB","code":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode reverseKGroup(ListNode head, int k) {\n        ArrayList<ListNode> array = new ArrayList<>();\n        ListNode cur = head;\n        while (cur != null){\n            array.add(cur);\n            cur = cur.next;\n        }\n        int size = k-1;\n        int max= array.size() - (array.size() % k );\n        for (int i = 0;i<max;i++){\n            System.out.println(i+\" \"+size);\n            if (size == 1-k) {\n                size = k-1;\n                continue;\n            }\n            if (size <= 0) {\n                size = size - 2;\n                continue; \n            }\n            int temp = array.get(i).val;\n            array.get(i).val = array.get(i+size).val;\n            array.get(i+size).val = temp;\n            size = size - 2;\n        }\n        return head;\n\n    }\n}","runtime":"42 ms","title":"Reverse Nodes in k-Group","url":"/submissions/detail/1152895243/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1152895243,"time":"5 days, 9 hours","lang":"java","title_slug":"reverse-nodes-in-k-group","timestamp":1705864620,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode reverseKGroup(ListNode head, int k) {\n        ArrayList<ListNode> array = new ArrayList<>();\n        ListNode cur = head;\n        while (cur != null){\n            array.add(cur);\n            cur = cur.next;\n        }\n        int size = k-1;\n        for (int i = 0;i<=array.size()-k;i++){\n            if (size == 1-k) {\n                size = k-1;\n                continue;\n            }\n            if (size <= 0) {\n                size = size - 2;\n                continue; \n            }\n            int temp = array.get(i).val;\n            array.get(i).val = array.get(i+size).val;\n            array.get(i+size).val = temp;\n            size = size - 2;\n        }\n        return head;\n\n    }\n}","runtime":"N/A","title":"Reverse Nodes in k-Group","url":"/submissions/detail/1152890811/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1152890811,"time":"5 days, 9 hours","lang":"java","title_slug":"reverse-nodes-in-k-group","timestamp":1705864259,"status":11,"is_pending":"Not Pending","compare_result":"11111111111101011111010111101101111111111111111100000101110110"},{"status_display":"Wrong Answer","memory":"N/A","code":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode reverseKGroup(ListNode head, int k) {\n        ArrayList<ListNode> array = new ArrayList<>();\n        ListNode cur = head;\n        while (cur != null){\n            array.add(cur);\n            cur = cur.next;\n        }\n        int size = k-1;\n        for (int i = 0;i<=array.size()-k;i++){\n            if (size == 1-k) {\n                size = k-1;\n                continue;\n            }\n            if (size <= 0) continue; \n            int temp = array.get(i).val;\n            array.get(i).val = array.get(i+size).val;\n            array.get(i+size).val = temp;\n            size = size - 2;\n        }\n        return head;\n\n    }\n}","runtime":"N/A","title":"Reverse Nodes in k-Group","url":"/submissions/detail/1152889496/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1152889496,"time":"5 days, 9 hours","lang":"java","title_slug":"reverse-nodes-in-k-group","timestamp":1705864156,"status":11,"is_pending":"Not Pending","compare_result":"11111111111101011011000111101101111001010001001000000001010010"},{"status_display":"Wrong Answer","memory":"N/A","code":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode reverseKGroup(ListNode head, int k) {\n        ArrayList<ListNode> array = new ArrayList<>();\n        ListNode cur = head;\n        while (cur != null){\n            array.add(cur);\n            cur = cur.next;\n        }\n        int size = k-1;\n        for (int i = 0;i<=array.size()-k;i++){\n            if (size == 1-k) {\n                size = k-1;\n                continue;\n            }\n            if (size < 0) continue; \n            int temp = array.get(i).val;\n            array.get(i).val = array.get(i+size).val;\n            array.get(i+size).val = temp;\n            size = size - 2;\n        }\n        return head;\n\n    }\n}","runtime":"N/A","title":"Reverse Nodes in k-Group","url":"/submissions/detail/1152889022/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1152889022,"time":"5 days, 9 hours","lang":"java","title_slug":"reverse-nodes-in-k-group","timestamp":1705864116,"status":11,"is_pending":"Not Pending","compare_result":"11111111111101011111000111101101111111010101001000000001010010"},{"status_display":"Accepted","memory":"41.1 MB","code":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode reverseBetween(ListNode head, int left, int right) {\n        if (left == right ) return head;\n        ListNode begin = null;\n        ListNode end = null;\n\n        ListNode cur = head;\n        ListNode cur_beg = null;\n        ListNode cur_end = null;\n        ListNode prev = null;\n        int count = 1;\n        \n\n        while (cur != null ){\n            \n            if (count == left - 1) begin = cur;\n            if (count == right + 1) end = cur;\n            if (count >= left && count <= right){\n                ListNode temp = new ListNode(cur.val, prev);\n                prev = temp;\n                if (count == left) cur_end = temp;\n                if (count == right) cur_beg = temp;\n            }\n            count++;\n            cur = cur.next;\n        }\n        if (begin !=null){\n            begin.next = cur_beg;\n        } else{\n            head = cur_beg;\n        } \n        if (end != null ){\n            cur_end.next = end;\n        }\n\n        return head;\n    }\n}","runtime":"0 ms","title":"Reverse Linked List II","url":"/submissions/detail/1152858894/","lang_name":"Java","has_notes":true,"flag_type":1,"id":1152858894,"time":"5 days, 10 hours","lang":"java","title_slug":"reverse-linked-list-ii","timestamp":1705861807,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"0B","code":"-- Write your PostgreSQL query statement below\nselect name, population, area \nfrom World\nwhere area>=3000000 or population>=25000000;","runtime":"782 ms","title":"Big Countries","url":"/submissions/detail/1135029736/","lang_name":"PostgreSQL","has_notes":false,"flag_type":1,"id":1135029736,"time":"3 weeks, 3 days","lang":"postgresql","title_slug":"big-countries","timestamp":1704231310,"status":10,"is_pending":"Not Pending","compare_result":"111111"},{"status_display":"Accepted","memory":"0B","code":"-- Write your PostgreSQL query statement below\nselect name \nfrom Customer\nwhere referee_id !=2  or referee_id IS NULL","runtime":"609 ms","title":"Find Customer Referee","url":"/submissions/detail/1135026138/","lang_name":"PostgreSQL","has_notes":false,"flag_type":1,"id":1135026138,"time":"3 weeks, 3 days","lang":"postgresql","title_slug":"find-customer-referee","timestamp":1704230934,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111"},{"status_display":"Accepted","memory":"0B","code":"-- Write your PostgreSQL query statement below\nselect name \nfrom Customer\nwhere referee_id IS NULL OR referee_id !=2;","runtime":"676 ms","title":"Find Customer Referee","url":"/submissions/detail/1135025905/","lang_name":"PostgreSQL","has_notes":false,"flag_type":1,"id":1135025905,"time":"3 weeks, 3 days","lang":"postgresql","title_slug":"find-customer-referee","timestamp":1704230907,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111"}],"has_next":true,"last_key":"%7B%22pk%22%3A%20%7B%22N%22%3A%20%221135025905%22%7D%2C%20%22dt%22%3A%20%7B%22S%22%3A%20%222024-01-02T21%3A28%3A27.965396%2B0000%22%7D%2C%20%22sid%22%3A%20%7B%22N%22%3A%20%227573785%22%7D%7D"}
2024-01-26 23:37:43.068 [main] DEBUG submission_dump - {"submissions_dump":[{"status_display":"Accepted","memory":"0B","code":"-- Write your PostgreSQL query statement below\nselect name \nfrom Customer\nwhere referee_id IS NULL OR referee_id !=2;","runtime":"541 ms","title":"Find Customer Referee","url":"/submissions/detail/1135025610/","lang_name":"PostgreSQL","has_notes":false,"flag_type":1,"id":1135025610,"time":"3 weeks, 3 days","lang":"postgresql","title_slug":"find-customer-referee","timestamp":1704230873,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111"},{"status_display":"Accepted","memory":"0B","code":"-- Write your PostgreSQL query statement below\nSELECT product_id from Products where low_fats='Y' AND recyclable= 'Y'","runtime":"1275 ms","title":"Recyclable and Low Fat Products","url":"/submissions/detail/1135023400/","lang_name":"PostgreSQL","has_notes":false,"flag_type":1,"id":1135023400,"time":"3 weeks, 3 days","lang":"postgresql","title_slug":"recyclable-and-low-fat-products","timestamp":1704230643,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111"},{"status_display":"Accepted","memory":"44 MB","code":"/*\n// Definition for a Node.\nclass Node {\n    int val;\n    Node next;\n    Node random;\n\n    public Node(int val) {\n        this.val = val;\n        this.next = null;\n        this.random = null;\n    }\n}\n*/\n\nclass Solution {\n    public Node copyRandomList(Node head) {\n        if (head == null) return null;\n\n        HashMap<Node,Node> map = new HashMap<>();\n        Node temp = new Node(head.val);\n        map.put(head,temp);\n        Node p = head.next;\n        Node prev = temp;\n        while (p!=null){\n            Node t = new Node(p.val);\n            prev.next = t;\n            map.put(p,t);\n            prev = prev.next;\n            p = p.next;\n        }\n        for (Node i: map.keySet()){\n            Node t = map.get(i);\n            t.random = map.get(i.random);\n        }\n        \n\n        return temp;\n    }\n}","runtime":"1 ms","title":"Copy List with Random Pointer","url":"/submissions/detail/1130075199/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1130075199,"time":"1 month","lang":"java","title_slug":"copy-list-with-random-pointer","timestamp":1703718042,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111"},{"status_display":"Accepted","memory":"44.4 MB","code":"/*\n// Definition for a Node.\nclass Node {\n    int val;\n    Node next;\n    Node random;\n\n    public Node(int val) {\n        this.val = val;\n        this.next = null;\n        this.random = null;\n    }\n}\n*/\n\nclass Solution {\n    public Node copyRandomList(Node head) {\n        if (head == null) return null;\n\n        HashMap<Node,Node> map = new HashMap<>();\n        Node temp = new Node(head.val);\n        map.put(head,temp);\n        Node p = head.next;\n        Node prev = temp;\n        while (p!=null){\n            Node t = new Node(p.val);\n            prev.next = t;\n            map.put(p,t);\n            prev = prev.next;\n            p = p.next;\n        }\n        for (Node i: map.keySet()){\n            Node t = map.get(i);\n            t.random = map.get(i.random);\n        }\n        \n\n        return temp;\n    }\n}","runtime":"1 ms","title":"Copy List with Random Pointer","url":"/submissions/detail/1130074485/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1130074485,"time":"1 month","lang":"java","title_slug":"copy-list-with-random-pointer","timestamp":1703717948,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111"},{"status_display":"Runtime Error","memory":"N/A","code":"/*\n// Definition for a Node.\nclass Node {\n    int val;\n    Node next;\n    Node random;\n\n    public Node(int val) {\n        this.val = val;\n        this.next = null;\n        this.random = null;\n    }\n}\n*/\n\nclass Solution {\n    public Node copyRandomList(Node head) {\n        HashMap<Node,Node> map = new HashMap<>();\n        Node temp = new Node(head.val);\n        map.put(head,temp);\n        Node p = head.next;\n        Node prev = temp;\n        while (p!=null){\n            Node t = new Node(p.val);\n            prev.next = t;\n            map.put(p,t);\n            prev = prev.next;\n            p = p.next;\n        }\n        for (Node i: map.keySet()){\n            Node t = map.get(i);\n            t.random = map.get(i.random);\n        }\n        \n\n        return temp;\n    }\n}","runtime":"N/A","title":"Copy List with Random Pointer","url":"/submissions/detail/1130074216/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1130074216,"time":"1 month","lang":"java","title_slug":"copy-list-with-random-pointer","timestamp":1703717916,"status":15,"is_pending":"Not Pending","compare_result":"1110000000000000000"},{"status_display":"Accepted","memory":"44.1 MB","code":"class Solution {\n    public int calculate(String s) {\n        Stack<Integer> st= new Stack<>();\n        char [] ch = s.toCharArray();\n        int sign = 1;\n        int runSum = 0;\n        int runNum = 0;\n        for (int i = 0;i<ch.length;i++){\n            if (ch[i]<='9' && ch[i]>='0'){\n                runNum = runNum*10 + (ch[i] - '0');\n            }\n            if (ch[i] == '+'){\n                runSum = runSum + sign*runNum;\n                sign = 1;\n                runNum = 0;\n            }\n            if (ch[i] == '-') {\n                runSum = runSum + sign*runNum;\n                sign = -1;\n                runNum = 0;\n            }\n            if (ch[i] =='('){\n                st.add(runSum);\n                st.add(sign);\n                runNum = 0;\n                runSum=0;\n                sign = 1;\n            }\n            if (ch[i] == ')'){\n                runSum = runSum + sign*runNum;\n                int tempSign = st.pop();\n                int oldSum = st.pop();\n                runSum = tempSign*runSum + oldSum;\n                runNum = 0;\n            }\n            // System.out.println(runSum +\" \"+ runNum + \" \" +sign);\n        }\n         runSum = runSum + sign*runNum;\n        return runSum;\n\n    }\n        \n}","runtime":"5 ms","title":"Basic Calculator","url":"/submissions/detail/1123906417/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1123906417,"time":"1 month, 1 week","lang":"java","title_slug":"basic-calculator","timestamp":1703045772,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int calculate(String s) {\n        Stack<Integer> st= new Stack<>();\n        char [] ch = s.toCharArray();\n        int sign = 1;\n        int runSum = 0;\n        int runNum = 0;\n        for (int i = 0;i<ch.length;i++){\n            if (ch[i]<='9' && ch[i]>='0'){\n                runNum = runNum*10 + (ch[i] - '0');\n            }\n            if (ch[i] == '+'){\n                runSum = runSum + sign*runNum;\n                sign = 1;\n                runNum = 0;\n            }\n            if (ch[i] == '-') {\n                runSum = runSum + sign*runNum;\n                sign = -1;\n                runNum = 0;\n            }\n            if (ch[i] =='('){\n                st.add(runSum);\n                st.add(sign);\n                runNum = 0;\n                runSum=0;\n            }\n            if (ch[i] == ')'){\n                runSum = runSum + sign*runNum;\n                int tempSign = st.pop();\n                int oldSum = st.pop();\n                runSum = tempSign*runSum + oldSum;\n                runNum = 0;\n            }\n            System.out.println(runSum +\" \"+ runNum + \" \" +sign);\n        }\n         runSum = runSum + sign*runNum;\n        return runSum;\n\n    }\n        \n}","runtime":"N/A","title":"Basic Calculator","url":"/submissions/detail/1123904630/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1123904630,"time":"1 month, 1 week","lang":"java","title_slug":"basic-calculator","timestamp":1703045598,"status":11,"is_pending":"Not Pending","compare_result":"111111111111101110111111100100000000000100101"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int calculate(String s) {\n        Stack<Integer> st= new Stack<>();\n        char [] ch = s.toCharArray();\n        int sign = 1;\n        int runSum = 0;\n        int runNum = 0;\n        for (int i = 0;i<ch.length;i++){\n            if (ch[i]<='9' && ch[i]>='0'){\n                runNum = runNum*10 + (ch[i] - '0');\n            }\n            if (ch[i] == '+'){\n                runSum = runSum + sign*runNum;\n                sign = 1;\n                runNum = 0;\n            }\n            if (ch[i] == '-') {\n                runSum = runSum + sign*runNum;\n                sign = -1;\n                runNum = 0;\n            }\n            if (ch[i] =='('){\n                st.add(runSum);\n                st.add(sign);\n                runNum = 0;\n                runSum=0;\n            }\n            if (ch[i] == ')'){\n                runSum = runSum + sign*runNum;\n                int tempSign = st.pop();\n                int oldSum = st.pop();\n                runSum = tempSign*runSum + oldSum;\n                runNum = 0;\n            }\n        }\n         runSum = runSum + sign*runNum;\n        return runSum;\n\n    }\n        \n}","runtime":"N/A","title":"Basic Calculator","url":"/submissions/detail/1123904460/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1123904460,"time":"1 month, 1 week","lang":"java","title_slug":"basic-calculator","timestamp":1703045581,"status":11,"is_pending":"Not Pending","compare_result":"111111111111101110111111100100000000000100101"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int calculate(String s) {\n        Stack<Integer> st= new Stack<>();\n        char [] ch = s.toCharArray();\n        int sign = 1;\n        int runSum = 0;\n        int runNum = 0;\n        for (int i = 0;i<ch.length;i++){\n            if (ch[i]<='9' && ch[i]>='0'){\n                runNum = runNum*10 + (ch[i] - '0');\n            }\n            if (ch[i] == '+'){\n                runSum = runSum + sign*runNum;\n                sign = 1;\n                runNum = 0;\n            }\n            if (ch[i] == '-') {\n                runSum = runSum + sign*runNum;\n                sign = -1;\n                runNum = 0;\n            }\n            if (ch[i] =='('){\n                st.add(runSum);\n                st.add(sign);\n                runNum = 0;\n                runSum=0;\n            }\n            if (ch[i] == ')'){\n                runSum = runSum + sign*runNum;\n                int tempSign = st.pop();\n                int oldSum = st.pop();\n                runSum = runSum + tempSign*oldSum;\n                runNum = 0;\n            }\n            // System.out.println(runSum +\" \"+ runNum + \" \" +sign);\n        }\n         runSum = runSum + sign*runNum;\n        return runSum;\n\n    }\n        \n}","runtime":"N/A","title":"Basic Calculator","url":"/submissions/detail/1123903295/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1123903295,"time":"1 month, 1 week","lang":"java","title_slug":"basic-calculator","timestamp":1703045467,"status":11,"is_pending":"Not Pending","compare_result":"111111111110101110111111100010000000000000001"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int calculate(String s) {\n        Stack<Integer> st= new Stack<>();\n        char [] ch = s.toCharArray();\n        int sign = 1;\n        int runSum = 0;\n        int runNum = 0;\n        for (int i = 0;i<ch.length;i++){\n            if (ch[i]<'9' && ch[i]>'0'){\n                runNum = runNum*10 + (ch[i] - '0');\n            }\n            if (ch[i] == '+'){\n                runSum = runSum + sign*runNum;\n                sign = 1;\n                runNum = 0;\n            }\n            if (ch[i] == '-') {\n                runSum = runSum + sign*runNum;\n                sign = -1;\n                runNum = 0;\n            }\n            if (ch[i] =='('){\n                st.add(runSum);\n                st.add(sign);\n                runNum = 0;\n                runSum=0;\n            }\n            if (ch[i] == ')'){\n                runSum = runSum + sign*runNum;\n                int tempSign = st.pop();\n                int oldSum = st.pop();\n                runSum = runSum + tempSign*oldSum;\n                runNum = 0;\n            }\n            // System.out.println(runSum +\" \"+ runNum + \" \" +sign);\n        }\n         runSum = runSum + sign*runNum;\n        return runSum;\n\n    }\n        \n}","runtime":"N/A","title":"Basic Calculator","url":"/submissions/detail/1123902299/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1123902299,"time":"1 month, 1 week","lang":"java","title_slug":"basic-calculator","timestamp":1703045372,"status":11,"is_pending":"Not Pending","compare_result":"111111101010100110101111100010000000000000001"},{"status_display":"Accepted","memory":"40.8 MB","code":"class Solution {\n    public void gameOfLife(int[][] board) {\n        int n = board.length;\n        int m = board[0].length;\n        for (int i=0;i<n;i++){\n            for (int j=0;j<m;j++){\n                int count = countValid(board,i-1,j-1) + countValid(board,i-1,j) +  countValid(board,i-1,j+1)\n                            + countValid(board,i,j-1) + countValid(board,i,j+1)\n                            + countValid(board,i+1,j-1) + countValid(board,i+1,j) + countValid(board,i+1,j+1);\n                // System.out.println(i+\" \"+j+\" \"+board[i][j]+\" \"+count) ;\n                if (board[i][j] %2 == 0 && count == 3) board[i][j] = board[i][j]+2;\n                if (board[i][j] %2 == 1 && (count ==2 || count==3)) board[i][j] = board[i][j]+2;\n            }\n        }\n        for (int i = 0;i<n;i++){\n            for (int j = 0;j<m;j++){\n                board[i][j] = board[i][j]>>1;\n            }\n        }\n    }\n\n    public int countValid(int[][] board, int x, int y){\n        int n = board.length;\n        int m = board[0].length; \n        if (x<0) return 0;\n        if (y<0) return 0;\n        if (x>=n) return 0;\n        if (y>=m) return 0;\n        return board[x][y]%2 == 0?0:1 ;\n    }\n}","runtime":"0 ms","title":"Game of Life","url":"/submissions/detail/1123838000/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1123838000,"time":"1 month, 1 week","lang":"java","title_slug":"game-of-life","timestamp":1703037806,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111"},{"status_display":"Accepted","memory":"43.3 MB","code":"class Solution {\n    public int evalRPN(String[] tokens) {\n      Stack<Integer> stack = new Stack<>();\n      for(String s: tokens){\n        if (s.equals(\"+\")){\n          int a = stack.pop();\n          int b = stack.pop();\n          stack.add(b+a);\n        }\n        else if (s.equals(\"-\")){\n          int a = stack.pop();\n          int b = stack.pop();\n          stack.add(b-a);\n        }\n        else if (s.equals(\"*\")){\n          int a = stack.pop();\n          int b = stack.pop();\n          stack.add(b*a);\n        }\n        else if (s.equals(\"/\")){\n          int a = stack.pop();\n          int b = stack.pop();\n          stack.add(b/a);\n        }\n        else stack.add(Integer.parseInt(s));\n      }\n        \n        return stack.pop();\n    }\n\n    \n}","runtime":"7 ms","title":"Evaluate Reverse Polish Notation","url":"/submissions/detail/1113956236/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1113956236,"time":"1 month, 3 weeks","lang":"java","title_slug":"evaluate-reverse-polish-notation","timestamp":1701906130,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111"},{"status_display":"Accepted","memory":"46.9 MB","code":"class MinStack {\n    Stack<Integer> stack = new Stack<>();\n    Stack<Integer> min_stack = new Stack<>();\n    public MinStack() {\n        stack = new Stack<>();\n        min_stack = new Stack<>();\n    }\n    \n    public void push(int val) {\n        if (stack.empty()){\n          stack.add(val);\n          min_stack.add(val);\n        } else{\n          stack.add(val);\n          if (val<=min_stack.peek()){\n            min_stack.add(val);\n          }\n        }\n    }\n    \n    public void pop() {\n        int temp = stack.pop();\n        if (temp == min_stack.peek()) min_stack.pop();\n    }\n    \n    public int top() {\n        return stack.peek();\n    }\n    \n    public int getMin() {\n        return min_stack.peek();\n    }\n}\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack obj = new MinStack();\n * obj.push(val);\n * obj.pop();\n * int param_3 = obj.top();\n * int param_4 = obj.getMin();\n */","runtime":"4 ms","title":"Min Stack","url":"/submissions/detail/1113939690/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1113939690,"time":"1 month, 3 weeks","lang":"java","title_slug":"min-stack","timestamp":1701903046,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111"},{"status_display":"Accepted","memory":"43.6 MB","code":"class Solution {\n    public String simplifyPath(String path) {\n        String [] split = path.split(\"/+\");\n        // for (int i = 0;i<split.length;i++){\n        //   System.out.println(split[i]);\n        // }\n        Stack<String> s = new Stack<String>();\n        for (int i = 0 ; i<split.length;i++){\n          if (split[i].equals(\"..\")){\n            if (!s.empty()) s.pop();\n          } else if (!split[i].equals(\"\") && !split[i].equals(\".\")) s.add(split[i]);\n\n        }\n        String res = \"\";\n        for (String i:s){\n          // System.out.println(i);\n          res = res+ \"/\" +i;\n        }\n        if (res.equals(\"\")) return \"/\";\n        return res;\n    }\n}","runtime":"13 ms","title":"Simplify Path","url":"/submissions/detail/1113934197/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1113934197,"time":"1 month, 3 weeks","lang":"java","title_slug":"simplify-path","timestamp":1701902122,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public String simplifyPath(String path) {\n        String [] split = path.split(\"/+\");\n        for (int i = 0;i<split.length;i++){\n          System.out.println(split[i]);\n        }\n        Stack<String> s = new Stack<String>();\n        for (int i = 0 ; i<split.length;i++){\n          if (split[i].equals(\"..\")){\n            if (!s.empty()) s.pop();\n          } else if (!split[i].equals(\"\") && !split.equals(\".\")) s.add(split[i]);\n        }\n        String res = \"\";\n        for (String i:s){\n          res = res+ \"/\" +i;\n        }\n        if (res.equals(\"\")) return \"/\";\n        return res;\n    }\n}","runtime":"N/A","title":"Simplify Path","url":"/submissions/detail/1113933314/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1113933314,"time":"1 month, 3 weeks","lang":"java","title_slug":"simplify-path","timestamp":1701901967,"status":11,"is_pending":"Not Pending","compare_result":"111000110011111111111111111111101000101101111101110000010111001010100000010101101000011011000100001000000000000000000000000000000000000000000000000000000000000000000000000000000010010000000000000000000000000000000000000000000000000000000000000000000000000011"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public String simplifyPath(String path) {\n        String [] split = path.split(\"/+\");\n        for (int i = 0;i<split.length;i++){\n          System.out.println(split[i]);\n        }\n        Stack<String> s = new Stack<String>();\n        for (int i = 0 ; i<split.length;i++){\n          if (split[i].equals(\"..\")){\n            if (!s.empty()) s.pop();\n          } else if (!split[i].equals(\"\")) s.add(split[i]);\n        }\n        String res = \"\";\n        for (String i:s){\n          res = res+ \"/\" +i;\n        }\n        if (res.equals(\"\")) return \"/\";\n        return res;\n    }\n}","runtime":"N/A","title":"Simplify Path","url":"/submissions/detail/1113933042/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1113933042,"time":"1 month, 3 weeks","lang":"java","title_slug":"simplify-path","timestamp":1701901925,"status":11,"is_pending":"Not Pending","compare_result":"111000110011111111111111111111101000101101111101110000010111001010100000010101101000011011000100001000000000000000000000000000000000000000000000000000000000000000000000000000000010010000000000000000000000000000000000000000000000000000000000000000000000000011"},{"status_display":"Accepted","memory":"78 MB","code":"class Solution {\n    public int findMinArrowShots(int[][] points) {\n        Arrays.sort(points, Comparator.comparingInt(x -> x[0]));\n        int n = points.length;\n        int count = 1;\n        int[]temp = points[0];\n\n        for (int i = 1;i<n;i++){\n\n          temp = diff(temp,points[i]);\n\n          if (temp == null){\n            temp = points[i];\n            count++;\n          }\n        }\n        return count;\n    }\n    int[] diff(int[] a, int[] b) {\n      int temp [] = new int[2];\n      if (b[1]<a[0]) return null;\n      if (b[0]>a[1]) return null;\n      temp[0] = a[0]>b[0]?a[0]:b[0];\n      temp[1] = a[1]<b[1]?a[1]:b[1];\n      return temp;\n    }\n}","runtime":"59 ms","title":"Minimum Number of Arrows to Burst Balloons","url":"/submissions/detail/1113849006/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1113849006,"time":"1 month, 3 weeks","lang":"java","title_slug":"minimum-number-of-arrows-to-burst-balloons","timestamp":1701890411,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"74.8 MB","code":"class Solution {\n    public int findMinArrowShots(int[][] points) {\n        Arrays.sort(points, Comparator.comparingInt(x -> x[0]));\n        int n = points.length;\n        int count = 1;\n        int[]temp = points[0];\n        // for (int i = 0 ; i<n;i++){\n        //   System.out.println(points[i][0] +\" \" + points[i][1]);\n        // }\n        for (int i = 1;i<n;i++){\n          // System.out.println(temp[0] +\" \" + temp[1]);\n\n          temp = diff(temp,points[i]);\n\n          if (temp == null){\n            temp = points[i];\n            count++;\n          }\n        }\n        return count;\n    }\n    int[] diff(int[] a, int[] b) {\n      int temp [] = new int[2];\n      if (b[1]<a[0]) return null;\n      if (b[0]>a[1]) return null;\n      temp[0] = a[0]>b[0]?a[0]:b[0];\n      temp[1] = a[1]<b[1]?a[1]:b[1];\n      return temp;\n    }\n}","runtime":"57 ms","title":"Minimum Number of Arrows to Burst Balloons","url":"/submissions/detail/1113848308/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1113848308,"time":"1 month, 3 weeks","lang":"java","title_slug":"minimum-number-of-arrows-to-burst-balloons","timestamp":1701890333,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"43.9 MB","code":"class Solution {\n    public int[][] insert(int[][] a, int[] b) {\n        List<int[]> re = new ArrayList<>();\n        int pointer = 0;\n        int n  = a.length;\n        int [] temp = new int[2];\n        while (pointer<n && comp(a[pointer],b) == 1 ){     \n            re.add(a[pointer]);                                           \n            pointer++;\n        }\n        // System.out.println(pointer + \" \"+ comp(a[pointer],b));\n        if (pointer == n) {\n            re.add(b);\n            return toArray(re);\n        }\n        if (comp(a[pointer],b) == -1){\n            re.add(b);\n            for (int i = pointer;i<n;i++){\n                re.add(a[i]);\n            }\n            return toArray(re);\n        }\n        if (comp(a[pointer],b)==0){\n            if (b[1]<=a[pointer][1] && b[0]>=a[pointer][0]) {\n                for (int i = pointer;i<n;i++){\n                    re.add(a[i]);\n                }\n                return toArray(re);\n            } else{\n                temp[0] = a[pointer][0]<b[0]?a[pointer][0]:b[0];\n                temp[1] = b[1]>a[pointer][1]?b[1]:a[pointer][1];\n                // re.add(temp);\n                // System.out.println(temp[0]+\" \"+temp[1]);\n\n                pointer++;\n                while (pointer<n){\n                    if (comp(temp,a[pointer]) == 0){\n                        temp[1]= a[pointer][1]>temp[1]?a[pointer][1]:temp[1];\n                    } else{\n                        break;\n                    }\n                    pointer++;\n                }\n                re.add(temp);\n                for (int i = pointer;i<n;i++){\n                    re.add(a[i]);\n                }\n            }\n        }\n        return toArray(re);\n        \n    }\n    public int[][] toArray(List<int[]> re ){\n      int [][] a = new int[re.size()][2];\n      for (int i = 0; i< re.size();i++){\n        a[i][0] = re.get(i)[0];\n        a[i][1] = re.get(i)[1];\n      }\n      return a;\n    }\n    public int comp(int[] a, int[] x){\n        if (x[1]<a[0]) return -1;\n        if (x[0]>a[1]) return 1;\n        return 0;\n    }\n}","runtime":"1 ms","title":"Insert Interval","url":"/submissions/detail/1113831592/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1113831592,"time":"1 month, 3 weeks","lang":"java","title_slug":"insert-interval","timestamp":1701888553,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"44.2 MB","code":"class Solution {\n    public int[][] insert(int[][] a, int[] b) {\n        List<int[]> re = new ArrayList<>();\n        int pointer = 0;\n        int n  = a.length;\n        int [] temp = new int[2];\n        while (pointer<n && comp(a[pointer],b) == 1 ){     \n            re.add(a[pointer]);                                           \n            pointer++;\n        }\n        // System.out.println(pointer + \" \"+ comp(a[pointer],b));\n        if (pointer == n) {\n            re.add(b);\n            return toArray(re);\n        }\n        if (comp(a[pointer],b) == -1){\n            re.add(b);\n            for (int i = pointer;i<n;i++){\n                re.add(a[i]);\n            }\n            return toArray(re);\n        }\n        if (comp(a[pointer],b)==0){\n            if (b[1]<=a[pointer][1] && b[0]>=a[pointer][0]) {\n                for (int i = pointer;i<n;i++){\n                    re.add(a[i]);\n                }\n                return toArray(re);\n            } else{\n                temp[0] = a[pointer][0]<b[0]?a[pointer][0]:b[0];\n                temp[1] = b[1]>a[pointer][1]?b[1]:a[pointer][1];\n                // re.add(temp);\n                // System.out.println(temp[0]+\" \"+temp[1]);\n\n                pointer++;\n                while (pointer<n){\n                    if (comp(temp,a[pointer]) == 0){\n                        temp[1]= a[pointer][1]>temp[1]?a[pointer][1]:temp[1];\n                    } else{\n                        break;\n                    }\n                    pointer++;\n                }\n                re.add(temp);\n                for (int i = pointer;i<n;i++){\n                    re.add(a[i]);\n                }\n            }\n        }\n        return toArray(re);\n        \n    }\n    public int[][] toArray(List<int[]> re ){\n      int [][] a = new int[re.size()][2];\n      for (int i = 0; i< re.size();i++){\n        a[i][0] = re.get(i)[0];\n        a[i][1] = re.get(i)[1];\n      }\n      return a;\n    }\n    public int comp(int[] a, int[] x){\n        if (x[1]<a[0]) return -1;\n        if (x[0]>a[1]) return 1;\n        return 0;\n    }\n}","runtime":"1 ms","title":"Insert Interval","url":"/submissions/detail/1113830608/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1113830608,"time":"1 month, 3 weeks","lang":"java","title_slug":"insert-interval","timestamp":1701888456,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}],"has_next":true,"last_key":"%7B%22pk%22%3A%20%7B%22N%22%3A%20%221113830608%22%7D%2C%20%22dt%22%3A%20%7B%22S%22%3A%20%222023-12-06T18%3A47%3A36.916840%2B0000%22%7D%2C%20%22sid%22%3A%20%7B%22N%22%3A%20%227573785%22%7D%7D"}
2024-01-26 23:37:53.694 [main] DEBUG submission_dump - {"submissions_dump":[{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int[][] insert(int[][] a, int[] b) {\n        List<int[]> re = new ArrayList<>();\n        int pointer = 0;\n        int n  = a.length;\n        int [] temp = new int[2];\n        while (pointer<n && comp(a[pointer],b) == 1 ){     \n            re.add(a[pointer]);                                           \n            pointer++;\n        }\n        // System.out.println(pointer);\n        if (pointer == n) {\n            re.add(b);\n            return toArray(re);\n        }\n        if (comp(a[pointer],b) == -1){\n            re.add(b);\n            for (int i = pointer;i<n;i++){\n                re.add(a[i]);\n            }\n            return toArray(re);\n        }\n        if (comp(a[pointer],b)==0){\n            if (b[1]<=a[pointer][1]) {\n                for (int i = pointer;i<n;i++){\n                    re.add(a[i]);\n                }\n                return toArray(re);\n            } else{\n                temp[0] = a[pointer][0];\n                temp[1] = b[1];\n                // re.add(temp);\n                pointer++;\n                while (pointer<n){\n                    if (comp(temp,a[pointer]) == 0){\n                        temp[1]= a[pointer][1]>temp[1]?a[pointer][1]:temp[1];\n                    } else{\n                        break;\n                    }\n                    pointer++;\n                }\n                re.add(temp);\n                for (int i = pointer;i<n;i++){\n                    re.add(a[i]);\n                }\n            }\n        }\n        return toArray(re);\n        \n    }\n    public int[][] toArray(List<int[]> re ){\n      int [][] a = new int[re.size()][2];\n      for (int i = 0; i< re.size();i++){\n        a[i][0] = re.get(i)[0];\n        a[i][1] = re.get(i)[1];\n      }\n      return a;\n    }\n    public int comp(int[] a, int[] x){\n        if (x[0]<a[0]) return -1;\n        if (x[0]>a[1]) return 1;\n        return 0;\n    }\n}","runtime":"N/A","title":"Insert Interval","url":"/submissions/detail/1113825610/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1113825610,"time":"1 month, 3 weeks","lang":"java","title_slug":"insert-interval","timestamp":1701887947,"status":11,"is_pending":"Not Pending","compare_result":"111111110010011101011111111111111111111110111111101111110111111111111111111111111111111111110011111111111111111111011011111111111111111010011111111111110111"},{"status_display":"Accepted","memory":"43.3 MB","code":"\nclass Solution {\n    public int[] sortByBits(int[] arr) {\n        List<Integer> a = new ArrayList<Integer>();\n        for (int i :arr) a.add(i);\n        Collections.sort(a,new Comparator<Integer>() {\n            @Override\n            public int compare(Integer a, Integer b){\n                if (Integer.compare(Integer.bitCount(a),Integer.bitCount(b)) == 0) \n                    return Integer.compare(a,b);\n                return Integer.compare(Integer.bitCount(a),Integer.bitCount(b));\n            }\n        } );\n        int []re = new int[a.size()];\n        for (int i = 0; i< re.length;i++) re[i] = a.get(i);\n        return re;\n    }\n}","runtime":"9 ms","title":"Sort Integers by The Number of 1 Bits","url":"/submissions/detail/1095491223/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1095491223,"time":"2 months, 2 weeks","lang":"java","title_slug":"sort-integers-by-the-number-of-1-bits","timestamp":1699562417,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"53.7 MB","code":"class Solution {\n    public int equalPairs(int[][] grid) {\n        HashMap<String,Integer> map1 = new HashMap<>();\n        HashMap<String,Integer> map2 = new HashMap<>();\n\n        int n = grid.length;\n        int m = grid[0].length;\n        for (int i = 0 ; i<n;i++){\n            String k = \"\";\n            for (int j = 0; j<m;j++){\n                k = k+grid[i][j]+\",\";\n            }\n            map1.put(k,map1.getOrDefault(k,0)+1);\n        }\n        for (int i=0;i<m;i++){\n            String k = \"\";\n            for (int j = 0; j<n;j++){\n                k = k+grid[j][i]+\",\";\n            }\n            map2.put(k,map2.getOrDefault(k,0)+1);\n        }\n        int re = 0;\n        for (String s: map1.keySet()){\n            if (map2.containsKey(s)){\n                re = re + map1.get(s)*map2.get(s);\n            }\n        }\n        return re;\n    }\n}","runtime":"87 ms","title":"Equal Row and Column Pairs","url":"/submissions/detail/1095480296/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1095480296,"time":"2 months, 2 weeks","lang":"java","title_slug":"equal-row-and-column-pairs","timestamp":1699561122,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"44.4 MB","code":"class Solution {\n    public int countHomogenous(String s) {\n        long count = 0;\n        int pointer = 0;\n        char [] a = s.toCharArray();\n        int beg = 0;\n        while (pointer<a.length){\n            while (pointer < a.length-1 && a[pointer] == a[pointer +1]) pointer ++;\n            long len = pointer - beg +1;\n            count = (count + len*(len+1)/2) % 1000000007;\n            pointer++;\n            beg= pointer;\n        }\n        return Math.toIntExact(count);\n        \n    }\n}","runtime":"6 ms","title":"Count Number of Homogenous Substrings","url":"/submissions/detail/1095475180/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1095475180,"time":"2 months, 2 weeks","lang":"java","title_slug":"count-number-of-homogenous-substrings","timestamp":1699560549,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int countHomogenous(String s) {\n        int count = 0;\n        int pointer = 0;\n        char [] a = s.toCharArray();\n        int beg = 0;\n        while (pointer<a.length){\n            while (pointer < a.length-1 && a[pointer] == a[pointer +1]) pointer ++;\n            int len = pointer - beg +1;\n            count = (count + len*(len+1)/2) % 100000007;\n            pointer++;\n            beg= pointer;\n        }\n        return count;\n        \n    }\n}","runtime":"N/A","title":"Count Number of Homogenous Substrings","url":"/submissions/detail/1095471980/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1095471980,"time":"2 months, 2 weeks","lang":"java","title_slug":"count-number-of-homogenous-substrings","timestamp":1699560192,"status":11,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111110111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int countHomogenous(String s) {\n        int count = 0;\n        int pointer = 0;\n        char [] a = s.toCharArray();\n        int beg = 0;\n        while (pointer<a.length){\n            while (pointer < a.length-1 && a[pointer] == a[pointer +1]) pointer ++;\n            int len = pointer - beg +1;\n            count = (count + len*(len+1)/2) % 1000000007;\n            pointer++;\n            beg= pointer;\n        }\n        return count;\n        \n    }\n}","runtime":"N/A","title":"Count Number of Homogenous Substrings","url":"/submissions/detail/1095471629/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1095471629,"time":"2 months, 2 weeks","lang":"java","title_slug":"count-number-of-homogenous-substrings","timestamp":1699560151,"status":11,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111110111111"},{"status_display":"Accepted","memory":"57.9 MB","code":"class Solution {\n    public int longestConsecutive(int[] nums) {\n        HashMap<Integer,Integer> map = new HashMap<>();\n        int max = 0;\n        for (int i:nums){\n            if (map.containsKey(i)) continue;\n            if ( (map.containsKey(i-1) && map.containsKey(i+1)) ){\n                map.put(i,1+map.get(i-1)+map.get(i+1));\n                map.put(i-map.get(i-1),map.get(i));\n                map.put(i+map.get(i+1),map.get(i));\n            } else if (map.containsKey(i-1)){\n                map.put(i,map.get(i-1)+1);\n                map.put(i-map.get(i-1),map.get(i));\n            } else if (map.containsKey(i+1)){\n                map.put(i,map.get(i+1)+1);\n                map.put(i+map.get(i+1),map.get(i));\n            } else{\n                map.put(i,1);\n            }\n            if (max< map.get(i)) max = map.get(i);\n        }\n        return max; \n        \n    }\n}","runtime":"74 ms","title":"Longest Consecutive Sequence","url":"/submissions/detail/1090933513/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1090933513,"time":"2 months, 3 weeks","lang":"java","title_slug":"longest-consecutive-sequence","timestamp":1699053737,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int longestConsecutive(int[] nums) {\n        HashMap<Integer,Integer> map = new HashMap<>();\n        int max = 0;\n        for (int i:nums){\n            if ( (map.containsKey(i-1) && map.containsKey(i+1)) ){\n                map.put(i,1+map.get(i-1)+map.get(i+1));\n                map.put(i-map.get(i-1),map.get(i));\n                map.put(i+map.get(i+1),map.get(i));\n            } else if (map.containsKey(i-1)){\n                map.put(i,map.get(i-1)+1);\n                map.put(i-map.get(i-1),map.get(i));\n            } else if (map.containsKey(i+1)){\n                map.put(i,map.get(i+1)+1);\n                map.put(i+map.get(i+1),map.get(i));\n            } else{\n                map.put(i,1);\n            }\n            if (max< map.get(i)) max = map.get(i);\n        }\n        return max; \n        \n    }\n}","runtime":"N/A","title":"Longest Consecutive Sequence","url":"/submissions/detail/1090932821/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1090932821,"time":"2 months, 3 weeks","lang":"java","title_slug":"longest-consecutive-sequence","timestamp":1699053623,"status":11,"is_pending":"Not Pending","compare_result":"111111111011111011110001010000110101000000001100001010000000001011011111111"},{"status_display":"Accepted","memory":"40 MB","code":"class Solution {\n    public int uniquePathsWithObstacles(int[][] grid) {\n        int n = grid.length;\n        int m = grid[0].length;\n        int [][] dp = new int[n][m];\n        if (grid[0][0] == 1) return 0;\n        int val = 1;\n        for (int i = 0; i<n;i++){\n            if (grid[i][0] == 1) val = Integer.MAX_VALUE;\n            dp[i][0] = val;\n        }\n        val = 1;\n        for (int i = 0; i<m;i++){\n            if (grid[0][i] == 1) val = Integer.MAX_VALUE;\n            dp[0][i] = val;\n        }\n        for (int i=0;i<n;i++){\n            for (int j = 0;j<m;j++){\n                if (grid[i][j] == 1) dp[i][j] = Integer.MAX_VALUE;\n            }\n        }\n\n        // for (int i = 0;i<n;i++){\n        //     for (int j = 0; j<m ; j++){\n        //         System.out.print(dp[i][j] + \" \");\n        //     }\n        //     System.out.println();\n        // }\n        \n        for (int i = 1; i<n;i++){\n            for (int j = 1;j<m;j++){\n                if (grid[i][j] == 0) {\n                    if (valid(i-1,j,n,m,dp) == Integer.MAX_VALUE && valid(i,j-1,n,m,dp) == Integer.MAX_VALUE ) dp[i][j] = Integer.MAX_VALUE;\n                    else if (valid(i-1,j,n,m,dp)== Integer.MAX_VALUE ) dp[i][j] = valid(i,j-1,n,m,dp);\n                    else if ( valid(i,j-1,n,m,dp) == Integer.MAX_VALUE) dp[i][j] = valid(i-1,j,n,m,dp);\n                    else dp[i][j] = valid(i-1,j,n,m,dp) + valid(i,j-1,n,m,dp);\n                }\n            }\n        }\n        // for (int i = 0;i<n;i++){\n        //     for (int j = 0; j<m ; j++){\n        //         System.out.print(dp[i][j] + \" \");\n        //     }\n        //     System.out.println();\n        // }\n\n        // for (int )\n        return dp[n-1][m-1]==Integer.MAX_VALUE?0:dp[n-1][m-1];\n    }\n\n    public int valid(int x,int y,int n,int m, int [][]dp){\n        if (x>=n) return Integer.MAX_VALUE;\n        if (y>=m) return Integer.MAX_VALUE;\n        if (x<0) return Integer.MAX_VALUE;\n        if (y<0) return Integer.MAX_VALUE;\n        if (dp[x][y] == Integer.MAX_VALUE) return Integer.MAX_VALUE;\n        return dp[x][y];\n    }\n}","runtime":"1 ms","title":"Unique Paths II","url":"/submissions/detail/1089308951/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1089308951,"time":"2 months, 3 weeks","lang":"java","title_slug":"unique-paths-ii","timestamp":1698861103,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int uniquePathsWithObstacles(int[][] grid) {\n        int n = grid.length;\n        int m = grid[0].length;\n        int [][] dp = new int[n][m];\n        if (grid[0][0] == 1) return 0;\n        \n        for (int i = 0; i<n;i++){\n            dp[i][0] = 1;\n        }\n        for (int i = 0; i<m;i++){\n            dp[0][i] = 1;\n        }\n        for (int i=0;i<n;i++){\n            for (int j = 0;j<m;j++){\n                if (grid[i][j] == 1) dp[i][j] = Integer.MAX_VALUE;\n            }\n        }\n        for (int i = 1; i<n;i++){\n            for (int j = 1;j<m;j++){\n                if (grid[i][j] == 0) {\n                    if (valid(i-1,j,n,m,dp) == Integer.MAX_VALUE && valid(i,j-1,n,m,dp) == Integer.MAX_VALUE ) dp[i][j] = Integer.MAX_VALUE;\n                    else if (valid(i-1,j,n,m,dp)== Integer.MAX_VALUE ) dp[i][j] = valid(i,j-1,n,m,dp);\n                    else if ( valid(i,j-1,n,m,dp) == Integer.MAX_VALUE) dp[i][j] = valid(i-1,j,n,m,dp);\n                    else dp[i][j] = valid(i-1,j,n,m,dp) + valid(i,j-1,n,m,dp);\n                }\n            }\n        }\n\n        // for (int )\n        return dp[n-1][m-1]==Integer.MAX_VALUE?0:dp[n-1][m-1];\n    }\n\n    public int valid(int x,int y,int n,int m, int [][]dp){\n        if (x>=n) return Integer.MAX_VALUE;\n        if (y>=m) return Integer.MAX_VALUE;\n        if (x<0) return Integer.MAX_VALUE;\n        if (y<0) return Integer.MAX_VALUE;\n        if (dp[x][y] == Integer.MAX_VALUE) return Integer.MAX_VALUE;\n        return dp[x][y];\n    }\n}","runtime":"N/A","title":"Unique Paths II","url":"/submissions/detail/1089300284/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1089300284,"time":"2 months, 3 weeks","lang":"java","title_slug":"unique-paths-ii","timestamp":1698860454,"status":11,"is_pending":"Not Pending","compare_result":"11111111111111111101011110100000000111011"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int uniquePathsWithObstacles(int[][] grid) {\n        int n = grid.length;\n        int m = grid[0].length;\n        int [][] dp = new int[n][m];\n        if (grid[0][0] == 1) return 0;\n        \n        for (int i = 0; i<n;i++){\n            dp[i][0] = 1;\n        }\n        for (int i = 0; i<m;i++){\n            dp[0][i] = 1;\n        }\n        for (int i=0;i<n;i++){\n            for (int j = 0;j<m;j++){\n                if (grid[i][j] == 1) dp[i][j] = Integer.MAX_VALUE;\n            }\n        }\n        for (int i = 1; i<n;i++){\n            for (int j = 1;j<m;j++){\n                if (grid[i][j] == 0) {\n                    dp[i][j] = valid(i-1,j,n,m,dp) + valid(i,j-1,n,m,dp);\n                }\n            }\n        }\n\n        // for (int )\n        return dp[n-1][m-1]==Integer.MAX_VALUE?0:dp[n-1][m-1];\n    }\n\n    public int valid(int x,int y,int n,int m, int [][]dp){\n        if (x>=n) return 0;\n        if (y>=m) return 0;\n        if (x<0) return 0;\n        if (y<0) return 0;\n        if (dp[x][y] == Integer.MAX_VALUE) return 0;\n        return dp[x][y];\n    }\n}","runtime":"N/A","title":"Unique Paths II","url":"/submissions/detail/1088642751/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1088642751,"time":"2 months, 3 weeks","lang":"java","title_slug":"unique-paths-ii","timestamp":1698784147,"status":11,"is_pending":"Not Pending","compare_result":"11111111111111111101011110100000000111011"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int uniquePathsWithObstacles(int[][] grid) {\n        int n = grid.length;\n        int m = grid[0].length;\n        int [][] dp = new int[n][m];\n\n        \n        for (int i = 0; i<n;i++){\n            dp[i][0] = 1;\n        }\n        for (int i = 0; i<m;i++){\n            dp[0][i] = 1;\n        }\n        for (int i=0;i<n;i++){\n            for (int j = 0;j<m;j++){\n                if (grid[i][j] == 1) dp[i][j] = Integer.MAX_VALUE;\n            }\n        }\n        for (int i = 1; i<n;i++){\n            for (int j = 1;j<m;j++){\n                if (grid[i][j] == 0) {\n                    dp[i][j] = valid(i-1,j,n,m,dp) + valid(i,j-1,n,m,dp);\n                }\n            }\n        }\n\n        // for (int )\n        return dp[n-1][m-1]==Integer.MAX_VALUE?0:dp[n-1][m-1];\n    }\n\n    public int valid(int x,int y,int n,int m, int [][]dp){\n        if (x>=n) return 0;\n        if (y>=m) return 0;\n        if (x<0) return 0;\n        if (y<0) return 0;\n        if (dp[x][y] == Integer.MAX_VALUE) return 0;\n        return dp[x][y];\n    }\n}","runtime":"N/A","title":"Unique Paths II","url":"/submissions/detail/1088642393/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1088642393,"time":"2 months, 3 weeks","lang":"java","title_slug":"unique-paths-ii","timestamp":1698784106,"status":11,"is_pending":"Not Pending","compare_result":"11111110111011110101011110000000000111011"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int uniquePathsWithObstacles(int[][] grid) {\n        int n = grid.length;\n        int m = grid[0].length;\n        int [][] dp = new int[n][m];\n\n        \n        for (int i = 0; i<n;i++){\n            dp[i][0] = 1;\n        }\n        for (int i = 0; i<m;i++){\n            dp[0][i] = 1;\n        }\n        for (int i=0;i<n;i++){\n            for (int j = 0;j<m;j++){\n                if (grid[i][j] == 1) dp[i][j] = Integer.MAX_VALUE;\n            }\n        }\n        for (int i = 1; i<n;i++){\n            for (int j = 1;j<m;j++){\n                if (grid[i][j] == 0) {\n                    dp[i][j] = valid(i-1,j,n,m,dp) + valid(i,j-1,n,m,dp);\n                }\n            }\n        }\n\n        // for (int )\n        return dp[n-1][m-1];\n    }\n\n    public int valid(int x,int y,int n,int m, int [][]dp){\n        if (x>=n) return 0;\n        if (y>=m) return 0;\n        if (x<0) return 0;\n        if (y<0) return 0;\n        if (dp[x][y] == Integer.MAX_VALUE) return 0;\n        return dp[x][y];\n    }\n}","runtime":"N/A","title":"Unique Paths II","url":"/submissions/detail/1088642006/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1088642006,"time":"2 months, 3 weeks","lang":"java","title_slug":"unique-paths-ii","timestamp":1698784062,"status":11,"is_pending":"Not Pending","compare_result":"11010100010001110101011100000000000111011"},{"status_display":"Accepted","memory":"43.8 MB","code":"class Solution {\n    public int minPathSum(int[][] grid) {\n        int n = grid.length;\n        int m = grid[0].length;\n        int [][] dp = new int[n][m];\n        for (int i = 0;i<n;i++ )\n            Arrays.fill(dp[i],Integer.MAX_VALUE);\n        dp[0][0] = grid[0][0];\n        for (int i = 0; i<n;i++){\n            for (int j = 0;j<m;j++){\n                if (valid(i+1,j,n,m)){\n                    dp[i+1][j] = Integer.min(grid[i+1][j] + dp[i][j],dp[i+1][j]);\n                }\n                if (valid(i-1,j,n,m)){\n                    dp[i-1][j] = Integer.min(grid[i-1][j] + dp[i][j],dp[i-1][j]);\n                }\n                if (valid(i,j+1,n,m)){\n                    dp[i][j+1] = Integer.min(grid[i][j+1] + dp[i][j],dp[i][j+1]);\n                }\n                if (valid(i,j-1,n,m)){\n                    dp[i][j-1] = Integer.min(grid[i][j-1] + dp[i][j],dp[i][j-1]);\n                }\n            }\n        }\n\n        // for (int )\n        return dp[n-1][m-1];\n        \n    }\n    public boolean valid(int x,int y,int n,int m){\n        if (x>=n) return false;\n        if (y>=m) return false;\n        if (x<0) return false;\n        if (y<0) return false;\n        return true;\n    }\n}","runtime":"16 ms","title":"Minimum Path Sum","url":"/submissions/detail/1088621425/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1088621425,"time":"2 months, 3 weeks","lang":"java","title_slug":"minimum-path-sum","timestamp":1698781781,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"43.6 MB","code":"class Solution {\n    public int minimumTotal(List<List<Integer>> triangle) {\n\n        for (int i = 1;i<triangle.size();i++){\n            int m = triangle.get(i).size();\n            for (int j = 0; j< m;j++){\n                int l = j-1;\n                int r = j;\n                if (l<0) triangle.get(i).set(j,triangle.get(i).get(j) + triangle.get(i-1).get(r));\n                else if (r>=triangle.get(i-1).size() ) triangle.get(i).set(j,triangle.get(i).get(j) + triangle.get(i-1).get(l));\n                else triangle.get(i).set(j,Integer.min(triangle.get(i).get(j) + triangle.get(i-1).get(r), triangle.get(i).get(j) + triangle.get(i-1).get(l)));\n            }\n        }\n        int min = Integer.MAX_VALUE;\n        for (int i = 0;i<triangle.get(triangle.size()-1).size();i++){\n            if (min>triangle.get(triangle.size()-1).get(i)) min = triangle.get(triangle.size()-1).get(i);\n        }\n        return min;\n    }\n}","runtime":"10 ms","title":"Triangle","url":"/submissions/detail/1088575661/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1088575661,"time":"2 months, 3 weeks","lang":"java","title_slug":"triangle","timestamp":1698777427,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"43.9 MB","code":"class Solution {\n    public int minimumTotal(List<List<Integer>> triangle) {\n\n        for (int i = 1;i<triangle.size();i++){\n            int m = triangle.get(i).size();\n            for (int j = 0; j< m;j++){\n                int l = j-1;\n                int r = j;\n                if (l<0) triangle.get(i).set(j,triangle.get(i).get(j) + triangle.get(i-1).get(r));\n                else if (r>=triangle.get(i-1).size() ) triangle.get(i).set(j,triangle.get(i).get(j) + triangle.get(i-1).get(l));\n                else triangle.get(i).set(j,Integer.min(triangle.get(i).get(j) + triangle.get(i-1).get(r), triangle.get(i).get(j) + triangle.get(i-1).get(l)));\n            }\n        }\n        int min = Integer.MAX_VALUE;\n        for (int i = 0;i<triangle.get(triangle.size()-1).size();i++){\n            if (min>triangle.get(triangle.size()-1).get(i)) min = triangle.get(triangle.size()-1).get(i);\n        }\n        return min;\n    }\n}","runtime":"10 ms","title":"Triangle","url":"/submissions/detail/1088575551/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1088575551,"time":"2 months, 3 weeks","lang":"java","title_slug":"triangle","timestamp":1698777419,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"43.7 MB","code":"class Solution {\n    public int minimumTotal(List<List<Integer>> triangle) {\n        List<List<Integer>> dp = new ArrayList<>();\n        ArrayList<Integer> first = new ArrayList<>();\n        first.add(triangle.get(0).get(0));\n        dp.add(first);\n        for (int i = 1;i<triangle.size();i++){\n            int m = triangle.get(i).size();\n            ArrayList<Integer> temp = new ArrayList<>();\n            for (int j = 0; j< m;j++){\n                int l = j-1;\n                int r = j;\n                if (l<0) temp.add(triangle.get(i).get(j) + dp.get(i-1).get(r));\n                else if (r>=triangle.get(i-1).size() ) temp.add(triangle.get(i).get(j) + dp.get(i-1).get(l));\n                else temp.add(Integer.min(triangle.get(i).get(j) + dp.get(i-1).get(r), triangle.get(i).get(j) + dp.get(i-1).get(l)));\n            }\n            dp.add(temp);\n        }\n        int min = Integer.MAX_VALUE;\n        for (int i = 0;i<dp.get(dp.size()-1).size();i++){\n            if (min>dp.get(dp.size()-1).get(i)) min = dp.get(dp.size()-1).get(i);\n        }\n        return min;\n    }\n}","runtime":"9 ms","title":"Triangle","url":"/submissions/detail/1088573114/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1088573114,"time":"2 months, 3 weeks","lang":"java","title_slug":"triangle","timestamp":1698777213,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"56.8 MB","code":"class Solution {\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\n        HashMap<Integer,Integer> m = new HashMap<>();\n        for (int i = 0; i< nums.length;i++){\n            if (!m.containsKey(nums[i])){\n                m.put(nums[i],i);\n            } else{\n                if (i-m.get(nums[i])<= k) return true;\n                m.put(nums[i],i);\n            }\n        }\n        return false;\n    }\n}","runtime":"20 ms","title":"Contains Duplicate II","url":"/submissions/detail/1087892084/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1087892084,"time":"2 months, 4 weeks","lang":"java","title_slug":"contains-duplicate-ii","timestamp":1698702911,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"43.4 MB","code":"/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public boolean hasCycle(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        if (head == null) return false;\n        if (head.next == null ) return false;\n        if (head.next.next == null) return false;\n        while (slow!=null && fast!=null){\n            // if (slow.next == null) return false;\n            if (fast.next == null) return false;\n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast) return true;\n        }\n        return false;\n        \n    }\n}","runtime":"0 ms","title":"Linked List Cycle","url":"/submissions/detail/1087887961/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1087887961,"time":"2 months, 4 weeks","lang":"java","title_slug":"linked-list-cycle","timestamp":1698702360,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111"},{"status_display":"Runtime Error","memory":"N/A","code":"/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public boolean hasCycle(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        if (head == null) return false;\n        if (head.next == null ) return false;\n        if (head.next.next == null) return false;\n        while (slow!=null && fast!=null){\n            \n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast) return true;\n        }\n        return false;\n        \n    }\n}","runtime":"N/A","title":"Linked List Cycle","url":"/submissions/detail/1087887197/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1087887197,"time":"2 months, 4 weeks","lang":"java","title_slug":"linked-list-cycle","timestamp":1698702252,"status":15,"is_pending":"Not Pending","compare_result":"11111111111111000000000"}],"has_next":true,"last_key":"%7B%22pk%22%3A%20%7B%22N%22%3A%20%221087887197%22%7D%2C%20%22dt%22%3A%20%7B%22S%22%3A%20%222023-10-30T21%3A44%3A12.659887%2B0000%22%7D%2C%20%22sid%22%3A%20%7B%22N%22%3A%20%227573785%22%7D%7D"}
2024-01-26 23:38:04.150 [main] DEBUG submission_dump - {"submissions_dump":[{"status_display":"Accepted","memory":"42.9 MB","code":"/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public boolean hasCycle(ListNode head) {\n        HashSet<ListNode> set = new HashSet<>();\n        while (head!=null){\n            if (set.contains(head)) return true;\n            set.add(head);\n            head = head.next;\n        }\n        return false;\n        \n    }\n}","runtime":"4 ms","title":"Linked List Cycle","url":"/submissions/detail/1087885291/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1087885291,"time":"2 months, 4 weeks","lang":"java","title_slug":"linked-list-cycle","timestamp":1698701992,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111"},{"status_display":"Accepted","memory":"40.8 MB","code":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {\n        ListNode re = null;\n        if (list2 == null) return list1;\n        if (list1 == null) return list2;\n        if (list1.val >= list2.val){\n            re = list2;\n            list2 = list2.next;\n        }  else{\n            re = list1;\n            list1 = list1.next;\n        }\n        ListNode cur = re;\n        while (list1!=null && list2!=null){\n            if (list1.val>=list2.val){\n                cur.next = list2;\n                list2 = list2.next;\n            } else{\n                cur.next = list1;\n                list1 = list1.next;\n            }\n            cur = cur.next;\n        }\n        if (list1 == null) cur.next = list2;\n        if (list2 == null) cur.next = list1;\n        return re;\n        \n    }\n}","runtime":"0 ms","title":"Merge Two Sorted Lists","url":"/submissions/detail/1087883993/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1087883993,"time":"2 months, 4 weeks","lang":"java","title_slug":"merge-two-sorted-lists","timestamp":1698701815,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"41.5 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null ) return 0;\n        return Integer.max(maxDepth(root.left)+1,maxDepth(root.right)+1);\n    }\n}","runtime":"0 ms","title":"Maximum Depth of Binary Tree","url":"/submissions/detail/1087879511/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1087879511,"time":"2 months, 4 weeks","lang":"java","title_slug":"maximum-depth-of-binary-tree","timestamp":1698701217,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"39.9 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null) return false;\n        if ( p.val!=q.val ) return false;\n        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n        \n    }\n}","runtime":"0 ms","title":"Same Tree","url":"/submissions/detail/1087878932/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1087878932,"time":"2 months, 4 weeks","lang":"java","title_slug":"same-tree","timestamp":1698701138,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"39.6 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode invertTree(TreeNode root) {\n        iTree(root);\n        return root;\n    }\n    public void iTree(TreeNode root){\n        if (root == null) return;\n        TreeNode temp = root.left;\n        root.left = root.right;\n        root.right = temp;\n        iTree(root.left);\n        iTree(root.right);\n    }\n}","runtime":"0 ms","title":"Invert Binary Tree","url":"/submissions/detail/1087877829/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1087877829,"time":"2 months, 4 weeks","lang":"java","title_slug":"invert-binary-tree","timestamp":1698701002,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"40.1 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean isSymmetric(TreeNode root) {\n        return isS(root.left,root.right);\n    }\n\n    public boolean isS(TreeNode l, TreeNode r){\n        if (l == null && r == null) return true;\n        if (l==null) return false;\n        if (r == null) return false;\n        if (l.val != r.val) return false;\n        return isS(l.left,r.right) && isS(l.right,r.left);\n    }\n}","runtime":"0 ms","title":"Symmetric Tree","url":"/submissions/detail/1087874307/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1087874307,"time":"2 months, 4 weeks","lang":"java","title_slug":"symmetric-tree","timestamp":1698700548,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"45.8 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int countNodes(TreeNode root) {\n        return root==null?0:1 + countNodes(root.left) + countNodes(root.right);\n    }\n}","runtime":"0 ms","title":"Count Complete Tree Nodes","url":"/submissions/detail/1087869562/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1087869562,"time":"2 months, 4 weeks","lang":"java","title_slug":"count-complete-tree-nodes","timestamp":1698699925,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111"},{"status_display":"Accepted","memory":"45.4 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int countNodes(TreeNode root) {\n        if (root == null) return 0;\n        return 1 + countNodes(root.left) + countNodes(root.right);\n        \n    }\n}","runtime":"0 ms","title":"Count Complete Tree Nodes","url":"/submissions/detail/1087869174/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1087869174,"time":"2 months, 4 weeks","lang":"java","title_slug":"count-complete-tree-nodes","timestamp":1698699877,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111"},{"status_display":"Accepted","memory":"44.5 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<Double> averageOfLevels(TreeNode root) {\n        List<TreeNode> layer = new ArrayList<>();\n        layer.add(root);\n        List<Double> re = new ArrayList<>();\n        while (layer.size()!=0){\n            re.add(avgList(layer));\n            layer = getChildList(layer);\n        }\n        return re;\n    }\n\n    public double avgList(List<TreeNode> layer){\n        double re = 0;\n        int count = 0;\n        for (TreeNode i: layer){\n            if (i!=null){\n                re = re + i.val;\n                count++;\n            }\n        }\n        re = (double) re / (double) count;\n        return re;\n    }\n    public List<TreeNode> getChildList(List<TreeNode> layer){\n        List<TreeNode> re= new ArrayList<>();\n        for (TreeNode i: layer){\n            if (i.left != null) re.add(i.left);\n            if (i.right != null) re.add(i.right);\n        }\n        return re;\n    }\n}","runtime":"1 ms","title":"Average of Levels in Binary Tree","url":"/submissions/detail/1087867840/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1087867840,"time":"2 months, 4 weeks","lang":"java","title_slug":"average-of-levels-in-binary-tree","timestamp":1698699700,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"44.5 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<Double> averageOfLevels(TreeNode root) {\n        List<TreeNode> layer = new ArrayList<>();\n        layer.add(root);\n        List<Double> re = new ArrayList<>();\n        while (layer.size()!=0){\n            re.add(avgList(layer));\n            layer = getChildList(layer);\n        }\n        return re;\n    }\n\n    public double avgList(List<TreeNode> layer){\n        double re = 0;\n        int count = 0;\n        for (TreeNode i: layer){\n            if (i!=null){\n                re = re + i.val;\n                count++;\n            }\n        }\n        re = (double) re / (double) count;\n        return re;\n    }\n    public List<TreeNode> getChildList(List<TreeNode> layer){\n        List<TreeNode> re= new ArrayList<>();\n        for (TreeNode i: layer){\n            if (i.left != null) re.add(i.left);\n            if (i.right != null) re.add(i.right);\n        }\n        return re;\n    }\n}","runtime":"1 ms","title":"Average of Levels in Binary Tree","url":"/submissions/detail/1087867142/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1087867142,"time":"2 months, 4 weeks","lang":"java","title_slug":"average-of-levels-in-binary-tree","timestamp":1698699611,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"40.6 MB","code":"class Solution {\n    public boolean isValid(String s) {\n        Stack<Character> open = new Stack<>();\n        \n        for (char i:s.toCharArray()){\n            if (i=='(' || i == '[' || i == '{') open.add(i);\n            if ((i==')' || i == ']' || i == '}') && (open.size() == 0)) return false;\n            if (i == ')' && open.peek()!='(') return false;\n            if (i == ']' && open.peek()!='[') return false;\n            if (i == '}' && open.peek()!='{') return false;\n            if (i==')' || i == ']' || i == '}') open.pop();\n        }\n        if (open.size() == 0) return true;\n        return false;\n    }\n}","runtime":"2 ms","title":"Valid Parentheses","url":"/submissions/detail/1087766779/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1087766779,"time":"2 months, 4 weeks","lang":"java","title_slug":"valid-parentheses","timestamp":1698689692,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"40.5 MB","code":"class Solution {\n    public boolean isValid(String s) {\n        Stack<Character> open = new Stack<>();\n        Stack<Character> close = new Stack<>();\n        \n        for (char i:s.toCharArray()){\n            if (i=='(' || i == '[' || i == '{') open.add(i);\n            if ((i==')' || i == ']' || i == '}') && (open.size() == 0)) return false;\n            if (i == ')' && open.peek()!='(') return false;\n            if (i == ']' && open.peek()!='[') return false;\n            if (i == '}' && open.peek()!='{') return false;\n            if (i==')' || i == ']' || i == '}') open.pop();\n        }\n        if (open.size() == 0) return true;\n        return false;\n    }\n}","runtime":"2 ms","title":"Valid Parentheses","url":"/submissions/detail/1087766603/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1087766603,"time":"2 months, 4 weeks","lang":"java","title_slug":"valid-parentheses","timestamp":1698689680,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Runtime Error","memory":"N/A","code":"class Solution {\n    public boolean isValid(String s) {\n        Stack<Character> open = new Stack<>();\n        Stack<Character> close = new Stack<>();\n        \n        for (char i:s.toCharArray()){\n            if (i=='(' || i == '[' || i == '{') open.add(i);\n            if (i == ')' && open.peek()!='(') return false;\n            if (i == ']' && open.peek()!='[') return false;\n            if (i == '}' && open.peek()!='{') return false;\n            if (i==')' || i == ']' || i == '}') open.pop();\n        }\n        if (open.size() == 0) return true;\n        return false;\n    }\n}","runtime":"N/A","title":"Valid Parentheses","url":"/submissions/detail/1087765175/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1087765175,"time":"2 months, 4 weeks","lang":"java","title_slug":"valid-parentheses","timestamp":1698689579,"status":15,"is_pending":"Not Pending","compare_result":"11111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public long minIncrementOperations(int[] nums, int k) {\n        int ind = 0;\n        int n = nums.length;\n        long re = 0;\n        while (ind+2<n){\n            long max = nums[ind];\n            int pos = ind;\n            for (int i = 1; i<=2;i++){\n                if (max<=nums[ind+i]){\n                    max= nums[ind+i];\n                    pos = ind + i ;\n                }\n            }\n            System.out.println(max);\n            if (max<k){\n                re = re + k - nums[pos];\n                nums[pos] = k;\n            }\n            ind++;\n        }\n        return re;\n    }\n}","runtime":"N/A","title":"Minimum Increment Operations to Make Array Beautiful","url":"/submissions/detail/1086524199/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1086524199,"time":"3 months","lang":"java","title_slug":"minimum-increment-operations-to-make-array-beautiful","timestamp":1698550697,"status":11,"is_pending":"Not Pending","compare_result":"111111111111111111111111110111111100000101111111111111111111110101011001111111111101110111111101111010111101111111001101010001000011111101000100101000001100001000010100100100100011101100001001110000101101100010100110010010000110100001000000000010001000010000000101000000000000001101110100000000000000001000000100001000000000010010000001001010011011100010101010001000010011000000000000111000000010000101001000010001000011001011010011000000001001000100001000001000100000000000100000000000000000000010000000000000000000000000000000000000000000001000010000111001111111100000"},{"status_display":"Accepted","memory":"43.4 MB","code":"class Solution {\n    public int findKOr(int[] nums, int k) {\n        int pow2 = 1;\n        if (k == nums.length) {\n            int re = nums[0];\n            for (int i :nums) re = re & i;\n            return re;\n        }\n        if (k == 1){\n            int re = nums[0];\n            for (int i :nums) re = re | i;\n            return re;\n        }\n        \n        int re = 0;\n        int exit = 0;\n        int n = nums.length;\n        while (exit<n){\n            int count = 0;\n            exit = 0;\n            for (int i = 0; i<nums.length; i++){\n                // System.out.print(nums[i] +\" \");\n                if (nums[i] == 0 ) exit++;\n\n                if (nums[i] != 0 && nums[i] %2 == 1 ){\n                    count++;\n                }\n                nums[i] = nums[i] / 2;\n                // if (count >= k) break;\n            }\n            // System.out.println();\n            // System.out.println(count);\n            if (count >= k) re = re+ pow2;\n            pow2 = pow2 * 2;\n        }\n        \n        return re;\n        \n    }\n}","runtime":"3 ms","title":"Find the K-or of an Array","url":"/submissions/detail/1086516435/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1086516435,"time":"3 months","lang":"java","title_slug":"find-the-k-or-of-an-array","timestamp":1698550187,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int findKOr(int[] nums, int k) {\n        int pow2 = 1;\n        if (k == nums.length) {\n            int re = nums[0];\n            for (int i :nums) re = re & i;\n            return re;\n        }\n        if (k == 1){\n            int re = nums[0];\n            for (int i :nums) re = re | i;\n            return re;\n        }\n        \n        int re = 0;\n        int exit = 0;\n        int n = nums.length;\n        while (exit<n){\n            int count = 0;\n            for (int i = 0; i<nums.length; i++){\n                // System.out.print(nums[i] +\" \");\n                if (nums[i] == 0 ) exit++;\n\n                if (nums[i] != 0 && nums[i] %2 == 1 ){\n                    count++;\n                }\n                nums[i] = nums[i] / 2;\n                // if (count >= k) break;\n            }\n            // System.out.println();\n            // System.out.println(count);\n            if (count >= k) re = re+ pow2;\n            pow2 = pow2 * 2;\n        }\n        \n        return re;\n        \n    }\n}","runtime":"N/A","title":"Find the K-or of an Array","url":"/submissions/detail/1086515061/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1086515061,"time":"3 months","lang":"java","title_slug":"find-the-k-or-of-an-array","timestamp":1698550098,"status":11,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111101111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110111111110111101111111111111111111111111111111111111111101111111111111111111111111111111110111111111110111111111111111111111111111111111111111111111111111111111111111111111111110111111111111111111111111111111111111111111111111111111111111111011110111111111111111111011111111111111111111111111111110111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110111111111111111111111111111111111111111111111111111111111111111010111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int findKOr(int[] nums, int k) {\n        int pow2 = 1;\n        if (k == nums.length) {\n            int re = nums[0];\n            for (int i :nums) re = re & i;\n            return re;\n        }\n        if (k == 1){\n            int re = nums[0];\n            for (int i :nums) re = re | i;\n            return re;\n        }\n        \n        int re = 0;\n        int exit = 0;\n        int n = nums.length;\n        while (exit<n){\n            int count = 0;\n            for (int i = 0; i<nums.length; i++){\n                if (nums[i] == 0 ) exit++;\n\n                if (nums[i] != 0 && nums[i] %2 == 1 ){\n                    count++;\n                }\n                nums[i] = nums[i] / 2;\n                if (count >= k) break;\n            }\n            // System.out.println(count);\n            if (count >= k) re = re+ pow2;\n            pow2 = pow2 * 2;\n        }\n        \n        return re;\n        \n    }\n}","runtime":"N/A","title":"Find the K-or of an Array","url":"/submissions/detail/1086512878/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1086512878,"time":"3 months","lang":"java","title_slug":"find-the-k-or-of-an-array","timestamp":1698549962,"status":11,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111101111010010101111010111111111111111111011111010111111101100011110111111101110010111111111111101111111010011111011110100010111111111110011101011101000101110111111111111111110110111011111011111001111110001000111111010111111111111111110001111110101110111111100111001111111001111111010111110110101100100000101111111001111000111111011110110110111011110110101101111110110111110101111101101111001111111011111011111000001110011101110111111011110101111010101001111011111101111010101101110111111111010110111101011000010111011010000010010000000000110100100111000100110100001000010001110111000100001101010011001111010101001000011110100001000010000001001010000101000010010010011100101010001110000010101010010100011101000000001011001000011001101100111011010000001111010100101001110101101010101000000000010011000001110010101101101100100100010010111000001101000101101011001101110010010000100010100010100000010101100111101100110"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int findKOr(int[] nums, int k) {\n        int pow2 = 1;\n        if (k == nums.length) {\n            int re = nums[0];\n            for (int i :nums) re = re & i;\n            return re;\n        }\n        if (k == 1){\n            int re = nums[0];\n            for (int i :nums) re = re | i;\n            return re;\n        }\n        \n        int re = 0;\n        int exit = 0;\n        int n = nums.length;\n        while (exit<n){\n            int count = 0;\n            for (int i = 0; i<nums.length; i++){\n                if (nums[i] == 0 ) exit++;\n\n                if (nums[i] %2 == 1){\n                    count++;\n                }\n                nums[i] = nums[i] / 2;\n                if (count >= k) break;\n            }\n            System.out.println(count);\n            if (count >= k) re = re+ pow2;\n            pow2 = pow2 * 2;\n        }\n        \n        return re;\n        \n    }\n}","runtime":"N/A","title":"Find the K-or of an Array","url":"/submissions/detail/1086509421/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1086509421,"time":"3 months","lang":"java","title_slug":"find-the-k-or-of-an-array","timestamp":1698549750,"status":11,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111101111010010101111010111111111111111111011111010111111101100011110111111101110010111111111111101111111010011111011110100010111111111110011101011101000101110111111111111111110110111011111011111001111110001000111111010111111111111111110001111110101110111111100111001111111001111111010111110110101100100000101111111001111000111111011110110110111011110110101101111110110111110101111101101111001111111011111011111000001110011101110111111011110101111010101001111011111101111010101101110111111111010110111101011000010111011010000010010000000000110100100111000100110100001000010001110111000100001101010011001111010101001000011110100001000010000001001010000101000010010010011100101010001110000010101010010100011101000000001011001000011001101100111011010000001111010100101001110101101010101000000000010011000001110010101101101100100100010010111000001101000101101011001101110010010000100010100010100000010101100111101100110"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int findKOr(int[] nums, int k) {\n        int pow2 = 1;\n        if (k == nums.length) {\n            int re = nums[0];\n            for (int i :nums) re = re & i;\n            return re;\n        }\n        if (k == 1){\n            int re = nums[0];\n            for (int i :nums) re = re | i;\n            return re;\n        }\n        \n        int re = 0;\n        int exit = 0;\n        int n = nums.length;\n        while (exit<n){\n            int count = 0;\n            for (int i = 0; i<nums.length; i++){\n                if (nums[i] %2 == 1){\n                    count++;\n                }\n                nums[i] = nums[i] /2;\n                if (nums[i] == 0 ) exit++;\n                if (count >= k) break;\n            } \n            if (count >= k) re = re+ pow2;\n            pow2 = pow2 * 2;\n        }\n        \n        return re;\n        \n    }\n}","runtime":"N/A","title":"Find the K-or of an Array","url":"/submissions/detail/1086505200/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1086505200,"time":"3 months","lang":"java","title_slug":"find-the-k-or-of-an-array","timestamp":1698549503,"status":11,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111010010111111010111111111111111111011111010111111101100011110111111101110010111111111111101111111010001111011110100010111111111110011101011101001101100111111111111111111110111011111011111001111110101000111111110111111111111111110001111110101110111111100101001111111011111111010111110110101100100000101011111101111010111111011111110110111011110110101101111110110111110101111101101111001111111011111111111010001110011101110111111011110101111010101011111011111101111010111101110111011111010110111101011000010111011010000010010000000000110100100111000100110100001000010001110111000100001111010011001111010101001000011110100001000010000001001010000101000010010010011100101010001110000011101010010100011101000000001011001000011001101100111011010000001111010100101001110101101010101000000000010011000001110010101101101100100100010010111000001101000101101011001101110010010000100010100010100000010101100111101100110"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public long minIncrementOperations(int[] nums, int k) {\n        int ind = 0;\n        int n = nums.length;\n        long re = 0;\n        while (ind+2<n){\n            long max = nums[ind];\n            int pos = ind;\n            for (int i = 1; i<=2;i++){\n                if (max<=nums[ind+i]){\n                    max= nums[ind+i];\n                    pos = ind + i ;\n                }\n            }\n            // System.out.println(max);\n            if (max<k){\n                re = re + k - nums[pos];\n                nums[pos] = k;\n            }\n            ind++;\n        }\n        return re;\n    }\n}","runtime":"N/A","title":"Minimum Increment Operations to Make Array Beautiful","url":"/submissions/detail/1086492941/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1086492941,"time":"3 months","lang":"java","title_slug":"minimum-increment-operations-to-make-array-beautiful","timestamp":1698548803,"status":11,"is_pending":"Not Pending","compare_result":"111111111111111111111111110111111100000101111111111111111111110101011001111111111101110111111101111010111101111111001101010001000011111101000100101000001100001000010100100100100011101100001001110000101101100010100110010010000110100001000000000010001000010000000101000000000000001101110100000000000000001000000100001000000000010010000001001010011011100010101010001000010011000000000000111000000010000101001000010001000011001011010011000000001001000100001000001000100000000000100000000000000000000010000000000000000000000000000000000000000000001000010000111001111111100000"}],"has_next":true,"last_key":"%7B%22pk%22%3A%20%7B%22N%22%3A%20%221086492941%22%7D%2C%20%22dt%22%3A%20%7B%22S%22%3A%20%222023-10-29T03%3A06%3A43.174541%2B0000%22%7D%2C%20%22sid%22%3A%20%7B%22N%22%3A%20%227573785%22%7D%7D"}
2024-01-26 23:38:14.653 [main] DEBUG submission_dump - {"submissions_dump":[{"status_display":"Accepted","memory":"59.1 MB","code":"class Solution {\n    public long minSum(int[] nums1, int[] nums2) {\n        long count1 = 0;\n        long count2 = 0;\n        long sum1 = 0;\n        long sum2 = 0;\n        for (int i: nums1){\n            sum1 = sum1+i;\n            if (i == 0 ) count1++;\n        }\n        for (int i: nums2){\n            sum2 = sum2+i;\n            if (i == 0 ) count2++;\n        }\n        if (count1 == 0 && count2 == 0 ){\n            if (sum1 == sum2) return sum1;\n            else return -1;\n        }\n        // System.out.println(sum1 + \" \"+ sum2 + \" \"+ count1+ \" \"+ count2);\n        if (sum1 > sum2 && count2 == 0 ) return -1;\n        if (sum1 < sum2 && count1 == 0 ) return -1;\n        if (sum1 + count1 > sum2 && count2 == 0 ) return -1;\n        if (sum1 < sum2 + count2 && count1 == 0 ) return -1;\n        return Long.max(sum1+count1,sum2+count2);\n        \n    }\n}","runtime":"3 ms","title":"Minimum Equal Sum of Two Arrays After Replacing Zeros","url":"/submissions/detail/1086478614/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1086478614,"time":"3 months","lang":"java","title_slug":"minimum-equal-sum-of-two-arrays-after-replacing-zeros","timestamp":1698548034,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public long minSum(int[] nums1, int[] nums2) {\n        int count1 = 0;\n        int count2 = 0;\n        int sum1 = 0;\n        int sum2 = 0;\n        for (int i: nums1){\n            sum1 = sum1+i;\n            if (i == 0 ) count1++;\n        }\n        for (int i: nums2){\n            sum2 = sum2+i;\n            if (i == 0 ) count2++;\n        }\n        if (count1 == 0 && count2 == 0 ){\n            if (sum1 == sum2) return sum1;\n            else return -1;\n        }\n        if (sum1 > sum2 && count2 == 0 ) return -1;\n        if (sum1 < sum2 && count1 == 0 ) return -1;\n        if (sum1 + count1 >= sum2 && count2 == 0 ) return -1;\n        if (sum1 <= sum2 + count2 && count1 == 0 ) return -1;\n        return Integer.max(sum1+count1,sum2+count2);\n        \n    }\n}","runtime":"N/A","title":"Minimum Equal Sum of Two Arrays After Replacing Zeros","url":"/submissions/detail/1086476316/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1086476316,"time":"3 months","lang":"java","title_slug":"minimum-equal-sum-of-two-arrays-after-replacing-zeros","timestamp":1698547909,"status":11,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public long minSum(int[] nums1, int[] nums2) {\n        int count1 = 0;\n        int count2 = 0;\n        int sum1 = 0;\n        int sum2 = 0;\n        for (int i: nums1){\n            sum1 = sum1+i;\n            if (i == 0 ) count1++;\n        }\n        for (int i: nums2){\n            sum2 = sum2+i;\n            if (i == 0 ) count2++;\n        }\n        if (count1 == 0 && count2 == 0 ){\n            if (sum1 == sum2) return sum1;\n            else return -1;\n        }\n        if (sum1 > sum2 && count2 == 0 ) return -1;\n        if (sum1 < sum2 && count1 == 0 ) return -1;\n        if (sum1 + count1 > sum2 && count2 == 0 ) return -1;\n        if (sum1 < sum2 + count2 && count1 == 0 ) return -1;\n        return Integer.max(sum1+count1,sum2+count2);\n        \n    }\n}","runtime":"N/A","title":"Minimum Equal Sum of Two Arrays After Replacing Zeros","url":"/submissions/detail/1086475884/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1086475884,"time":"3 months","lang":"java","title_slug":"minimum-equal-sum-of-two-arrays-after-replacing-zeros","timestamp":1698547884,"status":11,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public long minSum(int[] nums1, int[] nums2) {\n        int count1 = 0;\n        int count2 = 0;\n        int sum1 = 0;\n        int sum2 = 0;\n        for (int i: nums1){\n            sum1 = sum1+i;\n            if (i == 0 ) count1++;\n        }\n        for (int i: nums2){\n            sum2 = sum2+i;\n            if (i == 0 ) count2++;\n        }\n        if (count1 == 0 && count2 == 0 ){\n            if (sum1 == sum2) return sum1;\n            else return -1;\n        }\n        if (sum1 + count1 > sum2 && count2 == 0 ) return -1;\n        if (sum1 < sum2 + count2 && count1 == 0 ) return -1;\n        return Integer.max(sum1+count1,sum2+count2);\n        \n    }\n}","runtime":"N/A","title":"Minimum Equal Sum of Two Arrays After Replacing Zeros","url":"/submissions/detail/1086475421/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1086475421,"time":"3 months","lang":"java","title_slug":"minimum-equal-sum-of-two-arrays-after-replacing-zeros","timestamp":1698547860,"status":11,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000"},{"status_display":"Time Limit Exceeded","memory":"N/A","code":"class Solution {\n    public int findKOr(int[] nums, int k) {\n        int pow2 = 1;\n        if (k == nums.length) {\n            int re = nums[0];\n            for (int i :nums) re = re & i;\n            return re;\n        }\n        if (k == 1){\n            int re = nums[0];\n            for (int i :nums) re = re | i;\n            return re;\n        }\n        \n        int max = 0;\n        int re = 0;\n        for (int i : nums){\n            if (i>max) max = i;\n        }\n        while (pow2 < max){\n            int count = 0;\n            for (int i = 0; i<nums.length; i++){\n                if ( (pow2 & nums[i]) == pow2 ) count++;\n            } \n            if (count >= k) re = re+ pow2;\n            pow2 = pow2 * 2;\n        }\n        \n        return re;\n        \n    }\n}","runtime":"N/A","title":"Find the K-or of an Array","url":"/submissions/detail/1086466386/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1086466386,"time":"3 months","lang":"java","title_slug":"find-the-k-or-of-an-array","timestamp":1698547338,"status":14,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"},{"status_display":"Accepted","memory":"44.5 MB","code":"class Solution {\n    public int minChanges(String s) {\n        char [] ac = s.toCharArray();\n        int n = s.length();\n        int st = 0;\n        int count = 0;\n        while (st<n){\n            if (ac[st]!=ac[st+1]) count ++;\n            st+=2;\n        }\n        return count;\n        \n    }\n}","runtime":"3 ms","title":"Minimum Number of Changes to Make Binary String Beautiful","url":"/submissions/detail/1086107640/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1086107640,"time":"3 months","lang":"java","title_slug":"minimum-number-of-changes-to-make-binary-string-beautiful","timestamp":1698505320,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"44.1 MB","code":"class Solution {\n    public int sumCounts(List<Integer> nums) {\n        int n = nums.size();\n        List<Integer> dist = new ArrayList<>();\n        int sum = 0;\n        for (int i = 0 ; i<n;i++){\n\n            for (int j = 0;j<n;j++) {\n                HashSet<Integer> set = new HashSet<>();\n                if (i+j<n){\n                    for (int k =0;k<=i && j+k<n;k++){\n                    set.add(nums.get(j+k));\n                    }    \n                }\n                \n                // System.out.println(j +\" \"+i + \" \" + set.size());\n                sum = sum + set.size()*set.size();\n\n            }\n        }\n        return sum;\n        \n    }\n}","runtime":"105 ms","title":"Subarrays Distinct Element Sum of Squares I","url":"/submissions/detail/1086098064/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1086098064,"time":"3 months","lang":"java","title_slug":"subarrays-distinct-element-sum-of-squares-i","timestamp":1698504898,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"40.3 MB","code":"class Solution {\n    public boolean isHappy(int n) {\n        HashSet<Integer> set = new HashSet<>();\n        int temp = n;\n        set.add(temp);\n        if (n == 1) return true;\n        while (temp != 1){\n            // System.out.println(temp);\n            int h = happy(temp);\n            if (h == 1) return true;\n            if (set.contains(h)) return false;\n            set.add(h);\n            temp = h;\n        }\n        return true;\n\n        \n    }\n\n    public int happy(int n){\n        int temp = n;\n        int sum = 0;\n        while (temp>0){\n            int d = temp % 10;\n            sum = sum + d*d;\n            temp =temp / 10;\n        }\n        return sum;\n    }\n}","runtime":"1 ms","title":"Happy Number","url":"/submissions/detail/1085731173/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1085731173,"time":"3 months","lang":"java","title_slug":"happy-number","timestamp":1698456367,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"41.7 MB","code":"class Solution {\n    public String fractionToDecimal(long numerator, long denominator) {\n        String re = \"\";\n\n        if (numerator * denominator < 0) {\n            re = \"-\";\n            \n        }\n        numerator = Math.abs(numerator);\n        denominator = Math.abs(denominator);\n        long dec = numerator / denominator;\n        re = re+dec;\n\n        long remainder = numerator % denominator;\n        if (remainder < 0) remainder = -remainder;\n        List<Long> remains = new ArrayList<>();\n        List<Long> left = new ArrayList<>();\n        HashSet<Long> set = new HashSet<>();\n        set.add(remainder);\n        while (remainder != 0 || !set.contains(remainder)){\n            remains.add(remainder);\n            remainder = remainder * 10;\n            left.add(remainder/denominator);\n            remainder = remainder % denominator;\n            if (set.contains(remainder)) break;\n            set.add(remainder);\n        }\n        // System.out.println(remainder);\n        // for (int i  = 0;i<left.size();i++){\n        //     System.out.println(remains.get(i) + \" \" + left.get(i));\n        // }\n        if (remainder != 0){\n            if (remains.size()>0){\n                re = re+ \".\";\n                for (int i=0;i<remains.size();i++){\n                    if (remains.get(i).equals( remainder ) ){\n                        re = re+ \"(\" + left.get(i); \n                    }else{\n                        re = re+ left.get(i);\n                    }\n                }\n                re= re+\")\";\n            }\n        } else{\n            if (remains.size()>0) {\n                re = re+ \".\";\n                for (int i = 0;i<left.size();i++){\n                    re = re + left.get(i);\n                }\n            }\n        }\n        \n        return re;\n    }\n}","runtime":"13 ms","title":"Fraction to Recurring Decimal","url":"/submissions/detail/1085557251/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1085557251,"time":"3 months","lang":"java","title_slug":"fraction-to-recurring-decimal","timestamp":1698430554,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public String fractionToDecimal(int numerator, int denominator) {\n        String re = \"\";\n\n        if (numerator * denominator < 0) {\n            re = \"-\";\n            numerator = Math.abs(numerator);\n            denominator = Math.abs(denominator);\n        }\n        int dec = numerator / denominator;\n        re = re+dec;\n\n        int remainder = numerator % denominator;\n        if (remainder < 0) remainder = -remainder;\n        List<Integer> remains = new ArrayList<>();\n        List<Integer> left = new ArrayList<>();\n        HashSet<Integer> set = new HashSet<>();\n        set.add(remainder);\n        while (remainder != 0 || !set.contains(remainder)){\n            remains.add(remainder);\n            remainder = remainder * 10;\n            left.add(remainder/denominator);\n            remainder = remainder % denominator;\n            if (set.contains(remainder)) break;\n            set.add(remainder);\n        }\n        // System.out.println(remainder);\n        // for (int i  = 0;i<left.size();i++){\n        //     System.out.println(remains.get(i) + \" \" + left.get(i));\n        // }\n        if (remainder != 0){\n            if (remains.size()>0){\n                re = re+ \".\";\n                for (int i=0;i<remains.size();i++){\n                    if (remains.get(i).equals( remainder ) ){\n                        re = re+ \"(\" + left.get(i); \n                    }else{\n                        re = re+ left.get(i);\n                    }\n                }\n                re= re+\")\";\n            }\n        } else{\n            if (remains.size()>0) {\n                re = re+ \".\";\n                for (int i = 0;i<left.size();i++){\n                    re = re + left.get(i);\n                }\n            }\n        }\n        \n        return re;\n    }\n}","runtime":"N/A","title":"Fraction to Recurring Decimal","url":"/submissions/detail/1085555881/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1085555881,"time":"3 months","lang":"java","title_slug":"fraction-to-recurring-decimal","timestamp":1698430434,"status":11,"is_pending":"Not Pending","compare_result":"111111111111111111111111111110101000001"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public String fractionToDecimal(int numerator, int denominator) {\n        \n        int dec = numerator / denominator;\n        String re = \"\";\n        re = \"\"+dec;\n\n        int remainder = numerator % denominator;\n        if (remainder < 0) remainder = -remainder;\n        List<Integer> remains = new ArrayList<>();\n        List<Integer> left = new ArrayList<>();\n        HashSet<Integer> set = new HashSet<>();\n        set.add(remainder);\n        while (remainder != 0 || !set.contains(remainder)){\n            remains.add(remainder);\n            remainder = remainder * 10;\n            left.add(remainder/denominator);\n            remainder = remainder % denominator;\n            if (set.contains(remainder)) break;\n            set.add(remainder);\n        }\n        // System.out.println(remainder);\n        // for (int i  = 0;i<left.size();i++){\n        //     System.out.println(remains.get(i) + \" \" + left.get(i));\n        // }\n        if (remainder != 0){\n            if (remains.size()>0){\n                re = re+ \".\";\n                for (int i=0;i<remains.size();i++){\n                    if (remains.get(i).equals( remainder ) ){\n                        re = re+ \"(\" + left.get(i); \n                    }else{\n                        re = re+ left.get(i);\n                    }\n                }\n                re= re+\")\";\n            }\n        } else{\n            if (remains.size()>0) {\n                re = re+ \".\";\n                for (int i = 0;i<left.size();i++){\n                    re = re + left.get(i);\n                }\n            }\n        }\n        \n        return re;\n    }\n}","runtime":"N/A","title":"Fraction to Recurring Decimal","url":"/submissions/detail/1085553836/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1085553836,"time":"3 months","lang":"java","title_slug":"fraction-to-recurring-decimal","timestamp":1698430260,"status":11,"is_pending":"Not Pending","compare_result":"111111111111111111111111110110111100001"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public String fractionToDecimal(int numerator, int denominator) {\n        int dec = numerator / denominator;\n        int remainder = numerator % denominator;\n        List<Integer> remains = new ArrayList<>();\n        List<Integer> left = new ArrayList<>();\n        HashSet<Integer> set = new HashSet<>();\n        set.add(remainder);\n        while (remainder != 0 || !set.contains(remainder)){\n            remains.add(remainder);\n            remainder = remainder * 10;\n            left.add(remainder/denominator);\n            remainder = remainder % denominator;\n            if (set.contains(remainder)) break;\n            set.add(remainder);\n        }\n        System.out.println(remainder);\n        for (int i  = 0;i<left.size();i++){\n            System.out.println(remains.get(i) + \" \" + left.get(i));\n        }\n        String re = \"\"+dec;\n        if (remainder != 0){\n            if (remains.size()>0){\n                re = re+ \".\";\n                for (int i=0;i<remains.size();i++){\n                    if (remains.get(i).equals( remainder ) ){\n                        re = re+ \"(\" + left.get(i); \n                    }else{\n                        re = re+ left.get(i);\n                    }\n                }\n                re= re+\")\";\n            }\n        } else{\n            if (remains.size()>0) {\n                re = re+ \".\";\n                for (int i = 0;i<left.size();i++){\n                    re = re + left.get(i);\n                }\n            }\n        }\n        \n        return re;\n    }\n}","runtime":"N/A","title":"Fraction to Recurring Decimal","url":"/submissions/detail/1085552188/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1085552188,"time":"3 months","lang":"java","title_slug":"fraction-to-recurring-decimal","timestamp":1698430116,"status":11,"is_pending":"Not Pending","compare_result":"111111111111111111111111010110111101101"},{"status_display":"Accepted","memory":"44.5 MB","code":"class Solution {\n    public int[][] intervalIntersection(int[][] firstList, int[][] secondList) {\n        int n = firstList.length;\n        int m = secondList.length;\n        List<Integer> a = new ArrayList<>();\n        List<Integer> b = new ArrayList<>();\n        int c1 = 0;\n        int c2 = 0;\n        while (c1<n && c2<m){\n            if ( firstList[c1][0] <= secondList[c2][0] && secondList[c2][1] <= firstList[c1][1]) {\n                a.add(secondList[c2][0]);\n                b.add(secondList[c2][1]);\n                // c2++;\n            } else if ( secondList[c2][0] <= firstList[c1][0] && firstList[c1][1] <= secondList[c2][1] ){\n                a.add(firstList[c1][0]);\n                b.add(firstList[c1][1]);\n                // c1++;\n            } else if ( firstList[c1][0] <= secondList[c2][0] && secondList[c2][0] <= firstList[c1][1]) {\n                a.add(secondList[c2][0]);\n                b.add(firstList[c1][1]);\n                // c2++;\n            } else if ( secondList[c2][0] <= firstList[c1][0] && firstList[c1][0] <= secondList[c2][1] ){\n                a.add(firstList[c1][0]);\n                b.add(secondList[c2][1]);\n                // c1++;\n            }\n            \n            if (firstList[c1][1]<secondList[c2][1]){\n                c1++;\n            }\n            else{\n                c2++;\n            }\n                \n        }\n        int [][] re = new int[a.size()][2];\n        for (int i = 0;i<a.size();i++){\n            re[i][0] = a.get(i);\n            re[i][1] = b.get(i);\n        }\n        return re;\n        \n    }\n}","runtime":"6 ms","title":"Interval List Intersections","url":"/submissions/detail/1085524237/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1085524237,"time":"3 months","lang":"java","title_slug":"interval-list-intersections","timestamp":1698427769,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"44.9 MB","code":"class Solution {\n    public void setZeroes(int[][] matrix) {\n        int n = matrix.length;\n        int m = matrix[0].length;\n        boolean top = false;\n        boolean left = false;\n        for (int i = 0;i<n;i++){\n            for (int j = 0 ;j<m;j++){\n                if (matrix[i][j] == 0){\n                    if (i == 0) top = true;\n                    if (j == 0) left = true;\n                    matrix[i][0] = 0;\n                    matrix[0][j] = 0;\n                }\n            }\n        }\n        for (int i = 1;i<n;i++){\n            if (matrix[i][0] == 0)\n                for (int j = 0;j<m;j++) {\n                    matrix[i][j] = 0;\n                }\n        }\n        for (int i = 1;i<m;i++){\n            if (matrix[0][i] == 0)\n                for (int j = 0;j<n;j++) {\n                    matrix[j][i] = 0;\n                }\n        }\n        if (top){\n            // System.out.println(\"t\" + \" \"+m);\n            for (int i = 0;i<m;i++) matrix[0][i] = 0;\n        }\n        if (left){\n            // System.out.println(\"l\" );\n            for (int i = 0; i<n;i++) matrix[i][0] = 0;\n        }\n    }\n}","runtime":"1 ms","title":"Set Matrix Zeroes","url":"/submissions/detail/1085000221/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1085000221,"time":"3 months","lang":"java","title_slug":"set-matrix-zeroes","timestamp":1698368279,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public void setZeroes(int[][] matrix) {\n        int n = matrix.length;\n        int m = matrix[0].length;\n        boolean top = false;\n        boolean left = false;\n        for (int i = 0;i<n;i++){\n            for (int j = 0 ;j<m;j++){\n                if (matrix[i][j] == 0){\n                    if (i == 0) left = true;\n                    if (j == 0) top = true;\n                    matrix[i][0] = 0;\n                    matrix[0][j] = 0;\n                }\n            }\n        }\n        for (int i = 1;i<n;i++){\n            if (matrix[i][0] == 0)\n                for (int j = 0;j<m;j++) {\n                    matrix[i][j] = 0;\n                }\n        }\n        for (int i = 1;i<m;i++){\n            if (matrix[0][i] == 0)\n                for (int j = 0;j<n;j++) {\n                    matrix[j][i] = 0;\n                }\n        }\n        if (top){\n            for (int i = 0;i<m;i++) matrix[0][i] = 0;\n        }\n        if (left){\n            for (int i = 0; i<n;i++) matrix[i][0] = 0;\n        }\n    }\n}","runtime":"N/A","title":"Set Matrix Zeroes","url":"/submissions/detail/1084998746/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1084998746,"time":"3 months","lang":"java","title_slug":"set-matrix-zeroes","timestamp":1698368039,"status":11,"is_pending":"Not Pending","compare_result":"1111111100001111111010100111110000001000010011100000100011010010100111001000110101011111001010010110101101001010011000111001011101111111111111011111111010100100100111111101111"},{"status_display":"Accepted","memory":"38.9 MB","code":"class Solution {\n    public int fib(int n) {\n        if (n ==0 ) return 0;\n        if (n == 1) return 1;\n        if (n == 2) return 1;\n        int count = 2;\n        int a = 1;\n        int b = 1;\n        int c = 0;\n        while (count <n){\n            c = a+ b;\n            a= b;\n            b =c; \n            count ++;\n        }\n        return c;\n    }\n}","runtime":"0 ms","title":"Fibonacci Number","url":"/submissions/detail/1084979166/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1084979166,"time":"3 months","lang":"java","title_slug":"fibonacci-number","timestamp":1698364829,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111"},{"status_display":"Accepted","memory":"58.4 MB","code":"class Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n\t\tDeque<Integer> dNum = new ArrayDeque<Integer>();\n\t\tDeque<Integer> dInd = new ArrayDeque<Integer>();\n\t\tint n = nums.length;\n\t\tdNum.addLast(nums[0]);\n\t\tdInd.addLast(0);\n\t\tList<Integer> reL = new ArrayList<>();\n\n\t\tint count = 1;\n\t\tif (count >= k)\n\t\t\t\treL.add(dNum.getFirst());\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tint lowBound = i - (k - 1);\n\t\t\twhile (!dInd.isEmpty() && dInd.peekFirst() < lowBound) {\n\t\t\t\tdInd.removeFirst();\n\t\t\t\tdNum.removeFirst();\n\t\t\t}\n\t\t\tif (dNum.isEmpty()){\n\t\t\t\tdNum.addLast(nums[i]);\n\t\t\t\tdInd.addLast(i);\n\t\t\t}\n\t\t\telse {\n\t\t\t\twhile (!dNum.isEmpty() && dNum.getLast()<=nums[i]) {\n\t\t\t\t\tdNum.removeLast();\n\t\t\t\t\tdInd.removeLast();\n\t\t\t}\n\t\t\tdNum.addLast(nums[i]);\n\t\t\tdInd.addLast(i);\n\t\t\t}\n\t\t\t\n\t\t\tcount++;\n\t\t\tif (count >= k)\n\t\t\t\treL.add(dNum.getFirst());\n\t\t}\n\t\tint[] re = new int[reL.size()];\n\t\tfor (int i = 0; i < reL.size(); i++) {\n\t\t\tre[i] = reL.get(i);\n\t\t}\n\t\treturn re;\n\t}\n}","runtime":"48 ms","title":"Sliding Window Maximum","url":"/submissions/detail/1084946940/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1084946940,"time":"3 months","lang":"java","title_slug":"sliding-window-maximum","timestamp":1698359502,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n\t\tDeque<Integer> dNum = new ArrayDeque<Integer>();\n\t\tDeque<Integer> dInd = new ArrayDeque<Integer>();\n\t\tint n = nums.length;\n\t\tdNum.addLast(nums[0]);\n\t\tdInd.addLast(0);\n\t\tList<Integer> reL = new ArrayList<>();\n\n\t\tint count = 1;\n\t\tif (count >= k)\n\t\t\t\treL.add(dNum.getFirst());\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tint lowBound = i - (k - 1);\n\t\t\twhile (!dInd.isEmpty() && dInd.peekFirst() < lowBound) {\n\t\t\t\tdInd.removeFirst();\n\t\t\t\tdNum.removeFirst();\n\t\t\t}\n\t\t\tif (dNum.isEmpty()){\n\t\t\t\tdNum.addFirst(nums[i]);\n\t\t\t\tdInd.addFirst(i);\n\t\t\t} else if (nums[i] >= dNum.getFirst()) {\n\t\t\t\tdNum.addFirst(nums[i]);\n\t\t\t\tdInd.addFirst(i);\n\t\t\t} else {\n\t\t\t\tdNum.addLast(nums[i]);\n\t\t\t\tdInd.addLast(i);\n\t\t\t}\n\t\t\tcount++;\n\t\t\tif (count >= k)\n\t\t\t\treL.add(dNum.getFirst());\n\t\t}\n\t\tint[] re = new int[reL.size()];\n\t\tfor (int i = 0; i < reL.size(); i++) {\n\t\t\tre[i] = reL.get(i);\n\t\t}\n\t\treturn re;\n\t}\n}","runtime":"N/A","title":"Sliding Window Maximum","url":"/submissions/detail/1084922241/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1084922241,"time":"3 months","lang":"java","title_slug":"sliding-window-maximum","timestamp":1698355946,"status":11,"is_pending":"Not Pending","compare_result":"111111111101000010011000001101100010010101000111111"},{"status_display":"Runtime Error","memory":"N/A","code":"class Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n\t\tDeque<Integer> dNum = new ArrayDeque<Integer>();\n\t\tDeque<Integer> dInd = new ArrayDeque<Integer>();\n\t\tint n = nums.length;\n\t\tdNum.addLast(nums[0]);\n\t\tdInd.addLast(0);\n\t\tList<Integer> reL = new ArrayList<>();\n\n\t\tint count = 1;\n\t\tif (count >= k)\n\t\t\t\treL.add(dNum.getFirst());\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tint lowBound = i - (k - 1);\n\t\t\twhile (!dInd.isEmpty() && dInd.peekFirst() < lowBound) {\n\t\t\t\tdInd.removeFirst();\n\t\t\t\tdNum.removeFirst();\n\t\t\t}\n\t\t\tif (nums[i] >= dNum.getFirst()) {\n\t\t\t\tdNum.addFirst(nums[i]);\n\t\t\t\tdInd.addFirst(i);\n\t\t\t} else {\n\t\t\t\tdNum.addLast(nums[i]);\n\t\t\t\tdInd.addLast(i);\n\t\t\t}\n\t\t\tcount++;\n\t\t\tif (count >= k)\n\t\t\t\treL.add(dNum.getFirst());\n\t\t}\n\t\tint[] re = new int[reL.size()];\n\t\tfor (int i = 0; i < reL.size(); i++) {\n\t\t\tre[i] = reL.get(i);\n\t\t}\n\t\treturn re;\n\t}\n}","runtime":"N/A","title":"Sliding Window Maximum","url":"/submissions/detail/1084921574/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1084921574,"time":"3 months","lang":"java","title_slug":"sliding-window-maximum","timestamp":1698355852,"status":15,"is_pending":"Not Pending","compare_result":"110000000000000000000000000000000000000000000000000"},{"status_display":"Runtime Error","memory":"N/A","code":"class Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n\t\tDeque<Integer> dNum = new ArrayDeque<Integer>();\n\t\tDeque<Integer> dInd = new ArrayDeque<Integer>();\n\t\tint n = nums.length;\n\t\tdNum.addLast(nums[0]);\n\t\tdInd.addLast(0);\n\t\tList<Integer> reL = new ArrayList<>();\n\n\t\tint count = 1;\n\t\tif (count >= k)\n\t\t\t\treL.add(dNum.getFirst());\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tint lowBound = i - (k - 1);\n\t\t\twhile (dInd.peekFirst() < lowBound) {\n\t\t\t\tdInd.removeFirst();\n\t\t\t\tdNum.removeFirst();\n\t\t\t}\n\t\t\tif (nums[i] >= dNum.getFirst()) {\n\t\t\t\tdNum.addFirst(nums[i]);\n\t\t\t\tdInd.addFirst(i);\n\t\t\t} else {\n\t\t\t\tdNum.addLast(nums[i]);\n\t\t\t\tdInd.addLast(i);\n\t\t\t}\n\t\t\tcount++;\n\t\t\tif (count >= k)\n\t\t\t\treL.add(dNum.getFirst());\n\t\t}\n\t\tint[] re = new int[reL.size()];\n\t\tfor (int i = 0; i < reL.size(); i++) {\n\t\t\tre[i] = reL.get(i);\n\t\t}\n\t\treturn re;\n\t}\n}","runtime":"N/A","title":"Sliding Window Maximum","url":"/submissions/detail/1084921213/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1084921213,"time":"3 months","lang":"java","title_slug":"sliding-window-maximum","timestamp":1698355804,"status":15,"is_pending":"Not Pending","compare_result":"110000000000000000000000000000000000000000000000000"}],"has_next":true,"last_key":"%7B%22pk%22%3A%20%7B%22N%22%3A%20%221084921213%22%7D%2C%20%22dt%22%3A%20%7B%22S%22%3A%20%222023-10-26T21%3A30%3A04.267464%2B0000%22%7D%2C%20%22sid%22%3A%20%7B%22N%22%3A%20%227573785%22%7D%7D"}
2024-01-26 23:38:25.465 [main] DEBUG submission_dump - {"submissions_dump":[{"status_display":"Accepted","memory":"48.6 MB","code":"class Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        ArrayList<List<String>> re = new ArrayList<>();\n        HashMap<String,List<String>> m = new HashMap<>();\n        for (String s: strs){\n            char [] ca = s.toCharArray();\n            Arrays.sort(ca);\n            String k = new String(ca);\n            if (m.containsKey(k)){\n                m.get(k).add(s);\n            } else{\n                m.put(k,new ArrayList<>());\n                m.get(k).add(s);\n            }\n        }\n        for (String s: m.keySet()){\n            ArrayList<String> temp = new ArrayList<>();\n\n            for (String si:m.get(s)){\n                temp.add(si);\n            }\n            re.add(temp);\n        }\n\n        return re;\n        \n    }\n}","runtime":"7 ms","title":"Group Anagrams","url":"/submissions/detail/1084798338/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1084798338,"time":"3 months","lang":"java","title_slug":"group-anagrams","timestamp":1698343457,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"43.9 MB","code":"class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        HashMap<Integer,Integer> m = new HashMap<>();\n        int [] re = new int [2];\n        for (int i=0;i<nums.length;i++){\n            if (m.containsKey(target-nums[i])){\n                re[0] = i;\n                re[1] = m.get(target-nums[i]);\n            } else{\n                m.put(nums[i],i);\n            }\n        }\n        return re;\n        \n    }\n}","runtime":"4 ms","title":"Two Sum","url":"/submissions/detail/1084749903/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1084749903,"time":"3 months","lang":"java","title_slug":"two-sum","timestamp":1698339743,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public boolean isAnagram(String s, String t) {\n        HashMap<Character,Integer> as = new HashMap<>();\n        for (Character c:s.toCharArray()){\n            as.put(c,as.getOrDefault(c,0)+1);\n        }\n\n        HashMap<Character,Integer> at = new HashMap<>();\n        for (Character c:t.toCharArray()){\n            at.put(c,at.getOrDefault(c,0)+1);\n        }\n\n        for (Character c:as.keySet()){\n            if (!at.containsKey(c)) return false;\n            if (as.get(c)!=at.get(c)) return false;\n        }\n        for (Character c:at.keySet()){\n            if (!as.containsKey(c)) return false;\n            // if (as.get(c)!=at.get(c)) return false;\n        }\n        return true;\n        \n    }\n}","runtime":"N/A","title":"Valid Anagram","url":"/submissions/detail/1084298057/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1084298057,"time":"3 months","lang":"java","title_slug":"valid-anagram","timestamp":1698291395,"status":11,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111110111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public boolean isAnagram(String s, String t) {\n        HashMap<Character,Integer> as = new HashMap<>();\n        for (Character c:s.toCharArray()){\n            as.put(c,as.getOrDefault(c,0)+1);\n        }\n\n        HashMap<Character,Integer> at = new HashMap<>();\n        for (Character c:t.toCharArray()){\n            at.put(c,at.getOrDefault(c,0)+1);\n        }\n\n        for (Character c:as.keySet()){\n            if (!at.containsKey(c)) return false;\n            // if (as.get(c)!=at.get(c)) return false;\n        }\n        for (Character c:at.keySet()){\n            if (!as.containsKey(c)) return false;\n            // if (as.get(c)!=at.get(c)) return false;\n        }\n        return true;\n        \n    }\n}","runtime":"N/A","title":"Valid Anagram","url":"/submissions/detail/1084297942/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1084297942,"time":"3 months","lang":"java","title_slug":"valid-anagram","timestamp":1698291384,"status":11,"is_pending":"Not Pending","compare_result":"111111110111101110111110111111101010011111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public boolean isAnagram(String s, String t) {\n        HashMap<Character,Integer> as = new HashMap<>();\n        for (Character c:s.toCharArray()){\n            as.put(c,as.getOrDefault(c,0)+1);\n        }\n\n        HashMap<Character,Integer> at = new HashMap<>();\n        for (Character c:t.toCharArray()){\n            at.put(c,at.getOrDefault(c,0)+1);\n        }\n\n        for (Character c:as.keySet()){\n            if (!at.containsKey(c)) return false;\n            if (as.get(c)!=at.get(c)) return false;\n        }\n        for (Character c:at.keySet()){\n            if (!as.containsKey(c)) return false;\n            if (as.get(c)!=at.get(c)) return false;\n        }\n        return true;\n        \n    }\n}","runtime":"N/A","title":"Valid Anagram","url":"/submissions/detail/1084297176/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1084297176,"time":"3 months","lang":"java","title_slug":"valid-anagram","timestamp":1698291295,"status":11,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111110111111111"},{"status_display":"Accepted","memory":"40.6 MB","code":"class Solution {\n    public boolean wordPattern(String pattern, String s) {\n        HashMap<Character,String> m = new HashMap<>();\n        HashMap<String,Character> m2 = new HashMap<>();\n\n        String[] a = s.split(\"\\\\s+\");\n        char [] c = pattern.toCharArray();\n        int n = pattern.length();\n        if (n!=a.length) return false;\n        for (int i=0;i<n;i++){\n            if (m.containsKey(c[i])){\n                if (!m.get(c[i]).equals(a[i])) return false;\n            } else{\n                m.put(c[i],a[i]);\n            }\n\n            if (m2.containsKey(a[i])){\n                if (!m2.get(a[i]).equals(c[i])) return false;\n            } else{\n                m2.put(a[i],c[i]);\n            }\n        }        \n        return true;\n    }\n}","runtime":"2 ms","title":"Word Pattern","url":"/submissions/detail/1084295700/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1084295700,"time":"3 months","lang":"java","title_slug":"word-pattern","timestamp":1698291127,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public boolean wordPattern(String pattern, String s) {\n        HashMap<Character,String> m = new HashMap<>();\n        String[] a = s.split(\"\\\\s+\");\n        char [] c = pattern.toCharArray();\n        int n = pattern.length();\n        if (n!=a.length) return false;\n        for (int i=0;i<n;i++){\n            if (m.containsKey(c[i])){\n                if (!m.get(c[i]).equals(a[i])) return false;\n            } else{\n                m.put(c[i],a[i]);\n            }\n        }        \n        return true;\n    }\n}","runtime":"N/A","title":"Word Pattern","url":"/submissions/detail/1084294936/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1084294936,"time":"3 months","lang":"java","title_slug":"word-pattern","timestamp":1698291044,"status":11,"is_pending":"Not Pending","compare_result":"111011110111110111111111111111111111111111"},{"status_display":"Accepted","memory":"42 MB","code":"class Solution {\n    public boolean isIsomorphic(String s, String t) {\n        if (s.length()!=t.length()) return false;\n        HashMap<Character,Character> m = new HashMap<>();\n        HashMap<Character,Character> m2 = new HashMap<>();\n\n        char[] cs = s.toCharArray();\n        char[] ct = t.toCharArray();\n        int n = s.length();\n        for (int i=0;i<n;i++){\n            if (m.containsKey(cs[i])){\n                if (!m.get(cs[i]).equals(ct[i])) return false;\n            }else{\n                m.put(cs[i],ct[i]);\n            }\n            if (m2.containsKey(ct[i])){\n                if (!m2.get(ct[i]).equals(cs[i])) return false;\n            }else{\n                m2.put(ct[i],cs[i]);\n            }\n\n        }\n        return true;\n    }\n}","runtime":"16 ms","title":"Isomorphic Strings","url":"/submissions/detail/1084292758/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1084292758,"time":"3 months","lang":"java","title_slug":"isomorphic-strings","timestamp":1698290786,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public boolean isIsomorphic(String s, String t) {\n        if (s.length()!=t.length()) return false;\n        HashMap<Character,Character> m = new HashMap<>();\n        char[] cs = s.toCharArray();\n        char[] ct = t.toCharArray();\n        int n = s.length();\n        for (int i=0;i<n;i++){\n            if (m.containsKey(cs[i])){\n                if (!m.get(cs[i]).equals(ct[i])) return false;\n            }else{\n                m.put(cs[i],ct[i]);\n            }\n\n        }\n        return true;\n    }\n}","runtime":"N/A","title":"Isomorphic Strings","url":"/submissions/detail/1084291482/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1084291482,"time":"3 months","lang":"java","title_slug":"isomorphic-strings","timestamp":1698290631,"status":11,"is_pending":"Not Pending","compare_result":"1111110111101101110111011111110110111111111100"},{"status_display":"Accepted","memory":"43.9 MB","code":"class Solution {\n    public boolean canConstruct(String ransomNote, String magazine) {\n        HashMap<Character,Integer> ra = new HashMap<>();\n        for (Character c:ransomNote.toCharArray()){\n            ra.put(c,ra.getOrDefault(c,0)+1);\n        }\n\n        HashMap<Character,Integer> ma = new HashMap<>();\n        for (Character c:magazine.toCharArray()){\n            ma.put(c,ma.getOrDefault(c,0)+1);\n        }\n\n        for (Character c:ra.keySet()){\n            if (!ma.containsKey(c)) return false;\n            if (ra.get(c)>ma.get(c)) return false;\n        }\n        return true;\n    }\n}","runtime":"14 ms","title":"Ransom Note","url":"/submissions/detail/1084289052/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1084289052,"time":"3 months","lang":"java","title_slug":"ransom-note","timestamp":1698290345,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"41.4 MB","code":"class Solution {\n    public void rotate(int[][] matrix) {\n        transpose(matrix);\n        for (int i = 0;i<matrix.length;i++){\n            inv(matrix[i]);\n        }\n        return ;\n    }\n    void inv(int [] a){\n        int s = 0;\n        int e = a.length-1;\n        while (s<e){\n            int temp = a[s];\n            a[s] = a[e];\n            a[e] = temp;\n            s++;\n            e--;\n        }\n    }\n\n    void transpose(int [][] a){\n        int n = a.length;\n        int m = a[0].length;\n        for (int i = 0; i<n;i++){\n            for (int j =i+1;j<m;j++){\n                int temp = a[i][j];\n                a[i][j] = a[j][i];\n                a[j][i] = temp;\n            }\n        }\n    }\n}","runtime":"0 ms","title":"Rotate Image","url":"/submissions/detail/1084147147/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1084147147,"time":"3 months","lang":"java","title_slug":"rotate-image","timestamp":1698269660,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111"},{"status_display":"Accepted","memory":"41.8 MB","code":"class Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        int n = matrix.length;\n        int m = matrix[0].length;\n\n        boolean [][] check = new boolean[n][m];\n        // Arrays.fill(check,false);\n        ArrayList<Integer> re = new ArrayList<>();\n        move(re,0,matrix,check,0,0,n*m);\n        System.gc();\n        return re;\n        \n    }\n\n    void move(List<Integer> re, int dir, int[][] matrix, boolean[][] check, int x, int y,int total){\n        if (re.size() == total ) return;\n        if (x>= matrix.length) return;\n        if (y>= matrix[0].length) return;\n        if (check[x][y]) return;\n        // System.out.println(x+\" \"+ y + \" \"+ dir);\n        re.add(matrix[x][y]);\n        check[x][y] = true;\n        if (dir == 0){\n            if ( y+1<matrix[0].length && !check[x][y+1]){\n                move(re,dir,matrix,check,x,y+1, total);\n            } else{\n                move(re,1,matrix,check,x+1,y,total);\n            }\n        } else if (dir == 1){\n            if (x+1<matrix.length && !check[x+1][y])\n                move(re,dir,matrix,check,x+1,y,total);\n            else\n                move(re,2,matrix,check,x,y-1,total);\n        } else if (dir == 2) {\n            if ( y-1 >=0 && !check[x][y-1])\n                move(re,dir,matrix,check,x,y-1,total);\n            else \n                move(re,3,matrix,check,x-1,y,total);\n        } else if (dir == 3){\n            if (x-1>=0 && !check[x-1][y])\n                move(re,dir,matrix,check,x-1,y,total);\n            else\n                move(re,0,matrix,check,x,y+1,total);\n        }\n        return;\n    }\n}","runtime":"0 ms","title":"Spiral Matrix","url":"/submissions/detail/1084143015/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1084143015,"time":"3 months","lang":"java","title_slug":"spiral-matrix","timestamp":1698269127,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111"},{"status_display":"Accepted","memory":"42 MB","code":"class Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        int n = matrix.length;\n        int m = matrix[0].length;\n\n        boolean [][] check = new boolean[n][m];\n        // Arrays.fill(check,false);\n        ArrayList<Integer> re = new ArrayList<>();\n        move(re,0,matrix,check,0,0,n*m);\n        System.gc();\n        return re;\n        \n    }\n\n    void move(List<Integer> re, int dir, int[][] matrix, boolean[][] check, int x, int y,int total){\n        if (re.size() == total ) return;\n        if (x>= matrix.length) return;\n        if (y>= matrix[0].length) return;\n        if (check[x][y]) return;\n        // System.out.println(x+\" \"+ y + \" \"+ dir);\n        re.add(matrix[x][y]);\n        check[x][y] = true;\n        if (dir == 0){\n            if ( y+1<matrix[0].length && !check[x][y+1]){\n                move(re,dir,matrix,check,x,y+1, total);\n            } else{\n                move(re,1,matrix,check,x+1,y,total);\n            }\n        } else if (dir == 1){\n            if (x+1<matrix.length && !check[x+1][y])\n                move(re,dir,matrix,check,x+1,y,total);\n            else\n                move(re,2,matrix,check,x,y-1,total);\n        } else if (dir == 2) {\n            if ( y-1 >=0 && !check[x][y-1])\n                move(re,dir,matrix,check,x,y-1,total);\n            else \n                move(re,3,matrix,check,x-1,y,total);\n        } else if (dir == 3){\n            if (x-1>=0 && !check[x-1][y])\n                move(re,dir,matrix,check,x-1,y,total);\n            else\n                move(re,0,matrix,check,x,y+1,total);\n        }\n        return;\n    }\n}","runtime":"0 ms","title":"Spiral Matrix","url":"/submissions/detail/1084142947/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1084142947,"time":"3 months","lang":"java","title_slug":"spiral-matrix","timestamp":1698269118,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111"},{"status_display":"Accepted","memory":"41.8 MB","code":"class Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        int n = matrix.length;\n        int m = matrix[0].length;\n\n        boolean [][] check = new boolean[n][m];\n        // Arrays.fill(check,false);\n        ArrayList<Integer> re = new ArrayList<>();\n        move(re,0,matrix,check,0,0,n*m);\n        System.gc();\n        return re;\n        \n    }\n\n    void move(List<Integer> re, int dir, int[][] matrix, boolean[][] check, int x, int y,int total){\n        if (re.size() == total ) return;\n        if (x>= matrix.length) return;\n        if (y>= matrix[0].length) return;\n        if (check[x][y]) return;\n        // System.out.println(x+\" \"+ y + \" \"+ dir);\n        re.add(matrix[x][y]);\n        check[x][y] = true;\n        if (dir == 0){\n            if ( y+1<matrix[0].length && !check[x][y+1]){\n                move(re,dir,matrix,check,x,y+1, total);\n            } else{\n                move(re,1,matrix,check,x+1,y,total);\n            }\n        } else if (dir == 1){\n            if (x+1<matrix.length && !check[x+1][y])\n                move(re,dir,matrix,check,x+1,y,total);\n            else\n                move(re,2,matrix,check,x,y-1,total);\n        } else if (dir == 2) {\n            if ( y-1 >=0 && !check[x][y-1])\n                move(re,dir,matrix,check,x,y-1,total);\n            else \n                move(re,3,matrix,check,x-1,y,total);\n        } else if (dir == 3){\n            if (x-1>=0 && !check[x-1][y])\n                move(re,dir,matrix,check,x-1,y,total);\n            else\n                move(re,0,matrix,check,x,y+1,total);\n        }\n        return;\n    }\n}","runtime":"0 ms","title":"Spiral Matrix","url":"/submissions/detail/1084142883/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1084142883,"time":"3 months","lang":"java","title_slug":"spiral-matrix","timestamp":1698269111,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111"},{"status_display":"Accepted","memory":"40.6 MB","code":"class Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        int n = matrix.length;\n        int m = matrix[0].length;\n\n        boolean [][] check = new boolean[n][m];\n        // Arrays.fill(check,false);\n        ArrayList<Integer> re = new ArrayList<>();\n        move(re,0,matrix,check,0,0,n*m);\n        return re;\n        \n    }\n\n    void move(List<Integer> re, int dir, int[][] matrix, boolean[][] check, int x, int y,int total){\n        if (re.size() == total ) return;\n        if (x>= matrix.length) return;\n        if (y>= matrix[0].length) return;\n        if (check[x][y]) return;\n        // System.out.println(x+\" \"+ y + \" \"+ dir);\n        re.add(matrix[x][y]);\n        check[x][y] = true;\n        if (dir == 0){\n            if ( y+1<matrix[0].length && !check[x][y+1]){\n                move(re,dir,matrix,check,x,y+1, total);\n            } else{\n                move(re,1,matrix,check,x+1,y,total);\n            }\n        } else if (dir == 1){\n            if (x+1<matrix.length && !check[x+1][y])\n                move(re,dir,matrix,check,x+1,y,total);\n            else\n                move(re,2,matrix,check,x,y-1,total);\n        } else if (dir == 2) {\n            if ( y-1 >=0 && !check[x][y-1])\n                move(re,dir,matrix,check,x,y-1,total);\n            else \n                move(re,3,matrix,check,x-1,y,total);\n        } else if (dir == 3){\n            if (x-1>=0 && !check[x-1][y])\n                move(re,dir,matrix,check,x-1,y,total);\n            else\n                move(re,0,matrix,check,x,y+1,total);\n        }\n        return;\n    }\n}","runtime":"0 ms","title":"Spiral Matrix","url":"/submissions/detail/1084142459/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1084142459,"time":"3 months","lang":"java","title_slug":"spiral-matrix","timestamp":1698269059,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111"},{"status_display":"Accepted","memory":"43.3 MB","code":"class Solution {\n    public boolean isValidSudoku(char[][] board) {\n        int n = board.length;\n        int m = board[0].length;\n        for (int i  = 0;i<n;i++){\n            HashSet<Character> set = new HashSet<>();\n            for (int j = 0;j<m;j++){\n                if (board[i][j]!='.'){\n                    if (set.contains(board[i][j])) return false;\n                    else set.add(board[i][j]);\n                }\n            }\n        }\n        \n        for (int i  = 0;i<m;i++){\n            HashSet<Character> set = new HashSet<>();\n            for (int j = 0;j<n;j++){\n                if (board[j][i]!='.'){\n                    if (set.contains(board[j][i])) return false;\n                    else set.add(board[j][i]);\n                }\n            }\n        }\n\n        for (int i = 0;i<n;i+=3){\n            for (int j = 0;j<m;j+=3){\n                HashSet<Character> set = new HashSet<>();\n                for (int x = 0;x<3;x++){\n                    for (int y = 0;y<3;y++){\n                        char temp = board[i+x][j+y];\n                        if (temp!='.') {\n                            if (set.contains(temp)) return false;\n                            else set.add(temp);\n                        }\n                        \n                    }\n                }\n            }\n        }\n        return true;\n    }\n}","runtime":"2 ms","title":"Valid Sudoku","url":"/submissions/detail/1084082607/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1084082607,"time":"3 months","lang":"java","title_slug":"valid-sudoku","timestamp":1698262455,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"43.9 MB","code":"class Solution {\n    public String minWindow(String s, String t) {\n        HashMap<Character, Integer> m = new HashMap<>();\n        HashMap<Character, Integer> tracker = new HashMap<>();\n\n        for (Character c: t.toCharArray()){\n            m.put(c,m.getOrDefault(c,0)+1);\n            tracker.put(c,0);\n        }\n        int l = 0;\n        int r = 0;\n        int count = 0;\n        int n = s.length();\n        char [] ch = s.toCharArray();\n        int min = Integer.MAX_VALUE;\n        int min_l = -1;\n        int min_r = -1;\n        // HashSet<Integer> test = new HashSet<>();\n        while (r<n){\n                                // System.out.println(l +\" \" + r +\" \" + count);\n\n            if ( tracker.containsKey( ch[r] ) ){\n                tracker.put(ch[r], tracker.get(ch[r])+1);\n                if (tracker.get(ch[r]).equals(m.get(ch[r]))){\n                    count ++;\n                }\n            }\n            // if (!test.contains(count)){\n            //     System.out.println(count + \" \"+ m.keySet().size());;\n            //     test.add(count);\n            // }\n                \n\n            if (count == m.keySet().size()){\n                \n                while (count == m.keySet().size()){\n                    if (l>=n) break;\n\n                    int dist = r - l + 1;\n                    if (dist<min) {\n                        min = dist;\n                        min_l = l;\n                        min_r = r;\n                    }\n                      \n                    if (tracker.containsKey(ch[l])){\n                        tracker.put(ch[l],tracker.get(ch[l])-1 );\n                        if (tracker.get(ch[l])<m.get(ch[l] ) ) count --;\n\n                    }\n                    l++;\n                }\n            }\n            r++;\n        }\n\n\n        if (min==Integer.MAX_VALUE) return \"\";\n        StringBuilder re = new StringBuilder();\n        for (int i = min_l; i<=min_r;i++){\n            re.append(ch[i]);\n        }\n        return re.toString();\n\n    }\n}\n// ADOBECODEBANC","runtime":"15 ms","title":"Minimum Window Substring","url":"/submissions/detail/1083313001/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1083313001,"time":"3 months","lang":"java","title_slug":"minimum-window-substring","timestamp":1698180609,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public String minWindow(String s, String t) {\n        HashMap<Character, Integer> m = new HashMap<>();\n        HashMap<Character, Integer> tracker = new HashMap<>();\n\n        for (Character c: t.toCharArray()){\n            m.put(c,m.getOrDefault(c,0)+1);\n            tracker.put(c,0);\n        }\n        int l = 0;\n        int r = 0;\n        int count = 0;\n        int n = s.length();\n        char [] ch = s.toCharArray();\n        int min = Integer.MAX_VALUE;\n        int min_l = -1;\n        int min_r = -1;\n        \n        while (r<n){\n                                // System.out.println(l +\" \" + r +\" \" + count);\n\n            if ( tracker.containsKey( ch[r] ) ){\n                tracker.put(ch[r], tracker.get(ch[r])+1);\n                if (tracker.get(ch[r])==m.get(ch[r])){\n                    count ++;\n                }\n            }\n            if (count == m.keySet().size()){\n                \n                while (count == m.keySet().size()){\n                    if (l>=n) break;\n\n                    int dist = r - l + 1;\n                    if (dist<min) {\n                        min = dist;\n                        min_l = l;\n                        min_r = r;\n                    }\n                      \n                    if (tracker.containsKey(ch[l])){\n                        tracker.put(ch[l],tracker.get(ch[l])-1 );\n                        if (tracker.get(ch[l])<m.get(ch[l] ) ) count --;\n\n                    }\n                    l++;\n                }\n            }\n            r++;\n        }\n\n\n        if (min==Integer.MAX_VALUE) return \"\";\n        StringBuilder re = new StringBuilder();\n        for (int i = min_l; i<=min_r;i++){\n            re.append(ch[i]);\n        }\n        return re.toString();\n\n    }\n}\n// ADOBECODEBANC","runtime":"N/A","title":"Minimum Window Substring","url":"/submissions/detail/1083309688/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1083309688,"time":"3 months","lang":"java","title_slug":"minimum-window-substring","timestamp":1698180243,"status":11,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111101"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public String minWindow(String s, String t) {\n        HashMap<Character, Integer> m = new HashMap<>();\n        HashMap<Character, Integer> tracker = new HashMap<>();\n\n        for (Character c: t.toCharArray()){\n            m.put(c,m.getOrDefault(c,0)+1);\n            tracker.put(c,0);\n        }\n        int l = 0;\n        int r = 0;\n        int count = 0;\n        int n = s.length();\n        char [] ch = s.toCharArray();\n        int min = Integer.MAX_VALUE;\n        int min_l = -1;\n        int min_r = -1;\n        \n        while (r<n){\n                                System.out.println(l +\" \" + r +\" \" + count);\n\n            if ( tracker.containsKey( ch[r] ) ){\n                tracker.put(ch[r], tracker.get(ch[r])+1);\n                if (tracker.get(ch[r])==m.get(ch[r])){\n                    count ++;\n                }\n            }\n            if (count == m.keySet().size()){\n                \n                while (count == m.keySet().size()){\n                    if (l>=n) break;\n\n                    int dist = r - l + 1;\n                    if (dist<min) {\n                        min = dist;\n                        min_l = l;\n                        min_r = r;\n                    }\n                      \n                    if (tracker.containsKey(ch[l])){\n                        tracker.put(ch[l],tracker.get(ch[l])-1 );\n                        if (tracker.get(ch[l])<m.get(ch[l] ) ) count --;\n\n                    }\n                    l++;\n                }\n            }\n            r++;\n        }\n\n\n        if (min==Integer.MAX_VALUE) return \"\";\n        StringBuilder re = new StringBuilder();\n        for (int i = min_l; i<=min_r;i++){\n            re.append(ch[i]);\n        }\n        return re.toString();\n\n    }\n}\n// ADOBECODEBANC","runtime":"N/A","title":"Minimum Window Substring","url":"/submissions/detail/1083309628/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1083309628,"time":"3 months","lang":"java","title_slug":"minimum-window-substring","timestamp":1698180235,"status":11,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111101"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public String minWindow(String s, String t) {\n        HashMap<Character, Integer> m = new HashMap<>();\n        HashMap<Character, Integer> tracker = new HashMap<>();\n\n        for (Character c: t.toCharArray()){\n            m.put(c,m.getOrDefault(c,0)+1);\n            tracker.put(c,0);\n        }\n        int l = 0;\n        int r = 0;\n        int count = 0;\n        int n = s.length();\n        char [] ch = s.toCharArray();\n        int min = Integer.MAX_VALUE;\n        int min_l = -1;\n        int min_r = -1;\n        \n        while (r<n){\n            if ( tracker.containsKey( ch[r] ) ){\n                tracker.put(ch[r], tracker.get(ch[r])+1);\n                if (tracker.get(ch[r])==m.get(ch[r])){\n                    count ++;\n                }\n            }\n            if (count == t.length()){\n                \n                while (count == t.length()){\n                    // System.out.println(l +\" \" + r +\" \" + count);\n\n                    int dist = r - l + 1;\n                    if (dist<min) {\n                        min = dist;\n                        min_l = l;\n                        min_r = r;\n                    }\n                      \n                    if (l>=n) break;\n                    if (tracker.containsKey(ch[l])){\n                        tracker.put(ch[l],tracker.get(ch[l])-1 );\n                        if (tracker.get(ch[l])<m.get(ch[l] ) ) count --;\n\n                    }\n                    l++;\n                }\n            }\n            r++;\n        }\n\n\n        if (min==Integer.MAX_VALUE) return \"\";\n        StringBuilder re = new StringBuilder();\n        for (int i = min_l; i<=min_r;i++){\n            re.append(ch[i]);\n        }\n        return re.toString();\n\n    }\n}\n// ADOBECODEBANC","runtime":"N/A","title":"Minimum Window Substring","url":"/submissions/detail/1083308264/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1083308264,"time":"3 months","lang":"java","title_slug":"minimum-window-substring","timestamp":1698180092,"status":11,"is_pending":"Not Pending","compare_result":"111111110111111111101100011110011011010011111100110111111011001111111111111111010111110111111111111001000001011010111000111111111101111111010111101111010111110111111111100010010011110000000101000000000000000000000000001001010000000010000001001000100000001100000000001"}],"has_next":true,"last_key":"%7B%22pk%22%3A%20%7B%22N%22%3A%20%221083308264%22%7D%2C%20%22dt%22%3A%20%7B%22S%22%3A%20%222023-10-24T20%3A41%3A32.931501%2B0000%22%7D%2C%20%22sid%22%3A%20%7B%22N%22%3A%20%227573785%22%7D%7D"}
2024-01-26 23:38:36.537 [main] DEBUG submission_dump - {"submissions_dump":[{"status_display":"Accepted","memory":"60.7 MB","code":"class Solution {\n    public int minimumSum(int[] nums) {\n        int sum = 0;\n        int n = nums.length;\n        int[] l = new int[n];\n        int[] r = new int[n];\n        int min= Integer.MAX_VALUE;\n        Arrays.fill(l, Integer.MAX_VALUE);\n        Arrays.fill(r, Integer.MAX_VALUE);\n        for (int i =0;i<n;i++) {\n        \tif (nums[i]<min) min = nums[i];\n        \tl[i] = min;\n        }\n        min= Integer.MAX_VALUE;\n        for (int i =n-1;i>0;i--) {\n        \tif (nums[i]<min) min = nums[i];\n        \tr[i] = min;\n        }\n        min= Integer.MAX_VALUE;\n        for (int i = 0;i<n;i++) {\n        \t// System.out.println(l[i]+\" \"+r[i]);\n        \tsum = l[i] + r[i]+nums[i];\n        \tif (nums[i]>l[i] && nums[i]>r[i]) {\n        \t\tif (sum<min) min = sum;\n        \t}\n        }\n        return min==Integer.MAX_VALUE?-1:min;\n \n    }\n}","runtime":"3 ms","title":"Minimum Sum of Mountain Triplets II","url":"/submissions/detail/1081005310/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1081005310,"time":"3 months, 1 week","lang":"java","title_slug":"minimum-sum-of-mountain-triplets-ii","timestamp":1697943354,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Time Limit Exceeded","memory":"N/A","code":"class Solution {\n    public int minimumSum(int[] nums) {\n        int sum = 0;\n        int n = nums.length;\n        int[] l = new int[n];\n        int[] r = new int[n];\n        int min= Integer.MAX_VALUE;\n        Arrays.fill(l, Integer.MAX_VALUE);\n        Arrays.fill(r, Integer.MAX_VALUE);\n\n        for (int i=1;i<n;i++) {\n        \tfor (int j=i-1;j>=0;j--) {\n        \t\tif (nums[i]>nums[j]) {\n        \t\t\tif (nums[j]<l[i]) {\n        \t\t\t\tl[i] = nums[j];\n        \t\t\t}\n        \t\t}\n        \t}\n        }\n        for (int i=n-2;i>=0;i--) {\n        \tfor (int j=i+1;j<n;j++) {\n        \t\tif (nums[i]>nums[j]) {\n        \t\t\tif (nums[j]<r[i]) {\n        \t\t\t\tr[i] = nums[j];\n        \t\t\t}\n        \t\t}\n        \t}\n        }\n        for (int i = 0;i<n;i++) {\n        \t// System.out.println(l[i]+\" \"+r[i]);\n        \tsum = l[i] + r[i]+nums[i];\n        \tif (l[i]!= Integer.MAX_VALUE && r[i]!=Integer.MAX_VALUE) {\n        \t\tif (sum<min) min = sum;\n        \t}\n        }\n        \n        return min==Integer.MAX_VALUE?-1:min;\n \n    }\n}","runtime":"N/A","title":"Minimum Sum of Mountain Triplets II","url":"/submissions/detail/1081000886/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1081000886,"time":"3 months, 1 week","lang":"java","title_slug":"minimum-sum-of-mountain-triplets-ii","timestamp":1697943108,"status":14,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000"},{"status_display":"Time Limit Exceeded","memory":"N/A","code":"class Solution {\n    public int minimumSum(int[] nums) {\n        int sum = 0;\n        int n = nums.length;\n        int min = Integer.MAX_VALUE;\n        for (int i =0;i<n-2;i++) {\n        \tfor (int j=i+1;j<n-1;j++) {\n        \t\tfor (int k= j+1;k<n;k++) {\n        \t\t\tif (nums[j]>nums[k] && nums[j]>nums[i]) {\n        \t\t\t\tsum = nums[i] + nums[j] + nums[k];\n        \t\t\t\tif (sum<min) min = sum;\n        \t\t\t}\n        \t\t}\n        \t}\n        }\n        return min==Integer.MAX_VALUE?-1:min;\n    }\n}","runtime":"N/A","title":"Minimum Sum of Mountain Triplets II","url":"/submissions/detail/1080984658/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1080984658,"time":"3 months, 1 week","lang":"java","title_slug":"minimum-sum-of-mountain-triplets-ii","timestamp":1697942300,"status":14,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000000000000"},{"status_display":"Accepted","memory":"41.4 MB","code":"class Solution {\n    public int minimumSum(int[] nums) {\n        int sum = 0;\n        int n = nums.length;\n        int min = Integer.MAX_VALUE;\n        for (int i =0;i<n-2;i++) {\n        \tfor (int j=i+1;j<n-1;j++) {\n        \t\tfor (int k= j+1;k<n;k++) {\n        \t\t\tif (nums[j]>nums[k] && nums[j]>nums[i]) {\n        \t\t\t\tsum = nums[i] + nums[j] + nums[k];\n        \t\t\t\tif (sum<min) min = sum;\n        \t\t\t}\n        \t\t}\n        \t}\n        }\n        return min==Integer.MAX_VALUE?-1:min;\n    }\n}","runtime":"1 ms","title":"Minimum Sum of Mountain Triplets I","url":"/submissions/detail/1080982338/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1080982338,"time":"3 months, 1 week","lang":"java","title_slug":"minimum-sum-of-mountain-triplets-i","timestamp":1697942206,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Time Limit Exceeded","memory":"N/A","code":"class Solution {\n    public String minWindow(String s, String t) {\n        HashMap<Character, Integer> m = new HashMap<>();\n        for (Character c: t.toCharArray()){\n            m.put(c,m.getOrDefault(c,0)+1);\n        }\n        int l = 0;\n        int r = 0;\n        char [] ch = s.toCharArray();\n        int n = t.length();\n        HashMap<Character, Integer> temp = new HashMap<>(m);\n        int min = Integer.MAX_VALUE;\n        int min_l = -1;\n        int min_r = -1;\n        int count = 0;\n        int next_l = -1;\n        while (l<s.length()){\n            while (l<s.length() && !temp.containsKey(ch[l])) l++;\n            r= l;\n            count = 0;\n            next_l = -1;\n            while (r<s.length() && count<n){\n                if (temp.containsKey(ch[r])){\n                    if ( r != l && next_l == -1) next_l = r;\n                }\n                if (temp.containsKey(ch[r]) && temp.get(ch[r])>0 ){\n                    count++;\n                    temp.put(ch[r], temp.get(ch[r])-1);\n                }\n                // System.out.println(l+\" \"+r+\" \"+count+ \" \"+ next_l);\n                if (count == n){\n                    int v = r-l + 1;\n                    if (v < min) {\n                        min = v;\n                        min_l = l;\n                        min_r = r;\n                        break;\n                    }\n                }\n                r++;\n            }\n            count = 1;\n\n            l = next_l!=-1?next_l:r ;\n            temp = new HashMap<>(m);\n            \n        }\n        StringBuilder re = new StringBuilder();\n        if (min == Integer.MAX_VALUE) return \"\";\n        for (int i = min_l;i<=min_r;i++){\n            re.append(s.charAt(i));\n        }\n\n        return re.toString();\n\n    }\n}","runtime":"N/A","title":"Minimum Window Substring","url":"/submissions/detail/1080881773/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1080881773,"time":"3 months, 1 week","lang":"java","title_slug":"minimum-window-substring","timestamp":1697925760,"status":14,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100"},{"status_display":"Time Limit Exceeded","memory":"N/A","code":"class Solution {\n    public String minWindow(String s, String t) {\n        HashMap<Character, Integer> m = new HashMap<>();\n        for (Character c: t.toCharArray()){\n            m.put(c,m.getOrDefault(c,0)+1);\n        }\n        int l = 0;\n        int r = 0;\n        char [] ch = s.toCharArray();\n        int n = t.length();\n        HashMap<Character, Integer> temp = new HashMap<>(m);\n        int min = Integer.MAX_VALUE;\n        int min_l = -1;\n        int min_r = -1;\n        int count = 0;\n        int next_l = -1;\n        while (l<s.length()){\n            while (l<s.length() && !temp.containsKey(ch[l])) l++;\n            r= l;\n            count = 0;\n            next_l = -1;\n            while (r<s.length() && count<n){\n                if (temp.containsKey(ch[r])){\n                    if ( r != l && next_l == -1) next_l = r;\n                }\n                if (temp.containsKey(ch[r]) && temp.get(ch[r])>0 ){\n                    count++;\n                    temp.put(ch[r], temp.get(ch[r])-1);\n                }\n                // System.out.println(l+\" \"+r+\" \"+count+ \" \"+ next_l);\n                if (count == n){\n                    int v = r-l + 1;\n                    if (v < min) {\n                        min = v;\n                        min_l = l;\n                        min_r = r;\n                        break;\n                    }\n                }\n                r++;\n            }\n            count = 1;\n\n            l = next_l!=-1?next_l:r ;\n            temp = new HashMap<>(m);\n            \n        }\n        StringBuilder re = new StringBuilder();\n        if (min == Integer.MAX_VALUE) return \"\";\n        for (int i = min_l;i<=min_r;i++){\n            re.append(s.charAt(i));\n        }\n\n        return re.toString();\n\n    }\n}","runtime":"N/A","title":"Minimum Window Substring","url":"/submissions/detail/1080297362/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1080297362,"time":"3 months, 1 week","lang":"java","title_slug":"minimum-window-substring","timestamp":1697855801,"status":14,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100"},{"status_display":"Time Limit Exceeded","memory":"N/A","code":"class Solution {\n    public String minWindow(String s, String t) {\n        HashMap<Character, Integer> m = new HashMap<>();\n        for (Character c: t.toCharArray()){\n            m.put(c,m.getOrDefault(c,0)+1);\n        }\n        int l = 0;\n        int r = 0;\n        char [] ch = s.toCharArray();\n        int n = t.length();\n        HashMap<Character, Integer> temp = new HashMap<>(m);\n        int min = Integer.MAX_VALUE;\n        int min_l = -1;\n        int min_r = -1;\n        int count = 0;\n        while (l<s.length()){\n            while (l<s.length() && !temp.containsKey(ch[l])) l++;\n            r= l;\n            count = 0;\n            while (r<s.length() && count<n){\n                if (temp.containsKey(ch[r]) && temp.get(ch[r])>0 ){\n                    count++;\n                    temp.put(ch[r], temp.get(ch[r])-1);\n                }\n                // System.out.println(l+\" \"+r+\" \"+count);\n                if (count == n){\n                    int v = r-l + 1;\n                    if (v < min) {\n                        min = v;\n                        min_l = l;\n                        min_r = r;\n                        break;\n\n                    }\n                }\n                r++;\n            }\n            count = 1;\n            l = l+1 ;\n            temp = new HashMap<>(m);\n            \n        }\n        StringBuilder re = new StringBuilder();\n        if (min == Integer.MAX_VALUE) return \"\";\n        for (int i = min_l;i<=min_r;i++){\n            re.append(s.charAt(i));\n        }\n\n        return re.toString();\n\n    }\n}","runtime":"N/A","title":"Minimum Window Substring","url":"/submissions/detail/1080295015/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1080295015,"time":"3 months, 1 week","lang":"java","title_slug":"minimum-window-substring","timestamp":1697855341,"status":14,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100"},{"status_display":"Time Limit Exceeded","memory":"N/A","code":"class Solution {\n    public String minWindow(String s, String t) {\n        HashMap<Character, Integer> m = new HashMap<>();\n        for (Character c: t.toCharArray()){\n            m.put(c,m.getOrDefault(c,0)+1);\n        }\n        int l = 0;\n        int r = 0;\n        char [] ch = s.toCharArray();\n        int n = t.length();\n        HashMap<Character, Integer> temp = new HashMap<>(m);\n        int min = Integer.MAX_VALUE;\n        int min_l = -1;\n        int min_r = -1;\n        int count = 0;\n        while (l<s.length()){\n            while (l<s.length() && !temp.containsKey(ch[l])) l++;\n            r= l;\n            count = 0;\n            while (r<s.length() && count<n){\n                if (temp.containsKey(ch[r]) && temp.get(ch[r])>0 ){\n                    count++;\n                    temp.put(ch[r], temp.get(ch[r])-1);\n                }\n                System.out.println(l+\" \"+r+\" \"+count);\n                if (count == n){\n                    int v = r-l + 1;\n                    if (v < min) {\n                        min = v;\n                        min_l = l;\n                        min_r = r;\n                        break;\n\n                    }\n                }\n                r++;\n            }\n            count = 1;\n            l = l+1 ;\n            temp = new HashMap<>(m);\n            \n        }\n        StringBuilder re = new StringBuilder();\n        if (min == Integer.MAX_VALUE) return \"\";\n        for (int i = min_l;i<=min_r;i++){\n            re.append(s.charAt(i));\n        }\n\n        return re.toString();\n\n    }\n}","runtime":"N/A","title":"Minimum Window Substring","url":"/submissions/detail/1080294956/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1080294956,"time":"3 months, 1 week","lang":"java","title_slug":"minimum-window-substring","timestamp":1697855332,"status":14,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public String minWindow(String s, String t) {\n        HashMap<Character, Integer> m = new HashMap<>();\n        for (Character c: t.toCharArray()){\n            m.put(c,m.getOrDefault(c,0)+1);\n        }\n        int l = 0;\n        int r = 0;\n        char [] ch = s.toCharArray();\n        int n = t.length();\n        HashMap<Character, Integer> temp = new HashMap<>(m);\n        int min = Integer.MAX_VALUE;\n        int min_l = -1;\n        int min_r = -1;\n        int count = 0;\n        while (l<s.length()){\n            while (l<s.length() && !temp.containsKey(ch[l])) l++;\n            r= l;\n            count = 0;\n            while (r<s.length() && count<n){\n                if (temp.containsKey(ch[r]) && temp.get(ch[r])>0 ){\n                    count++;\n                    temp.put(ch[r], temp.get(ch[r])+1);\n                }\n                System.out.println(l+\" \"+r+\" \"+count);\n                if (count == n){\n                    int v = r-l + 1;\n                    if (v < min) {\n                        min = v;\n                        min_l = l;\n                        min_r = r;\n                        break;\n\n                    }\n                }\n                r++;\n            }\n            count = 1;\n            l = l+1 ;\n            temp = new HashMap<>(m);\n            \n        }\n        StringBuilder re = new StringBuilder();\n        if (min == Integer.MAX_VALUE) return \"\";\n        for (int i = min_l;i<=min_r;i++){\n            re.append(s.charAt(i));\n        }\n\n        return re.toString();\n\n    }\n}","runtime":"N/A","title":"Minimum Window Substring","url":"/submissions/detail/1080294322/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1080294322,"time":"3 months, 1 week","lang":"java","title_slug":"minimum-window-substring","timestamp":1697855201,"status":11,"is_pending":"Not Pending","compare_result":"111111111111111111111000011111000000010001001100011110111100100011011101111110011110011110001010001000010001011111001101110111101110111111111111111111111000011111010111101001010110000000001101101000000000000000000010000000000000000000000000001000000000000000000000000"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public String minWindow(String s, String t) {\n        HashMap<Character, Integer> m = new HashMap<>();\n        for (Character c: t.toCharArray()){\n            m.put(c,m.getOrDefault(c,0)+1);\n        }\n        int l = 0;\n        int r = 0;\n        char [] ch = s.toCharArray();\n        int n = t.length();\n        HashMap<Character, Integer> temp = new HashMap<>(m);\n        int min = Integer.MAX_VALUE;\n        int min_l = -1;\n        int min_r = -1;\n        int count = 0;\n        while (l<s.length()){\n            while (l<s.length() && !temp.containsKey(ch[l])) l++;\n            r= l;\n            count = 0;\n            while (r<s.length() && count<n){\n                if (temp.containsKey(ch[r]) && temp.get(ch[r])>0 ){\n                    count++;\n                    temp.put(ch[r], temp.get(ch[r])+1);\n                }\n                // System.out.println(l+\" \"+r+\" \"+count);\n                if (count == n){\n                    int v = r-l + 1;\n                    if (v < min) {\n                        min = v;\n                        min_l = l;\n                        min_r = r;\n                    }\n                }\n                r++;\n\n            }\n            l = r + 1;\n            \n        }\n        StringBuilder re = new StringBuilder();\n        if (min == Integer.MAX_VALUE) return \"\";\n        for (int i = min_l;i<=min_r;i++){\n            re.append(s.charAt(i));\n        }\n\n        return re.toString();\n\n    }\n}","runtime":"N/A","title":"Minimum Window Substring","url":"/submissions/detail/1080281724/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1080281724,"time":"3 months, 1 week","lang":"java","title_slug":"minimum-window-substring","timestamp":1697852637,"status":11,"is_pending":"Not Pending","compare_result":"111111111111111111110000000001000000010010001100011110111100100011010101101110011110011110001010001100000001011110101101110111101110111111111111111111111000011111010111101001010110010000001101101000000000000000000000000000000000000000000000000000000000000000000000000"},{"status_display":"Runtime Error","memory":"N/A","code":"class Solution {\n    public String minWindow(String s, String t) {\n        HashMap<Character, Integer> m = new HashMap<>();\n        for (Character c: t.toCharArray()){\n            m.put(c,m.getOrDefault(c,0)+1);\n        }\n        int l = 0;\n        int r = 0;\n        char [] ch = s.toCharArray();\n        int n = t.length();\n        HashMap<Character, Integer> temp = new HashMap<>(m);\n        int min = Integer.MAX_VALUE;\n        int min_l = -1;\n        int min_r = -1;\n        int count = 0;\n        while (l<s.length()){\n            while (!temp.containsKey(ch[l])) l++;\n            r= l;\n            count = 0;\n            while (r<s.length() && count<n){\n                if (temp.containsKey(ch[r]) && temp.get(ch[r])>0 ){\n                    count++;\n                    temp.put(ch[r], temp.get(ch[r])+1);\n                }\n                // System.out.println(l+\" \"+r+\" \"+count);\n                if (count == n){\n                    int v = r-l + 1;\n                    if (v < min) {\n                        min = v;\n                        min_l = l;\n                        min_r = r;\n                    }\n                }\n                r++;\n\n            }\n            l = r + 1;\n            \n        }\n        StringBuilder re = new StringBuilder();\n        if (min == Integer.MAX_VALUE) return \"\";\n        for (int i = min_l;i<=min_r;i++){\n            re.append(s.charAt(i));\n        }\n\n        return re.toString();\n\n    }\n}","runtime":"N/A","title":"Minimum Window Substring","url":"/submissions/detail/1080281548/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1080281548,"time":"3 months, 1 week","lang":"java","title_slug":"minimum-window-substring","timestamp":1697852601,"status":15,"is_pending":"Not Pending","compare_result":"111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"},{"status_display":"Runtime Error","memory":"N/A","code":"class Solution {\n    public String minWindow(String s, String t) {\n        HashMap<Character, Integer> m = new HashMap<>();\n        for (Character c: t.toCharArray()){\n            m.put(c,m.getOrDefault(c,0)+1);\n        }\n        int l = 0;\n        int r = 0;\n        char [] ch = s.toCharArray();\n        int n = t.length();\n        HashMap<Character, Integer> temp = new HashMap<>(m);\n        int min = Integer.MAX_VALUE;\n        int min_l = -1;\n        int min_r = -1;\n        int count = 0;\n        while (l<s.length()){\n            while (!temp.containsKey(ch[l])) l++;\n            r= l;\n            count = 0;\n            while (r<s.length() && count<n){\n                if (temp.containsKey(ch[r]) && temp.get(ch[r])>0 ){\n                    count++;\n                    temp.put(ch[r], temp.get(ch[r])+1);\n                }\n                System.out.println(l+\" \"+r+\" \"+count);\n                if (count == n){\n                    int v = r-l + 1;\n                    if (v < min) {\n                        min = v;\n                        min_l = l;\n                        min_r = r;\n                    }\n                }\n                r++;\n\n            }\n            l = r + 1;\n            \n        }\n        StringBuilder re = new StringBuilder();\n        if (min == Integer.MAX_VALUE) return \"\";\n        for (int i = min_l;i<=min_r;i++){\n            re.append(s.charAt(i));\n        }\n\n        return re.toString();\n\n    }\n}","runtime":"N/A","title":"Minimum Window Substring","url":"/submissions/detail/1080281525/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1080281525,"time":"3 months, 1 week","lang":"java","title_slug":"minimum-window-substring","timestamp":1697852595,"status":15,"is_pending":"Not Pending","compare_result":"111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"},{"status_display":"Accepted","memory":"45 MB","code":"class Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        HashMap<String,Integer> map = new HashMap<>();\n        for (String si: words){\n            if (map.containsKey(si)) map.put(si,map.get(si)+1);\n            else map.put(si,1);\n        }\n        HashMap<String,Integer> temp = new HashMap<>();\n        StringBuilder sb = new StringBuilder();\n        int l = 0;\n        int r = 0;\n        int count = 0;\n        int wordLen = words[0].length();\n        int start = l;\n        List<Integer> re = new ArrayList<>();\n        while (l<s.length()){\n            boolean check = false;\n            for (String si:map.keySet()){\n                if (!temp.containsKey(si)){\n                    if (s.startsWith(si,l)){\n                        // System.out.println(si);\n                        count++;\n                        l= l + si.length();\n                        temp.put(si,1);\n                        check = true;\n                    }\n                }\n                else if (temp.get(si)<map.get(si)){\n                    if (s.startsWith(si,l)){\n                        // System.out.println(si);\n                        count++;\n                        l= l + si.length();\n                        temp.put(si,temp.get(si)+1);\n                        check = true;\n                    }\n                }\n                \n            }\n            if (!check){\n                if (count == words.length) re.add(start);\n                l = start+1;\n                start = l;\n                count = 0;\n                temp = new HashMap<>();\n            }   \n        }\n        // System.out.println(count);\n        if (count == words.length) re.add(start);\n\n        return re;\n    }\n}","runtime":"2346 ms","title":"Substring with Concatenation of All Words","url":"/submissions/detail/1080272298/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1080272298,"time":"3 months, 1 week","lang":"java","title_slug":"substring-with-concatenation-of-all-words","timestamp":1697850613,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"45 MB","code":"class Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        HashMap<String,Integer> map = new HashMap<>();\n        for (String si: words){\n            if (map.containsKey(si)) map.put(si,map.get(si)+1);\n            else map.put(si,1);\n        }\n        HashMap<String,Integer> temp = new HashMap<>();\n        StringBuilder sb = new StringBuilder();\n        int l = 0;\n        int r = 0;\n        int count = 0;\n        int wordLen = words[0].length();\n        int start = l;\n        List<Integer> re = new ArrayList<>();\n        while (l<s.length()){\n            boolean check = false;\n            for (String si:map.keySet()){\n                if (!temp.containsKey(si)){\n                    if (s.startsWith(si,l)){\n                        // System.out.println(si);\n                        count++;\n                        l= l + si.length();\n                        temp.put(si,1);\n                        check = true;\n                    }\n                }\n                else if (temp.get(si)<map.get(si)){\n                    if (s.startsWith(si,l)){\n                        // System.out.println(si);\n                        count++;\n                        l= l + si.length();\n                        temp.put(si,temp.get(si)+1);\n                        check = true;\n                    }\n                }\n                \n            }\n            if (!check){\n                if (count == words.length) re.add(start);\n                l = start+1;\n                start = l;\n                count = 0;\n                temp.clear();\n            }   \n        }\n        // System.out.println(count);\n        if (count == words.length) re.add(start);\n\n        return re;\n    }\n}","runtime":"2277 ms","title":"Substring with Concatenation of All Words","url":"/submissions/detail/1080272159/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1080272159,"time":"3 months, 1 week","lang":"java","title_slug":"substring-with-concatenation-of-all-words","timestamp":1697850587,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"45 MB","code":"class Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        HashMap<String,Integer> map = new HashMap<>();\n        for (String si: words){\n            if (map.containsKey(si)) map.put(si,map.get(si)+1);\n            else map.put(si,1);\n        }\n        HashMap<String,Integer> temp = new HashMap<>();\n        StringBuilder sb = new StringBuilder();\n        int l = 0;\n        int r = 0;\n        int count = 0;\n        int wordLen = words[0].length();\n        int start = l;\n        List<Integer> re = new ArrayList<>();\n        while (l<s.length()){\n            boolean check = false;\n            for (String si:map.keySet()){\n                if (!temp.containsKey(si)){\n                    if (s.startsWith(si,l)){\n                        // System.out.println(si);\n                        count++;\n                        l= l + si.length();\n                        temp.put(si,1);\n                        check = true;\n                    }\n                }\n                else if (temp.get(si)<map.get(si)){\n                    if (s.startsWith(si,l)){\n                        // System.out.println(si);\n                        count++;\n                        l= l + si.length();\n                        temp.put(si,temp.get(si)+1);\n                        check = true;\n                    }\n                }\n                \n            }\n            if (!check){\n                if (count == words.length) re.add(start);\n                l = start+1;\n                start = l;\n                count = 0;\n                temp.clear();\n            }   \n        }\n        // System.out.println(count);\n        if (count == words.length) re.add(start);\n\n        return re;\n    }\n}","runtime":"2275 ms","title":"Substring with Concatenation of All Words","url":"/submissions/detail/1080272096/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1080272096,"time":"3 months, 1 week","lang":"java","title_slug":"substring-with-concatenation-of-all-words","timestamp":1697850574,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"45 MB","code":"class Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        HashMap<String,Integer> map = new HashMap<>();\n        for (String si: words){\n            if (map.containsKey(si)) map.put(si,map.get(si)+1);\n            else map.put(si,1);\n        }\n        HashMap<String,Integer> temp = new HashMap<>(map);\n        StringBuilder sb = new StringBuilder();\n        int l = 0;\n        int r = 0;\n        int count = 0;\n        int wordLen = words[0].length();\n        int start = l;\n        List<Integer> re = new ArrayList<>();\n        while (l<s.length()){\n            boolean check = false;\n            for (String si:map.keySet()){\n                if (map.get(si)>0){\n                    if (s.startsWith(si,l)){\n                        // System.out.println(si);\n                        count++;\n                        l= l + si.length();\n                        map.put(si,map.get(si)-1);\n                        check = true;\n                    }\n                }\n            }\n            if (!check){\n                if (count == words.length) re.add(start);\n                l = start+1;\n                start = l;\n                count = 0;\n                map = new HashMap<>(temp);\n            }   \n        }\n        // System.out.println(count);\n        if (count == words.length) re.add(start);\n\n        return re;\n    }\n}","runtime":"1959 ms","title":"Substring with Concatenation of All Words","url":"/submissions/detail/1080245817/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1080245817,"time":"3 months, 1 week","lang":"java","title_slug":"substring-with-concatenation-of-all-words","timestamp":1697845047,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Time Limit Exceeded","memory":"N/A","code":"class Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        HashMap<String,Integer> map = new HashMap<>();\n        for (String si: words){\n            if (map.containsKey(si)) map.put(si,map.get(si)+1);\n            else map.put(si,1);\n        }\n        HashMap<String,Integer> temp = new HashMap<>(map);\n        StringBuilder sb = new StringBuilder();\n        int l = 0;\n        int r = 0;\n        int count = 0;\n        int wordLen = words[0].length();\n        int start = l;\n        List<Integer> re = new ArrayList<>();\n        while (l<s.length()){\n            boolean check = false;\n            for (String si:map.keySet()){\n                if (map.get(si)>0){\n                    if (s.startsWith(si,l)){\n                        System.out.println(si);\n                        count++;\n                        l= l + si.length();\n                        map.put(si,map.get(si)-1);\n                        check = true;\n                    }\n                }\n            }\n            if (!check){\n                if (count == words.length) re.add(start);\n                l = start+1;\n                start = l;\n                count = 0;\n                map = new HashMap<>(temp);\n            }   \n        }\n        System.out.println(count);\n        if (count == words.length) re.add(start);\n\n        return re;\n    }\n}","runtime":"N/A","title":"Substring with Concatenation of All Words","url":"/submissions/detail/1080245566/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1080245566,"time":"3 months, 1 week","lang":"java","title_slug":"substring-with-concatenation-of-all-words","timestamp":1697844995,"status":14,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        HashMap<String,Integer> map = new HashMap<>();\n        for (String si: words){\n            if (map.containsKey(si)) map.put(si,map.get(si)+1);\n            else map.put(si,1);\n        }\n        HashMap<String,Integer> temp = new HashMap<>(map);\n        StringBuilder sb = new StringBuilder();\n        int l = 0;\n        int r = 0;\n        int count = 0;\n        int wordLen = words[0].length();\n        int start = l;\n        List<Integer> re = new ArrayList<>();\n        while (l<s.length()){\n            boolean check = false;\n            for (String si:map.keySet()){\n                if (map.get(si)>0){\n                    if (s.startsWith(si,l)){\n                        System.out.println(si);\n                        count++;\n                        l= l + si.length();\n                        map.put(si,map.get(si)-1);\n                        check = true;\n                    }\n                }\n            }\n            if (!check){\n                if (count == words.length) re.add(start);\n                l = start+wordLen;\n                start = l;\n                count = 0;\n                map = new HashMap<>(temp);\n            }   \n        }\n        System.out.println(count);\n        if (count == words.length) re.add(start);\n\n        return re;\n    }\n}","runtime":"N/A","title":"Substring with Concatenation of All Words","url":"/submissions/detail/1080245094/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1080245094,"time":"3 months, 1 week","lang":"java","title_slug":"substring-with-concatenation-of-all-words","timestamp":1697844893,"status":11,"is_pending":"Not Pending","compare_result":"11110111110110111100111110010011010001111011100110110001111110111011110100000011111001000111110001101101110010110011010101010000010010000001000000100000000000000000000000000011010"},{"status_display":"Accepted","memory":"52.4 MB","code":"class Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        Set<List<Integer>> a = new HashSet<>();\n        int zeros = 0;\n        ArrayList<Integer> pos = new ArrayList<>();\n        ArrayList<Integer> neg = new ArrayList<>();\n        HashSet<Integer> posSet = new HashSet<>();\n        HashSet<Integer> negSet = new HashSet<>();\n        for (int i : nums){\n            if (i ==0) zeros++;\n            if (i>0) {\n                pos.add(i);\n                posSet.add(i);\n            }\n            if (i<0){\n                neg.add(i);\n                negSet.add(i);\n            }\n        }\n        List<List<Integer>> re = new ArrayList<>();\n        if (zeros >=3) a.add(Arrays.asList(0,0,0));\n        if (zeros >0 ){\n            for (int i: posSet){\n                if (negSet.contains(-i)){\n                    a.add(Arrays.asList(-i,0,i));\n                }\n            }\n        }\n        //2 pos\n        for (int i = 0; i<pos.size()-1;i++){\n            for (int j = i+1;j<pos.size();j++){\n                if ( negSet.contains( -1 *(pos.get(i)+pos.get(j) ) ) )  {\n                    List<Integer> temp = Arrays.asList(-1 * (pos.get(i)+pos.get(j)), pos.get(i),pos.get(j));\n                    Collections.sort(temp);\n                    a.add(temp);\n                }\n            }\n        }\n        \n        // 2 neg\n        for (int i = 0 ;i<neg.size()-1;i++){\n            for (int j = i+1; j<neg.size();j++){\n                if (posSet.contains( -1 * (neg.get(i)+neg.get(j)) )){\n                    List<Integer> temp = Arrays.asList(neg.get(i),neg.get(j),-1 * (neg.get(i)+neg.get(j)));\n                    Collections.sort(temp);\n                    a.add(temp);\n                }\n            }\n        }       \n        re.addAll(a);\n\n        return re;\n        \n    }\n}\n\n","runtime":"119 ms","title":"3Sum","url":"/submissions/detail/1080218693/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1080218693,"time":"3 months, 1 week","lang":"java","title_slug":"3sum","timestamp":1697840016,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"53.4 MB","code":"class Solution {\n    public int minSubArrayLen(int target, int[] nums) {\n        int l = 0;\n        int r = -1;\n        int n = nums.length;\n        int sum = 0;\n        int min = Integer.MAX_VALUE;\n        while (true ){\n            if (sum<target){\n                r++;\n                if (r>=n) break;\n                sum = sum+nums[r];\n            } else{\n                if (r-l + 1 < min) min = r-l+1;\n                if (l>=n) break;\n                sum = sum - nums[l];\n                l++;\n            }\n            // System.out.println(l +\" \" + r +\" \"+ sum +\" \" + min);\n\n        }\n        return min==Integer.MAX_VALUE?0:min;\n        \n    }\n}","runtime":"1 ms","title":"Minimum Size Subarray Sum","url":"/submissions/detail/1079726575/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1079726575,"time":"3 months, 1 week","lang":"java","title_slug":"minimum-size-subarray-sum","timestamp":1697782357,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111"}],"has_next":true,"last_key":"%7B%22pk%22%3A%20%7B%22N%22%3A%20%221079726575%22%7D%2C%20%22dt%22%3A%20%7B%22S%22%3A%20%222023-10-20T06%3A12%3A37.349906%2B0000%22%7D%2C%20%22sid%22%3A%20%7B%22N%22%3A%20%227573785%22%7D%7D"}
2024-01-26 23:38:47.036 [main] DEBUG submission_dump - {"submissions_dump":[{"status_display":"Accepted","memory":"56.2 MB","code":"class Solution {\n    public int minSubArrayLen(int target, int[] nums) {\n        int l = 0;\n        int r = -1;\n        int n = nums.length;\n        int sum = 0;\n        int min = Integer.MAX_VALUE;\n        while (true ){\n            if (sum<target){\n                r++;\n                if (r>=n) break;\n                sum = sum+nums[r];\n            } else{\n                if (r-l + 1 < min) min = r-l+1;\n                if (l>=n) break;\n                sum = sum - nums[l];\n                l++;\n            }\n            System.out.println(l +\" \" + r +\" \"+ sum +\" \" + min);\n\n        }\n        return min==Integer.MAX_VALUE?0:min;\n        \n    }\n}","runtime":"356 ms","title":"Minimum Size Subarray Sum","url":"/submissions/detail/1079726461/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1079726461,"time":"3 months, 1 week","lang":"java","title_slug":"minimum-size-subarray-sum","timestamp":1697782345,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int minSubArrayLen(int target, int[] nums) {\n        Arrays.sort(nums);\n        int n = nums.length;\n        int sum = 0;\n        int count = 0;\n        for (int i = n-1;i>=0;i-- ){\n            count++;\n            sum = sum + nums[i];\n            if (sum >= target) return count;\n        }\n        return 0;\n        \n    }\n}","runtime":"N/A","title":"Minimum Size Subarray Sum","url":"/submissions/detail/1079712714/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1079712714,"time":"3 months, 1 week","lang":"java","title_slug":"minimum-size-subarray-sum","timestamp":1697780900,"status":11,"is_pending":"Not Pending","compare_result":"111111110111111110011"},{"status_display":"Accepted","memory":"52.3 MB","code":"class Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        Set<List<Integer>> a = new HashSet<>();\n        int zeros = 0;\n        ArrayList<Integer> pos = new ArrayList<>();\n        ArrayList<Integer> neg = new ArrayList<>();\n        HashSet<Integer> posSet = new HashSet<>();\n        HashSet<Integer> negSet = new HashSet<>();\n        for (int i : nums){\n            if (i ==0) zeros++;\n            if (i>0) {\n                pos.add(i);\n                posSet.add(i);\n            }\n            if (i<0){\n                neg.add(i);\n                negSet.add(i);\n            }\n        }\n        List<List<Integer>> re = new ArrayList<>();\n        if (zeros >=3) a.add(Arrays.asList(0,0,0));\n        if (zeros >0 ){\n            for (int i: posSet){\n                if (negSet.contains(-i)){\n                    a.add(Arrays.asList(-i,0,i));\n                }\n            }\n        }\n        //2 pos\n        for (int i = 0; i<pos.size()-1;i++){\n            for (int j = i+1;j<pos.size();j++){\n                if ( negSet.contains( -1 *(pos.get(i)+pos.get(j) ) ) )  {\n                    List<Integer> temp = Arrays.asList(-1 * (pos.get(i)+pos.get(j)), pos.get(i),pos.get(j));\n                    Collections.sort(temp);\n                    a.add(temp);\n                }\n            }\n        }\n        \n        // 2 neg\n        for (int i = 0 ;i<neg.size()-1;i++){\n            for (int j = i+1; j<neg.size();j++){\n                if (posSet.contains( -1 * (neg.get(i)+neg.get(j)) )){\n                    List<Integer> temp = Arrays.asList(neg.get(i),neg.get(j),-1 * (neg.get(i)+neg.get(j)));\n                    Collections.sort(temp);\n                    a.add(temp);\n                }\n            }\n        }       \n        re.addAll(a);\n\n        return re;\n        \n    }\n}\n\n","runtime":"119 ms","title":"3Sum","url":"/submissions/detail/1079701921/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1079701921,"time":"3 months, 1 week","lang":"java","title_slug":"3sum","timestamp":1697779694,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        List<List<Integer>> a = new ArrayList<>();\n        int zeros = 0;\n        ArrayList<Integer> pos = new ArrayList<>();\n        ArrayList<Integer> neg = new ArrayList<>();\n        HashSet<Integer> posSet = new HashSet<>();\n        HashSet<Integer> negSet = new HashSet<>();\n        for (int i : nums){\n            if (i ==0) zeros++;\n            if (i>0) {\n                pos.add(i);\n                posSet.add(i);\n            }\n            if (i<0){\n                neg.add(i);\n                negSet.add(i);\n            }\n        }\n        if (zeros >=3) a.add(Arrays.asList(0,0,0));\n        if (zeros >0 ){\n            for (int i: posSet){\n                if (negSet.contains(-i)){\n                    a.add(Arrays.asList(-i,0,i));\n                }\n            }\n        }\n        //2 pos\n        for (int i = 0; i<pos.size()-1;i++){\n            for (int j = i+1;j<pos.size();j++){\n                if ( negSet.contains( -1 *(pos.get(i)+pos.get(j) ) ) )  {\n                    a.add(Arrays.asList(-1 * (pos.get(i)+pos.get(j)), pos.get(i),pos.get(j)));\n                }\n            }\n        }\n        \n        // 2 neg\n        for (int i = 0 ;i<neg.size()-1;i++){\n            for (int j = i+1; j<neg.size();j++){\n                if (posSet.contains( -1 * (neg.get(i)+neg.get(j)) )){\n                    a.add(Arrays.asList(neg.get(i),neg.get(j),-1 * (neg.get(i)+neg.get(j))));\n                }\n            }\n        }       \n\n        return a;\n        \n    }\n}","runtime":"N/A","title":"3Sum","url":"/submissions/detail/1079696292/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1079696292,"time":"3 months, 1 week","lang":"java","title_slug":"3sum","timestamp":1697779062,"status":11,"is_pending":"Not Pending","compare_result":"111111111111111111111010011100011010111101001101010000000000111001000110011100011101100000000110101000100100000001111000011000000000000000000000000000000000000011000000000000000000000000001000000000000000000001011100000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000110"},{"status_display":"Accepted","memory":"40.6 MB","code":"class Solution {\n    public List<String> summaryRanges(int[] nums) {\n        int start = 0;\n        int pointer = 1;\n        // int prev = 0;\n        int n = nums.length;\n        int end = -1;\n        ArrayList<String> re = new ArrayList<>();\n        if (n == 0) return re;\n\n        while (pointer<n){\n            if ( nums[pointer] != nums[pointer -1 ] + 1 ){\n                if (start == pointer-1){\n                    re.add(\"\"+nums[start]);\n                } else{\n                    re.add(nums[start]+\"->\"+nums[pointer-1]);\n                }\n                start = pointer;\n            } \n            pointer++;\n        }\n        if (start == pointer-1){\n            re.add(\"\"+nums[start]);\n        } else{\n            re.add(nums[start]+\"->\"+nums[pointer-1]);\n        }\n        return re;\n    }\n}","runtime":"5 ms","title":"Summary Ranges","url":"/submissions/detail/1079008434/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1079008434,"time":"3 months, 1 week","lang":"java","title_slug":"summary-ranges","timestamp":1697701229,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111"},{"status_display":"Runtime Error","memory":"N/A","code":"class Solution {\n    public List<String> summaryRanges(int[] nums) {\n        int start = 0;\n        int pointer = 1;\n        // int prev = 0;\n        int n = nums.length;\n        int end = -1;\n        ArrayList<String> re = new ArrayList<>();\n        while (pointer<n){\n            if ( nums[pointer] != nums[pointer -1 ] + 1 ){\n                if (start == pointer-1){\n                    re.add(\"\"+nums[start]);\n                } else{\n                    re.add(nums[start]+\"->\"+nums[pointer-1]);\n                }\n                start = pointer;\n            } \n            pointer++;\n        }\n        if (start == pointer-1){\n            re.add(\"\"+nums[start]);\n        } else{\n            re.add(nums[start]+\"->\"+nums[pointer-1]);\n        }\n        return re;\n    }\n}","runtime":"N/A","title":"Summary Ranges","url":"/submissions/detail/1079008119/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1079008119,"time":"3 months, 1 week","lang":"java","title_slug":"summary-ranges","timestamp":1697701197,"status":15,"is_pending":"Not Pending","compare_result":"11000000000000000000000000000000"},{"status_display":"Accepted","memory":"55 MB","code":"class Solution {\n    public int maxArea(int[] height) {\n        int max = 0;\n        int n = height.length;\n        int l= 0;\n        int r = n-1;\n        while (l<r){\n            int val = Integer.min(height[l],height[r]) * (r-l);\n            if (val > max) max = val;\n            if (height[l]<height[r]) l++;\n            else r--;\n        }\n        return max;\n    }\n}","runtime":"4 ms","title":"Container With Most Water","url":"/submissions/detail/1078092930/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1078092930,"time":"3 months, 1 week","lang":"java","title_slug":"container-with-most-water","timestamp":1697605207,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Time Limit Exceeded","memory":"N/A","code":"class Solution {\n    public int maxArea(int[] height) {\n        int max = 0;\n        int n = height.length;\n        for (int i = 0;i<n-1;i++){\n            for (int j= i+1; j<n;j++){\n                int val= Integer.min(height[i],height[j]) * (j-i);\n                if (val >max) max = val;\n            }\n        }\n        return max;\n    }\n}","runtime":"N/A","title":"Container With Most Water","url":"/submissions/detail/1078090155/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1078090155,"time":"3 months, 1 week","lang":"java","title_slug":"container-with-most-water","timestamp":1697604923,"status":14,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111100000"},{"status_display":"Accepted","memory":"45.2 MB","code":"class Solution {\n    public int[] twoSum(int[] numbers, int target) {\n        int l = 0;\n        int r = numbers.length-1;\n        while(numbers[l]+numbers[r]!=target){\n            if (numbers[l]+numbers[r]> target) \n                r--;\n            else \n                l++;\n        }\n        int [] re = {l+1,r+1};\n        return re;\n        \n    }\n}","runtime":"2 ms","title":"Two Sum II - Input Array Is Sorted","url":"/submissions/detail/1078072802/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1078072802,"time":"3 months, 1 week","lang":"java","title_slug":"two-sum-ii-input-array-is-sorted","timestamp":1697603101,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111"},{"status_display":"Accepted","memory":"40.4 MB","code":"class Solution {\n    public boolean isSubsequence(String s, String t) {\n        int p1 = 0;\n        int p2 = 0;\n        while (p1<s.length() && p2<t.length()){\n            if (s.charAt(p1)==t.charAt(p2)){\n                p1++;\n                p2++;\n            } else{\n                p2++;\n            }\n        }\n        return p1>(s.length()-1);\n\n    }\n}","runtime":"1 ms","title":"Is Subsequence","url":"/submissions/detail/1078058309/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1078058309,"time":"3 months, 1 week","lang":"java","title_slug":"is-subsequence","timestamp":1697601594,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111"},{"status_display":"Accepted","memory":"41.7 MB","code":"class Solution {\n    public List<String> fullJustify(String[] words, int maxWidth) {\n        List<String> re = new ArrayList<>();\n        Queue<String> q = new LinkedList<>();\n        int count = 0;\n        int c = -1;\n        for (int i=0;i<words.length;i++){\n            count = count + words[i].length();\n            c++;\n            if (count+c<=maxWidth){\n                q.add(words[i]);\n            } else{\n                String s = \"\";\n                String sp = \"\";\n                String sp1 = \"\";\n\n                count = count - words[i].length();\n                int numspace;\n                int tempcount = 0;\n                if (q.size() == 1) {\n                    numspace = maxWidth - count;\n                    tempcount = 0;\n                } else{\n                    numspace = (maxWidth - count) /(q.size() -1);\n                    tempcount = (maxWidth - count) % (q.size() -1);\n                }\n                \n                while (sp.length()<numspace) sp=sp+\" \";\n                while (sp1.length()<numspace+1) sp1=sp1+\" \";\n                System.out.println(tempcount + \" \"+ numspace);\n                if (q.size() > 1)\n                {\n                    while (q.size()>1){\n                    if (tempcount > 0){\n                        s= s+ q.poll() + sp1;\n                    }\n                    else{\n                        s= s+ q.poll() + sp;\n                    }\n                    tempcount--;\n                    }\n                    if (q.size()==1)\n                    {\n                        s= s+q.poll();\n                    }\n                } else{\n                    s= s+q.poll();\n                    while (s.length()<maxWidth){\n                        s= s+\" \";\n                    }\n\n                }\n                \n                re.add(s);\n                q.add(words[i]);\n\n                count = 0;\n                c= -1;\n                count = count + words[i].length();\n                c++;\n            }\n        }\n        String s = \"\";\n        while (!q.isEmpty()){\n            s = s + q.poll() +\" \";\n        }\n        s = s.substring(0,s.length()-1);\n        while (s.length()<maxWidth){\n            s= s+\" \";\n        }\n\n        re.add(s);\n        for (String i:re){\n            System.out.println(i);\n        }\n        System.out.println(re.get(0).length());\n\n        return re;\n        \n    }\n}\n","runtime":"18 ms","title":"Text Justification","url":"/submissions/detail/1078005534/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1078005534,"time":"3 months, 1 week","lang":"java","title_slug":"text-justification","timestamp":1697595467,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public List<String> fullJustify(String[] words, int maxWidth) {\n        List<String> re = new ArrayList<>();\n        Queue<String> q = new LinkedList<>();\n        int count = 0;\n        int c = -1;\n        for (int i=0;i<words.length;i++){\n            count = count + words[i].length();\n            c++;\n            if (count+c<=maxWidth){\n                q.add(words[i]);\n            } else{\n                String s = \"\";\n                String sp = \"\";\n                count = count - words[i].length();\n                int numspace1;\n                int numspace;\n                if (q.size() == 1) {\n                    numspace = maxWidth - count;\n                    numspace1 = numspace;\n                } else{\n                    numspace = (maxWidth - count) /(q.size() -1);\n                    numspace1 = numspace + (maxWidth - count) % (q.size() -1);\n                }\n                \n                while (sp.length()<numspace1) sp=sp+\" \";\n                s = q.poll() + sp;\n                sp = \"\";\n                while (sp.length()<numspace) sp=sp+\" \";\n                while (q.size()>1){\n                    s= s+ q.poll() + sp;\n                }\n                if (q.size()==1)\n                {\n                    s= s+q.poll();\n                }\n                re.add(s);\n                q.add(words[i]);\n\n                count = 0;\n                c= -1;\n                count = count + words[i].length();\n                c++;\n            }\n        }\n        String s = \"\";\n        while (!q.isEmpty()){\n            s = s + q.poll() +\" \";\n        }\n        s = s.substring(0,s.length()-1);\n        while (s.length()<maxWidth){\n            s= s+\" \";\n        }\n\n        re.add(s);\n        for (String i:re){\n            System.out.println(i);\n        }\n        System.out.println(re.get(0).length());\n\n        return re;\n        \n    }\n}","runtime":"N/A","title":"Text Justification","url":"/submissions/detail/1077962591/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1077962591,"time":"3 months, 1 week","lang":"java","title_slug":"text-justification","timestamp":1697589329,"status":11,"is_pending":"Not Pending","compare_result":"11000111111111111110100100011"},{"status_display":"Accepted","memory":"40.2 MB","code":"class Solution {\n    public int strStr(String haystack, String needle) {\n        return haystack.indexOf(needle);\n    }\n}","runtime":"0 ms","title":"Find the Index of the First Occurrence in a String","url":"/submissions/detail/1077930590/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1077930590,"time":"3 months, 1 week","lang":"java","title_slug":"find-the-index-of-the-first-occurrence-in-a-string","timestamp":1697584485,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"40.8 MB","code":"class Solution {\n    public int strStr(String haystack, String needle) {\n        return haystack.indexOf(needle);\n    }\n}","runtime":"0 ms","title":"Find the Index of the First Occurrence in a String","url":"/submissions/detail/1077930522/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1077930522,"time":"3 months, 1 week","lang":"java","title_slug":"find-the-index-of-the-first-occurrence-in-a-string","timestamp":1697584475,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"44.5 MB","code":"class Solution {\n    public String convert(String s, int numRows) {\n        StringBuilder[] st = new StringBuilder[numRows];\n        for (int i = 0;i<numRows;i++) st[i] = new StringBuilder();\n        int count = 0;\n        main:\n        while (count<s.length()){\n            for (int i = 0;i< numRows;i++){\n                if (count >=s.length() ) break main;\n                st[i].append(s.charAt(count));\n                count++;\n            }\n            for (int i = numRows - 2 ; i>=1; i--){\n                if (count >=s.length() ) break main;\n                st[i].append(s.charAt(count));\n                count++;\n            }\n        }\n        StringBuilder re = new StringBuilder();\n        for (StringBuilder si:st){\n            re.append( si.toString() );\n        }\n        return re.toString();\n        \n    }\n}","runtime":"4 ms","title":"Zigzag Conversion","url":"/submissions/detail/1077929824/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1077929824,"time":"3 months, 1 week","lang":"java","title_slug":"zigzag-conversion","timestamp":1697584370,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"44.6 MB","code":"class Solution {\n    public String convert(String s, int numRows) {\n        String []st = new String[numRows];\n        Arrays.fill(st,\"\");\n        int count = 0;\n        main:\n        while (count<s.length()){\n            for (int i = 0;i< numRows;i++){\n                if (count >=s.length() ) break main;\n                st[i] = st[i] + s.charAt(count);\n                count++;\n            }\n            for (int i = numRows - 2 ; i>=1; i--){\n                if (count >=s.length() ) break main;\n                st[i] = st[i] + s.charAt(count);\n                count++;\n            }\n        }\n        String re = \"\";\n        for (String si:st){\n            re= re + si;\n        }\n        return re;\n        \n    }\n}","runtime":"14 ms","title":"Zigzag Conversion","url":"/submissions/detail/1077928086/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1077928086,"time":"3 months, 1 week","lang":"java","title_slug":"zigzag-conversion","timestamp":1697584088,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public String convert(String s, int numRows) {\n        String []st = new String[numRows];\n        // Arrays.fill(st,\"\");\n        int count = 0;\n        main:\n        while (count<s.length()){\n            for (int i = 0;i< numRows;i++){\n                if (count >=s.length() ) break main;\n                st[i] = st[i] + s.charAt(count);\n                count++;\n            }\n            for (int i = numRows - 2 ; i>=1; i--){\n                if (count >=s.length() ) break main;\n                st[i] = st[i] + s.charAt(count);\n                count++;\n            }\n        }\n        String re = \"\";\n        for (String si:st){\n            re= re + si;\n        }\n        return re;\n        \n    }\n}","runtime":"N/A","title":"Zigzag Conversion","url":"/submissions/detail/1077928047/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1077928047,"time":"3 months, 1 week","lang":"java","title_slug":"zigzag-conversion","timestamp":1697584082,"status":11,"is_pending":"Not Pending","compare_result":"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public String convert(String s, int numRows) {\n        String []st = new String[numRows];\n        // Arrays.fill(st,\"\");\n        int count = 0;\n        main:\n        while (count<s.length()){\n            for (int i = 0;i< numRows;i++){\n                if (count >=s.length() ) break main;\n                st[i] = st[i] + s.charAt(count);\n                count++;\n            }\n            for (int i = numRows - 2 ; i>=1; i--){\n                if (count >=s.length() ) break main;\n                st[i] = st[i] + s.charAt(count);\n                count++;\n            }\n        }\n        String re = \"\";\n        for (String si:st){\n            re= re + si;\n        }\n        return re;\n        \n    }\n}","runtime":"N/A","title":"Zigzag Conversion","url":"/submissions/detail/1077927996/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1077927996,"time":"3 months, 1 week","lang":"java","title_slug":"zigzag-conversion","timestamp":1697584073,"status":11,"is_pending":"Not Pending","compare_result":"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"},{"status_display":"Accepted","memory":"44.3 MB","code":"class Solution {\n    public String convert(String s, int numRows) {\n        String []st = new String[numRows];\n        Arrays.fill(st,\"\");\n        int count = 0;\n        main:\n        while (count<s.length()){\n            for (int i = 0;i< numRows;i++){\n                if (count >=s.length() ) break main;\n                st[i] = st[i] + s.charAt(count);\n                count++;\n            }\n            for (int i = numRows - 2 ; i>=1; i--){\n                if (count >=s.length() ) break main;\n                st[i] = st[i] + s.charAt(count);\n                count++;\n            }\n        }\n        String re = \"\";\n        for (String si:st){\n            re= re + si;\n        }\n        return re;\n        \n    }\n}","runtime":"14 ms","title":"Zigzag Conversion","url":"/submissions/detail/1077927917/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1077927917,"time":"3 months, 1 week","lang":"java","title_slug":"zigzag-conversion","timestamp":1697584063,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"43.9 MB","code":"class Solution {\n    public String reverseWords(String s) {\n        String [] temp = s.split(\"\\\\s+\");\n        StringBuilder sb = new StringBuilder();\n        for (int i = temp.length-1; i>=0;i--){\n            // System.out.println(temp[i]);\n            sb.append(temp[i] + \" \");\n        }\n        return sb.toString().trim();\n        \n    }\n}","runtime":"8 ms","title":"Reverse Words in a String","url":"/submissions/detail/1077923764/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1077923764,"time":"3 months, 1 week","lang":"java","title_slug":"reverse-words-in-a-string","timestamp":1697583427,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111"}],"has_next":true,"last_key":"%7B%22pk%22%3A%20%7B%22N%22%3A%20%221077923764%22%7D%2C%20%22dt%22%3A%20%7B%22S%22%3A%20%222023-10-17T22%3A57%3A07.623057%2B0000%22%7D%2C%20%22sid%22%3A%20%7B%22N%22%3A%20%227573785%22%7D%7D"}
2024-01-26 23:38:57.553 [main] DEBUG submission_dump - {"submissions_dump":[{"status_display":"Accepted","memory":"43.7 MB","code":"class Solution {\n    public String reverseWords(String s) {\n        String [] temp = s.split(\"\\\\s+\");\n        StringBuilder sb = new StringBuilder();\n        for (int i = temp.length-1; i>=0;i--){\n            System.out.println(temp[i]);\n            sb.append(temp[i] + \" \");\n        }\n        return sb.toString().trim();\n        \n    }\n}","runtime":"21 ms","title":"Reverse Words in a String","url":"/submissions/detail/1077923727/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1077923727,"time":"3 months, 1 week","lang":"java","title_slug":"reverse-words-in-a-string","timestamp":1697583421,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"40.3 MB","code":"class Solution {\n    public String longestCommonPrefix(String[] strs) {\n        int count = 0;\n        boolean check = true;\n        while (check){\n            if (count>=strs[0].length()) break;\n            char temp = strs[0].charAt(count);\n            for (String st: strs){\n\n                if ( count>=st.length() || st.charAt(count)!=temp){\n                    check = false;\n                    break;\n                }\n            }\n            if (!check) break;\n            count++;\n        }\n        System.out.println(count);\n        return strs[0].substring(0,count);\n    }\n}","runtime":"2 ms","title":"Longest Common Prefix","url":"/submissions/detail/1077913294/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1077913294,"time":"3 months, 1 week","lang":"java","title_slug":"longest-common-prefix","timestamp":1697581877,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"40.7 MB","code":"class Solution {\n    public int lengthOfLastWord(String s) {\n        String [] temp = s.split(\" \");\n        return temp[temp.length-1].length();\n    }\n}","runtime":"1 ms","title":"Length of Last Word","url":"/submissions/detail/1077908823/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1077908823,"time":"3 months, 1 week","lang":"java","title_slug":"length-of-last-word","timestamp":1697581260,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"43.2 MB","code":"class Solution {\n    public String intToRoman(int num) {\n        StringBuilder sb = new StringBuilder();\n        while(  num>=1000){\n            num = num - 1000;\n            sb.append(\"M\");\n        }\n\n        if (num >=900) {\n            num = num - 900;\n            sb.append(\"CM\");\n        }\n        if (num >=500) {\n            num = num - 500;\n            sb.append(\"D\");\n        }\n        if (num >=400) {\n            num = num - 400;\n            sb.append(\"CD\");\n        }\n        while (num >=100){\n            num = num-100;\n            sb.append(\"C\");\n        }\n\n        if (num >=90) {\n            num = num - 90;\n            sb.append(\"XC\");\n        }\n        if (num >=50) {\n            num = num - 50;\n            sb.append(\"L\");\n        }\n        if (num >=40) {\n            num = num - 40;\n            sb.append(\"XL\");\n        }\n        while (num >=10){\n            num = num-10;\n            sb.append(\"X\");\n        }\n\n        if (num >=9) {\n            num = num - 9;\n            sb.append(\"IX\");\n        }\n        if (num >=5) {\n            num = num - 5;\n            sb.append(\"V\");\n        }\n        if (num >=4) {\n            num = num - 4;\n            sb.append(\"IV\");\n        }\n        while (num >=1){\n            num = num-1;\n            sb.append(\"I\");\n        }\n        return sb.toString();\n        \n    }\n}","runtime":"2 ms","title":"Integer to Roman","url":"/submissions/detail/1077907368/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1077907368,"time":"3 months, 1 week","lang":"java","title_slug":"integer-to-roman","timestamp":1697581058,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public String intToRoman(int num) {\n        StringBuilder sb = new StringBuilder();\n        while(  num>=1000){\n            num = num - 1000;\n            sb.append(\"M\");\n        }\n\n        if (num >=900) {\n            num = num - 900;\n            sb.append(\"CM\");\n        }\n        if (num >=500) {\n            num = num - 900;\n            sb.append(\"D\");\n        }\n        if (num >=400) {\n            num = num - 400;\n            sb.append(\"CD\");\n        }\n        while (num >=100){\n            num = num-100;\n            sb.append(\"C\");\n        }\n\n        if (num >=90) {\n            num = num - 90;\n            sb.append(\"XC\");\n        }\n        if (num >=50) {\n            num = num - 50;\n            sb.append(\"L\");\n        }\n        if (num >=40) {\n            num = num - 40;\n            sb.append(\"XL\");\n        }\n        while (num >=10){\n            num = num-10;\n            sb.append(\"X\");\n        }\n\n        if (num >=9) {\n            num = num - 9;\n            sb.append(\"IX\");\n        }\n        if (num >=5) {\n            num = num - 5;\n            sb.append(\"V\");\n        }\n        if (num >=4) {\n            num = num - 4;\n            sb.append(\"IV\");\n        }\n        while (num >=1){\n            num = num-1;\n            sb.append(\"I\");\n        }\n        return sb.toString();\n        \n    }\n}","runtime":"N/A","title":"Integer to Roman","url":"/submissions/detail/1077907232/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1077907232,"time":"3 months, 1 week","lang":"java","title_slug":"integer-to-roman","timestamp":1697581042,"status":11,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public String intToRoman(int num) {\n        StringBuilder sb = new StringBuilder();\n        while(  num>=1000){\n            num = num - 1000;\n            sb.append(\"M\");\n        }\n\n        if (num >=900) {\n            num = num - 900;\n            sb.append(\"CM\");\n        }\n        if (num >=500) {\n            num = num - 900;\n            sb.append(\"D\");\n        }\n        if (num >=400) {\n            num = num - 400;\n            sb.append(\"CD\");\n        }\n        while (num >=100){\n            num = num-100;\n            sb.append(\"C\");\n        }\n\n        if (num >=90) {\n            num = num - 90;\n            sb.append(\"XC\");\n        }\n        if (num >=50) {\n            num = num - 50;\n            sb.append(\"L\");\n        }\n        if (num >=40) {\n            num = num - 400;\n            sb.append(\"XL\");\n        }\n        while (num >=10){\n            num = num-10;\n            sb.append(\"X\");\n        }\n\n        if (num >=9) {\n            num = num - 9;\n            sb.append(\"IX\");\n        }\n        if (num >=5) {\n            num = num - 5;\n            sb.append(\"V\");\n        }\n        if (num >=4) {\n            num = num - 4;\n            sb.append(\"IV\");\n        }\n        while (num >=1){\n            num = num-1;\n            sb.append(\"I\");\n        }\n        return sb.toString();\n        \n    }\n}","runtime":"N/A","title":"Integer to Roman","url":"/submissions/detail/1077907042/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1077907042,"time":"3 months, 1 week","lang":"java","title_slug":"integer-to-roman","timestamp":1697581017,"status":11,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000000001111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000000111111111111111111111111111111111111111111111111111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000111111111111111111111111111111111111111110000000001111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000000001111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000011111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011111111111111111111111111111111111111111000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000000001111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000011111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011111111111111111111111111111111111111111000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000000001111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000000001111111111111111111111111111111111111111111111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001111111111111111111111111111111111111111100000000011111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"44.3 MB","code":"class Solution {\n    public int trap(int[] r) {\n        int n = r.length;\n        int max = 0;\n        int sum = 0;\n        int [] left = new int[n];\n        int [] right = new int[n];\n        for (int i=0;i<n;i++){\n            if (r[i]>max){\n                max = r[i];\n                left[i] = 0;\n            } else{\n                left[i] = max- r[i];\n            }\n        }\n        max = 0;\n        for (int i=n-1;i>=0;i--){\n            if (r[i]>max){\n                max = r[i];\n                right[i] = 0;\n            }\n            else{\n                right[i] = max-r[i];\n            }\n        }\n        for (int i = 0;i<n;i++){\n            sum = sum + Integer.min(left[i],right[i]);\n        }\n        \n        return sum;\n        \n    }\n}","runtime":"1 ms","title":"Trapping Rain Water","url":"/submissions/detail/1077167694/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1077167694,"time":"3 months, 1 week","lang":"java","title_slug":"trapping-rain-water","timestamp":1697511241,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"44.4 MB","code":"class Solution {\n    public int trap(int[] r) {\n        int n = r.length;\n        int max = 0;\n        int sum = 0;\n        int [] left = new int[n];\n        int [] right = new int[n];\n        for (int i=0;i<n;i++){\n            if (r[i]>max){\n                max = r[i];\n                // temp = i;\n                left[i] = 0;\n            } else{\n                left[i] = max- r[i];\n                // sum = sum + max-r[i];\n            }\n        }\n        max = 0;\n        for (int i=n-1;i>=0;i--){\n            if (r[i]>max){\n                max = r[i];\n                right[i] = 0;\n            }\n            else{\n                right[i] = max-r[i];\n            }\n        }\n        for (int i = 0;i<n;i++){\n            // System.out.println(left[i] + \" \" + right[i]);\n            sum = sum + Integer.min(left[i],right[i]);\n        }\n        \n        return sum;\n        \n    }\n}","runtime":"1 ms","title":"Trapping Rain Water","url":"/submissions/detail/1077164357/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1077164357,"time":"3 months, 1 week","lang":"java","title_slug":"trapping-rain-water","timestamp":1697510873,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"43.7 MB","code":"class Solution {\n    public int trap(int[] r) {\n        int n = r.length;\n        int ind = 0;\n        int max = 0;\n        int sum = 0;\n        int min = Integer.MAX_VALUE;\n        int temp = -1;\n        int [] left = new int[n];\n        int [] right = new int[n];\n        for (int i=0;i<n;i++){\n            if (r[i]>max){\n                max = r[i];\n                // temp = i;\n                left[i] = 0;\n            } else{\n                left[i] = max- r[i];\n                // sum = sum + max-r[i];\n            }\n        }\n        max = 0;\n        for (int i=n-1;i>=0;i--){\n            if (r[i]>max){\n                max = r[i];\n                right[i] = 0;\n            }\n            else{\n                right[i] = max-r[i];\n            }\n        }\n        for (int i = 0;i<n;i++){\n            // System.out.println(left[i] + \" \" + right[i]);\n            sum = sum + Integer.min(left[i],right[i]);\n        }\n        \n        return sum;\n        \n    }\n}","runtime":"1 ms","title":"Trapping Rain Water","url":"/submissions/detail/1077163814/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1077163814,"time":"3 months, 1 week","lang":"java","title_slug":"trapping-rain-water","timestamp":1697510806,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"52.9 MB","code":"class Solution {\n    public int[] productExceptSelf(int[] nums) {\n        int [] re = new int [nums.length];\n        // Array.fills(1);\n        int left = 1;\n        re[0] = 1;\n        for (int i = 1;i<nums.length;i++){\n            left = left*nums[i-1];\n            re[i] = left;\n        }\n        int right = 1;\n        for (int i = nums.length-2;i>=0;i--){\n            right = right*nums[i+1];\n            re [i] = re[i]*right;\n        }\n        return re;\n    }\n}","runtime":"2 ms","title":"Product of Array Except Self","url":"/submissions/detail/1077078915/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1077078915,"time":"3 months, 1 week","lang":"java","title_slug":"product-of-array-except-self","timestamp":1697499422,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111"},{"status_display":"Accepted","memory":"92.5 MB","code":"class RandomizedSet {\n    HashMap<Integer,Integer> map;\n    ArrayList<Integer> list;\n    public RandomizedSet() {\n        map = new HashMap<>();\n        list= new ArrayList<>();\n    }\n    \n    public boolean insert(int val) {\n        if (map.containsKey(val)) return false;\n        map.put(val,list.size());\n        list.add(val);\n        return true;\n    }\n    \n    public boolean remove(int val) {\n        if (!map.containsKey(val)) return false;\n        int temp = list.remove(list.size()-1);\n        if (temp!=val){\n            list.set(map.get(val),temp);\n            map.put(temp,map.get(val));\n        }\n        map.remove(val);\n        return true;\n    }\n    \n    public int getRandom() {\n        return list.get(new Random().nextInt(list.size()));\n        \n    }\n}\n\n/**\n * Your RandomizedSet object will be instantiated and called as such:\n * RandomizedSet obj = new RandomizedSet();\n * boolean param_1 = obj.insert(val);\n * boolean param_2 = obj.remove(val);\n * int param_3 = obj.getRandom();\n */","runtime":"29 ms","title":"Insert Delete GetRandom O(1)","url":"/submissions/detail/1077076182/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1077076182,"time":"3 months, 1 week","lang":"java","title_slug":"insert-delete-getrandom-o1","timestamp":1697499004,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111"},{"status_display":"Accepted","memory":"84.9 MB","code":"class RandomizedSet {\n    HashMap<Integer,Integer> map;\n    ArrayList<Integer> list;\n    public RandomizedSet() {\n        map = new HashMap<>();\n        list= new ArrayList<>();\n    }\n    \n    public boolean insert(int val) {\n        if (map.containsKey(val)) return false;\n        map.put(val,list.size());\n        list.add(val);\n        return true;\n    }\n    \n    public boolean remove(int val) {\n        if (!map.containsKey(val)) return false;\n        int temp = list.remove(list.size()-1);\n        if (temp!=val){\n            list.set(map.get(val),temp);\n            map.put(temp,map.get(val));\n        }\n        map.remove(val);\n        return true;\n    }\n    \n    public int getRandom() {\n        return list.get(new Random().nextInt(list.size()));\n        \n    }\n}\n\n/**\n * Your RandomizedSet object will be instantiated and called as such:\n * RandomizedSet obj = new RandomizedSet();\n * boolean param_1 = obj.insert(val);\n * boolean param_2 = obj.remove(val);\n * int param_3 = obj.getRandom();\n */","runtime":"29 ms","title":"Insert Delete GetRandom O(1)","url":"/submissions/detail/1077076084/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1077076084,"time":"3 months, 1 week","lang":"java","title_slug":"insert-delete-getrandom-o1","timestamp":1697498992,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111"},{"status_display":"Accepted","memory":"44.2 MB","code":"class Solution {\n    public boolean canJump(int[] nums) {\n        int n = nums.length;\n        if (n==1) return true;\n        if (nums[0]==0) return false;\n        int max = 0;\n        for (int i=0;i<n;i++){\n            if (i>max) return false;\n            if (max<i+nums[i]) max = i+nums[i];\n        }\n        return true;\n\n        \n    }\n}","runtime":"2 ms","title":"Jump Game","url":"/submissions/detail/1077070761/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1077070761,"time":"3 months, 1 week","lang":"java","title_slug":"jump-game","timestamp":1697498205,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"43.6 MB","code":"class Solution {\n    public int maxProfit(int[] prices) {\n        int count = 0;\n        int re = 0;\n        int ind = 0;\n        int n = prices.length;\n        while (ind<n){\n            while (ind <n-1 && prices[ind]>prices[ind+1]) ind++;\n            int temp = ind;\n            if (temp == n-1) break;\n            while (ind < n-1 && prices[ind]<=prices[ind+1]) ind++;\n            re = re + prices[ind] - prices[temp];\n            if (ind == n-1) break;\n            ind++;\n        }\n\n        return re;\n    }\n}","runtime":"1 ms","title":"Best Time to Buy and Sell Stock II","url":"/submissions/detail/1077067643/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1077067643,"time":"3 months, 1 week","lang":"java","title_slug":"best-time-to-buy-and-sell-stock-ii","timestamp":1697497759,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"55.3 MB","code":"class Solution {\n    public void rotate(int[] nums, int k) {\n        k = k % nums.length;\n\t\trev(nums,0,nums.length-1);\n\t\trev(nums,0,k-1);\n\t\trev(nums,k,nums.length-1);\n    }\n    void rev(int [] nums, int x, int y) {\n\t\t\n\t\twhile (x< y) {\n\t\t\tint temp = nums[x];\n\t\t\tnums[x] = nums[y];\n\t\t\tnums[y] = temp;\n\t\t\tx ++;\n\t\t\ty --;\n\t\t}\n\t}\n}","runtime":"0 ms","title":"Rotate Array","url":"/submissions/detail/1077062343/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1077062343,"time":"3 months, 1 week","lang":"java","title_slug":"rotate-array","timestamp":1697496996,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"43.4 MB","code":"class Solution {\n    public int romanToInt(String s) {\n        char [] c = s.toCharArray();\n        HashMap<Character,Integer> m = new HashMap<>();\n        m.put('I',1);\n        m.put('V',5);\n        m.put('X',10);\n        m.put('L',50);\n        m.put('C',100);\n        m.put('D',500);\n        m.put('M',1000);\n        int n = c.length;\n        int prev = 0;\n        int sum = 0;\n        for (int i = n-1;i>=0;i--){\n            int cur = m.get(c[i]);\n            if (cur>=prev) sum = sum+m.get(c[i]);\n            else sum = sum - m.get(c[i]);\n            prev= cur; \n        }\n        return sum;\n    }\n}","runtime":"4 ms","title":"Roman to Integer","url":"/submissions/detail/1077061850/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1077061850,"time":"3 months, 1 week","lang":"java","title_slug":"roman-to-integer","timestamp":1697496929,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"44.1 MB","code":"class Solution {\n    public int removeDuplicates(int[] nums) {\n        int p1 = 0;\n        int n = nums.length;\n        int p2 = 0;\n        while (p2<n){\n            int count = 1;\n            while (p2<n-1&&nums[p2]==nums[p2+1]){\n                if (count<3)\n                {\n                    nums[p1] = nums[p2];\n                    p1++;\n                }                \n                count++;\n                p2++;\n            }\n            if (count<3){\n                nums[p1] = nums[p2];\n                p1++;\n                p2++;\n            } else{\n                p2++;\n            }\n\n        }\n        \n        return p1;       \n    }\n}","runtime":"0 ms","title":"Remove Duplicates from Sorted Array II","url":"/submissions/detail/1077056614/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1077056614,"time":"3 months, 1 week","lang":"java","title_slug":"remove-duplicates-from-sorted-array-ii","timestamp":1697496200,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"39.9 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    \n    int prev =-100001;\n    int min = Integer.MAX_VALUE;\n    public int minDiffInBST(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        minDiffInBST(root.left);\n        int val = root.val - prev;\n        if (val<min) min = val;\n        prev = root.val;\n        // System.out.println(root.val);\n        minDiffInBST(root.right);\n        \n        return min;\n        \n    }\n}","runtime":"0 ms","title":"Minimum Distance Between BST Nodes","url":"/submissions/detail/1077027033/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1077027033,"time":"3 months, 1 week","lang":"java","title_slug":"minimum-distance-between-bst-nodes","timestamp":1697492248,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"43.4 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int prev =-100001;\n    int min = Integer.MAX_VALUE;\n    public int getMinimumDifference(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        getMinimumDifference(root.left);\n        int val = root.val - prev;\n        if (val<min) min = val;\n        prev = root.val;\n        // System.out.println(root.val);\n        getMinimumDifference(root.right);\n        \n        return min;\n        \n    }\n}","runtime":"0 ms","title":"Minimum Absolute Difference in BST","url":"/submissions/detail/1076542721/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076542721,"time":"3 months, 1 week","lang":"java","title_slug":"minimum-absolute-difference-in-bst","timestamp":1697448133,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int searchInsert(int[] nums, int target) {\n        return search(nums,target,0,nums.length);\n    }\n    public int search(int [] nums, int t, int l, int r){\n        System.out.println(l+ \" \"+ r);\n        if (l<0) return 0;\n        if (r>nums.length) return nums.length;\n        if (l == r) return l;\n        if (l>r) return l;\n        int mid =  l + (r-l)/2;\n        if (nums[mid]<t) return search(nums,t,mid+1,r);\n        if (nums[mid]>t) return search(nums,t,l,mid-1);\n        return mid;\n\n    }\n}","runtime":"N/A","title":"Search Insert Position","url":"/submissions/detail/1076521255/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076521255,"time":"3 months, 1 week","lang":"java","title_slug":"search-insert-position","timestamp":1697445813,"status":11,"is_pending":"Not Pending","compare_result":"11111111101111011111111110111111001111110111111111111111111101111"}],"has_next":true,"last_key":"%7B%22pk%22%3A%20%7B%22N%22%3A%20%221076521255%22%7D%2C%20%22dt%22%3A%20%7B%22S%22%3A%20%222023-10-16T08%3A43%3A33.120114%2B0000%22%7D%2C%20%22sid%22%3A%20%7B%22N%22%3A%20%227573785%22%7D%7D"}
2024-01-26 23:39:08.025 [main] DEBUG submission_dump - {"submissions_dump":[{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int searchInsert(int[] nums, int target) {\n        return search(nums,target,0,nums.length);\n    }\n    public int search(int [] nums, int t, int l, int r){\n        System.out.println(l+ \" \"+ r);\n        if (l<0) return 0;\n        if (r>nums.length) return nums.length;\n        if (l>=r) return l;\n        int mid =  l + (r-l)/2;\n        if (nums[mid]<t) return search(nums,t,mid+1,r);\n        if (nums[mid]>t) return search(nums,t,l,mid-1);\n        return mid;\n\n    }\n}","runtime":"N/A","title":"Search Insert Position","url":"/submissions/detail/1076521133/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076521133,"time":"3 months, 1 week","lang":"java","title_slug":"search-insert-position","timestamp":1697445797,"status":11,"is_pending":"Not Pending","compare_result":"11111111101111011111111110111111001111110111111111111111111101111"},{"status_display":"Runtime Error","memory":"N/A","code":"class Solution {\n    public int searchInsert(int[] nums, int target) {\n        return search(nums,target,0,nums.length);\n    }\n    public int search(int [] nums, int t, int l, int r){\n        System.out.println(l+ \" \"+ r);\n        if (l<0) return 0;\n        if (r>nums.length) return nums.length;\n        if (l>r) return l;\n        int mid =  l + (r-l)/2;\n        if (nums[mid]<t) return search(nums,t,mid+1,r);\n        if (nums[mid]>t) return search(nums,t,l,mid-1);\n        return mid;\n\n    }\n}","runtime":"N/A","title":"Search Insert Position","url":"/submissions/detail/1076521041/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076521041,"time":"3 months, 1 week","lang":"java","title_slug":"search-insert-position","timestamp":1697445788,"status":15,"is_pending":"Not Pending","compare_result":"11000000000000000000000000000000000000000000000000000000000000000"},{"status_display":"Accepted","memory":"43.8 MB","code":"class Solution {\n    public int searchInsert(int[] nums, int target) {\n        return search(nums,target,0,nums.length-1);\n    }\n    public int search(int [] nums, int t, int l, int r){\n        System.out.println(l+ \" \"+ r);\n        if (l>r) return l;\n        int mid =  l + (r-l)/2;\n        if (nums[mid]<t) return search(nums,t,mid+1,r);\n        if (nums[mid]>t) return search(nums,t,l,mid-1);\n        return mid;\n\n    }\n}","runtime":"8 ms","title":"Search Insert Position","url":"/submissions/detail/1076519550/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076519550,"time":"3 months, 1 week","lang":"java","title_slug":"search-insert-position","timestamp":1697445626,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int searchInsert(int[] nums, int target) {\n        return search(nums,target,0,nums.length);\n    }\n    public int search(int [] nums, int t, int l, int r){\n        System.out.println(l+ \" \"+ r);\n        if (r>nums.length) return nums.length;\n        if (l == r) return l;\n        if (l>r) return l;\n        int mid =  l + (r-l)/2;\n        if (nums[mid]<t) return search(nums,t,mid+1,r);\n        if (nums[mid]>t) return search(nums,t,l,mid-1);\n        return mid;\n\n    }\n}","runtime":"N/A","title":"Search Insert Position","url":"/submissions/detail/1076519066/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076519066,"time":"3 months, 1 week","lang":"java","title_slug":"search-insert-position","timestamp":1697445573,"status":11,"is_pending":"Not Pending","compare_result":"11111111101111011111111110111111001111110111111111111111111101111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int searchInsert(int[] nums, int target) {\n        return search(nums,target,0,nums.length);\n    }\n    public int search(int [] nums, int t, int l, int r){\n        System.out.println(l+ \" \"+ r);\n        if (l<0) return 0;\n        if (r>nums.length) return nums.length;\n        if (l == r) return l;\n        if (l>r) return l;\n        int mid =  l + (r-l)/2;\n        if (nums[mid]<t) return search(nums,t,mid+1,r);\n        if (nums[mid]>t) return search(nums,t,l,mid-1);\n        return mid;\n\n    }\n}","runtime":"N/A","title":"Search Insert Position","url":"/submissions/detail/1076517979/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076517979,"time":"3 months, 1 week","lang":"java","title_slug":"search-insert-position","timestamp":1697445450,"status":11,"is_pending":"Not Pending","compare_result":"11111111101111011111111110111111001111110111111111111111111101111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int searchInsert(int[] nums, int target) {\n        return search(nums,target,0,nums.length);\n    }\n    public int search(int [] nums, int t, int l, int r){\n        System.out.println(l+ \" \"+ r);\n        if (l<0) return 0;\n        if (r>nums.length) return nums.length;\n        if (l == r) return l;\n        if (l>r) return r;\n        int mid =  l + (r-l)/2;\n        if (nums[mid]<t) return search(nums,t,mid+1,r);\n        if (nums[mid]>t) return search(nums,t,l,mid-1);\n        return mid;\n\n    }\n}","runtime":"N/A","title":"Search Insert Position","url":"/submissions/detail/1076517629/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076517629,"time":"3 months, 1 week","lang":"java","title_slug":"search-insert-position","timestamp":1697445414,"status":11,"is_pending":"Not Pending","compare_result":"11100111101111010110111010101111001111110111111111010111111101101"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int searchInsert(int[] nums, int target) {\n        return search(nums,target,0,nums.length);\n    }\n    public int search(int [] nums, int t, int l, int r){\n        System.out.println(l+ \" \"+ r);\n        if (l == r) return l;\n        if (l>r) return r;\n        int mid =  l + (r-l)/2;\n        if (nums[mid]<t) return search(nums,t,mid+1,r);\n        if (nums[mid]>t) return search(nums,t,l,mid-1);\n        return mid;\n\n    }\n}","runtime":"N/A","title":"Search Insert Position","url":"/submissions/detail/1076517020/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076517020,"time":"3 months, 1 week","lang":"java","title_slug":"search-insert-position","timestamp":1697445350,"status":11,"is_pending":"Not Pending","compare_result":"11100111101111010110111010101111001111110111111111010111111101101"},{"status_display":"Accepted","memory":"44.3 MB","code":"class Solution {\n    public int singleNumber(int[] nums) {\n        int re = 0;\n        for (int i: nums) re = re^i;\n        return re;\n    }\n}","runtime":"1 ms","title":"Single Number","url":"/submissions/detail/1076489271/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076489271,"time":"3 months, 1 week","lang":"java","title_slug":"single-number","timestamp":1697442082,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"42.7 MB","code":"class Solution {\n    public boolean isPalindrome(int x) {\n        if (x<0) return false;\n        return x == rev(x);\n    }\n    public int rev(int x){\n        int re = 0;\n        \n        while (x!=0){\n            re = 10*re + x %10;\n            x = x/10;\n        }\n        return re;\n    }\n}","runtime":"5 ms","title":"Palindrome Number","url":"/submissions/detail/1076486538/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076486538,"time":"3 months, 1 week","lang":"java","title_slug":"palindrome-number","timestamp":1697441777,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"41.1 MB","code":"class Solution {\n    public int[] plusOne(int[] digits) {\n        int n = digits.length;\n        LinkedList<Integer> re = new LinkedList<>();\n        int i = n-1;\n        int left = 1;\n        while (i>=0){\n            if (digits[i] + left >9 ){\n                left = 1;\n                re.addFirst(0);\n            } else{\n                re.addFirst(digits[i]+left);\n                left = 0;\n            }\n            i--;\n        }\n        if (left==1) re.addFirst(1);\n        int re1 [] = new int[re.size()];\n        int count = 0;\n        for (int val:re){\n            re1[count] = val;\n            count++;\n        }\n        return re1;\n    }\n}","runtime":"1 ms","title":"Plus One","url":"/submissions/detail/1076485171/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076485171,"time":"3 months, 1 week","lang":"java","title_slug":"plus-one","timestamp":1697441614,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"41.2 MB","code":"class Solution {\n    public int[] plusOne(int[] digits) {\n        int n = digits.length;\n        LinkedList<Integer> re = new LinkedList<>();\n        int i = n-1;\n        int left = 1;\n        while (i>=0){\n            if (digits[i] + left >9 ){\n                left = 1;\n                re.addFirst(0);\n            } else{\n                re.addFirst(digits[i]+left);\n                left = 0;\n            }\n            i--;\n        }\n        if (left==1) re.addFirst(1);\n        int re1 [] = new int[re.size()];\n        int count = 0;\n        for (int val:re){\n            re1[count] = val;\n            count++;\n        }\n        return re1;\n    }\n}","runtime":"1 ms","title":"Plus One","url":"/submissions/detail/1076485095/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076485095,"time":"3 months, 1 week","lang":"java","title_slug":"plus-one","timestamp":1697441605,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"40.2 MB","code":"class Solution {\n    public int mySqrt(int x) {\n        long r = x;\n        while (r*r > x)\n            r = (r + x/r) / 2;\n        return (int) r;\n    }\n}","runtime":"1 ms","title":"Sqrt(x)","url":"/submissions/detail/1076478896/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076478896,"time":"3 months, 1 week","lang":"java","title_slug":"sqrtx","timestamp":1697440925,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"61.6 MB","code":"class Solution {\n    public int maxProfit(int[] prices) {\n        int runMin = Integer.MAX_VALUE;\n        int max = 0;\n        for (int i:prices){\n            if (i>runMin){\n                if (i-runMin > max) max = i - runMin;\n            }\n            if (i<runMin){\n                runMin = i;\n            }\n        }\n        return max;\n    }\n}","runtime":"2 ms","title":"Best Time to Buy and Sell Stock","url":"/submissions/detail/1076469419/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076469419,"time":"3 months, 1 week","lang":"java","title_slug":"best-time-to-buy-and-sell-stock","timestamp":1697439960,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"48.2 MB","code":"class Solution {\n    public int majorityElement(int[] nums) {\n        int candidate = 0;\n        int freq = 0;\n        for (int i: nums){\n            if (i!=candidate) freq--;\n            else freq++;\n            if (freq<0) {\n                candidate = i;\n                freq = 1;\n            }\n\n        }\n        return candidate;\n        \n    }\n}","runtime":"1 ms","title":"Majority Element","url":"/submissions/detail/1076465295/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076465295,"time":"3 months, 1 week","lang":"java","title_slug":"majority-element","timestamp":1697439566,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"44 MB","code":"class Solution {\n    public int removeDuplicates(int[] nums) {\n        int p1 = 0;\n        int n = nums.length;\n        int p2 = 0;\n        while (p2<n){\n            while (p2<n-1 && nums[p2]==nums[p2+1]){\n                p2++;\n            } \n            nums[p1] = nums[p2];\n            p1++;\n            p2++;\n        }\n        return p1;\n\n        \n    }\n}","runtime":"1 ms","title":"Remove Duplicates from Sorted Array","url":"/submissions/detail/1076461449/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076461449,"time":"3 months, 1 week","lang":"java","title_slug":"remove-duplicates-from-sorted-array","timestamp":1697439202,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"46.3 MB","code":"class Solution {\n    public int removeDuplicates(int[] nums) {\n        int p1 = 0;\n        int n = nums.length;\n        int p2 = 0;\n        // int count = 0;\n        while (p2<n){\n            while (p2<n-1 && nums[p2]==nums[p2+1]){\n                p2++;\n            } \n            System.out.println(p1 +\" \" + p2);\n\n            nums[p1] = nums[p2];\n            p1++;\n            p2++;\n            // count++;\n        }\n        // System.out.println(p1);\n        return p1;\n\n        \n    }\n}","runtime":"23 ms","title":"Remove Duplicates from Sorted Array","url":"/submissions/detail/1076461200/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076461200,"time":"3 months, 1 week","lang":"java","title_slug":"remove-duplicates-from-sorted-array","timestamp":1697439179,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"43 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n\n    public boolean hasPathSum(TreeNode root, int targetSum) {\n        if (root == null){\n            return false;\n        }\n        return hasPathSum1(root, targetSum);        \n    }\n    public boolean hasPathSum1(TreeNode root, int targetSum) {\n        if (root == null){\n            if (targetSum == 0) return true;\n            return false;\n        }\n        if (root.left == null) return hasPathSum1(root.right, targetSum-root.val);\n        if (root.right == null) return hasPathSum1(root.left, targetSum-root.val);\n\n        return hasPathSum1(root.left, targetSum-root.val) || hasPathSum1(root.right, targetSum-root.val);        \n    }\n}","runtime":"0 ms","title":"Path Sum","url":"/submissions/detail/1076454742/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076454742,"time":"3 months, 1 week","lang":"java","title_slug":"path-sum","timestamp":1697438589,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n\n    public boolean hasPathSum(TreeNode root, int targetSum) {\n        if (root == null){\n            return false;\n        }\n        return hasPathSum1(root, targetSum);        \n    }\n    public boolean hasPathSum1(TreeNode root, int targetSum) {\n        if (root == null){\n            if (targetSum == 0) return true;\n            return false;\n        }\n        return hasPathSum1(root.left, targetSum-root.val) || hasPathSum1(root.right, targetSum-root.val);        \n    }\n}","runtime":"N/A","title":"Path Sum","url":"/submissions/detail/1076452529/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076452529,"time":"3 months, 1 week","lang":"java","title_slug":"path-sum","timestamp":1697438380,"status":11,"is_pending":"Not Pending","compare_result":"111111110111011111111101011101011111111010111101111111101111111011111111101111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"40.4 MB","code":"class Solution {\n    public int removeElement(int[] nums, int val) {\n        int count = 0;\n        int n = nums.length;\n        for (int i = 0;i<n;i++){\n            if (nums[i]!=val){\n                nums[count] = nums[i];\n                count++;\n            }\n        }\n        return count;\n    }\n}","runtime":"0 ms","title":"Remove Element","url":"/submissions/detail/1076449732/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076449732,"time":"3 months, 1 week","lang":"java","title_slug":"remove-element","timestamp":1697438109,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"40.9 MB","code":"class Solution {\n    public int removeElement(int[] nums, int val) {\n        int count = 0;\n        int n = nums.length;\n        for (int i=0;i<n;i++){\n            if (nums[i] != val){\n                count++;\n            }\n        }\n        for (int i = 0; i< n-1;i++){\n            if (nums[i] == val){\n                for (int j=i+1;j<n;j++){\n                    if (nums[j]!= val){\n                        nums[i] = nums[j];\n                        nums[j] = val;\n                        break;\n                    }\n                }\n            }\n        }\n        return count;\n    }\n}","runtime":"0 ms","title":"Remove Element","url":"/submissions/detail/1076447445/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076447445,"time":"3 months, 1 week","lang":"java","title_slug":"remove-element","timestamp":1697437883,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}],"has_next":true,"last_key":"%7B%22pk%22%3A%20%7B%22N%22%3A%20%221076447445%22%7D%2C%20%22dt%22%3A%20%7B%22S%22%3A%20%222023-10-16T06%3A31%3A23.918126%2B0000%22%7D%2C%20%22sid%22%3A%20%7B%22N%22%3A%20%227573785%22%7D%7D"}
2024-01-26 23:39:18.565 [main] DEBUG submission_dump - {"submissions_dump":[{"status_display":"Accepted","memory":"40.6 MB","code":"class Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        int p1 = m - 1;\n        int p2 = n-1;\n        int p = n+m-1;\n        while (p1>=0 && p2>=0){\n            \n            if (nums1[p1]>nums2[p2]){\n                nums1[p] = nums1[p1];\n                p1--;\n                p--;\n            } else if (nums2[p2]>nums1[p1]){\n                nums1[p] = nums2[p2];\n                p2--;\n                p--;\n            } else{\n                nums1[p] = nums1[p1];\n                p1--;\n                p--;\n                nums1[p] = nums2[p2];\n                p2--;\n                p--;\n            }\n        }\n        while (p2>=0){\n            nums1[p] = nums2[p2];\n            p2--;\n            p--;\n        } \n        while (p1>=0){\n            nums1[p] = nums1[p1];\n            p1--;\n            p--;\n        } \n        \n    }\n}","runtime":"0 ms","title":"Merge Sorted Array","url":"/submissions/detail/1076439592/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076439592,"time":"3 months, 1 week","lang":"java","title_slug":"merge-sorted-array","timestamp":1697437150,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"40.6 MB","code":"class Solution {\n    HashSet<String> set ;\n    HashSet<String> notSet ;\n\n    public boolean wordBreak(String s, List<String> wordDict) {\n        set= new HashSet<>(wordDict);\n        notSet= new HashSet<>();\n        if (set.contains(s)) return true;\n        return check(s);\n        \n    }\n\n    boolean check(String s){\n        // if (index >= s.length) return true;\n        if (s==\"\") return true;\n        if (set.contains(s)) return true;\n        if (notSet.contains(s)) return false;\n        for (String si: set){\n            if (s.startsWith(si)){\n                // System.out.println(si+\" \"+s.substring(si.length()));\n                if (check(s.substring(si.length()))) return true;\n                else notSet.add(s);\n            }\n        }\n        if (!notSet.contains(s))\n            notSet.add(s);\n        return false;\n    }\n}","runtime":"2 ms","title":"Word Break","url":"/submissions/detail/1076420906/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076420906,"time":"3 months, 1 week","lang":"java","title_slug":"word-break","timestamp":1697435382,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"40.9 MB","code":"class Solution {\n    HashSet<String> set ;\n    HashSet<String> notSet ;\n\n    public boolean wordBreak(String s, List<String> wordDict) {\n        set= new HashSet<>(wordDict);\n        notSet= new HashSet<>();\n        if (set.contains(s)) return true;\n        return check(s);\n        \n    }\n\n    boolean check(String s){\n        // if (index >= s.length) return true;\n        if (s==\"\") return true;\n        if (set.contains(s)) return true;\n        if (notSet.contains(s)) return false;\n        for (String si: set){\n            if (s.startsWith(si)){\n                // System.out.println(si+\" \"+s.substring(si.length()));\n                if (check(s.substring(si.length()))) return true;\n                else notSet.add(s);\n            }\n        }\n        notSet.add(s);\n        return false;\n    }\n}","runtime":"3 ms","title":"Word Break","url":"/submissions/detail/1076420656/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076420656,"time":"3 months, 1 week","lang":"java","title_slug":"word-break","timestamp":1697435360,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"41.3 MB","code":"class Solution {\n    HashSet<String> set ;\n    HashSet<String> notSet ;\n\n    public boolean wordBreak(String s, List<String> wordDict) {\n        set= new HashSet<>(wordDict);\n        notSet= new HashSet<>();\n        if (set.contains(s)) return true;\n        return check(s);\n        \n    }\n\n    boolean check(String s){\n        // if (index >= s.length) return true;\n        if (s==\"\") return true;\n        if (set.contains(s)) return true;\n        if (notSet.contains(s)) return false;\n        for (String si: set){\n            if (s.startsWith(si)){\n                // System.out.println(si+\" \"+s.substring(si.length()));\n                if (check(s.substring(si.length()))) return true;\n                else notSet.add(s);\n            }\n        }\n        return false;\n    }\n}","runtime":"2 ms","title":"Word Break","url":"/submissions/detail/1076419392/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076419392,"time":"3 months, 1 week","lang":"java","title_slug":"word-break","timestamp":1697435244,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111"},{"status_display":"Time Limit Exceeded","memory":"N/A","code":"class Solution {\n    HashSet<String> set ;\n\n    public boolean wordBreak(String s, List<String> wordDict) {\n        set= new HashSet<>(wordDict);\n        // notSet= new HashSet<>();\n        if (set.contains(s)) return true;\n        return check(s);\n        \n    }\n\n    boolean check(String s){\n        // if (index >= s.length) return true;\n        if (s==\"\") return true;\n        if (set.contains(s)) return true;\n        for (String si: set){\n            if (s.startsWith(si)){\n                // System.out.println(si+\" \"+s.substring(si.length()));\n                if (check(s.substring(si.length()))) return true;\n            }\n        }\n        return false;\n    }\n}","runtime":"N/A","title":"Word Break","url":"/submissions/detail/1076417033/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076417033,"time":"3 months, 1 week","lang":"java","title_slug":"word-break","timestamp":1697435024,"status":14,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111100000000000"},{"status_display":"Accepted","memory":"45.7 MB","code":"class Solution {\n    HashSet<String> set ;\n    HashSet<String> notSet;\n    public boolean wordBreak(String s, List<String> wordDict) {\n        set= new HashSet<>(wordDict);\n        notSet= new HashSet<>();\n\n        if (set.contains(s)) return true;\n        \n\n        return check(s);\n        \n    }\n\n    boolean check(String s){\n        if (set.contains(s)) return true;\n        if (notSet.contains(s)) return false;\n        for (int i = 1;i<s.length();i++){\n            String sl = s.substring(0,i);\n            String sr = s.substring(i,s.length());\n            // System.out.println\n            boolean left = check(sl);\n            if (left) set.add(sl);\n            else notSet.add(sl);\n            boolean right = check(sr);\n            if (right) set.add(sr);\n            else notSet.add(sr);\n            if (left && right) return true;\n        }\n        return false;\n    }\n}","runtime":"379 ms","title":"Word Break","url":"/submissions/detail/1076389096/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076389096,"time":"3 months, 1 week","lang":"java","title_slug":"word-break","timestamp":1697432228,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111"},{"status_display":"Time Limit Exceeded","memory":"N/A","code":"class Solution {\n    HashSet<String> set ;\n    public boolean wordBreak(String s, List<String> wordDict) {\n        set= new HashSet<>(wordDict);\n        if (set.contains(s)) return true;\n        \n\n        return check(s);\n        \n    }\n\n    boolean check(String s){\n        if (set.contains(s)) return true;\n        for (int i = 1;i<s.length();i++){\n            String sl = s.substring(0,i);\n            String sr = s.substring(i,s.length());\n            // System.out.println\n            boolean left = check(sl);\n            if (left) set.add(sl);\n            boolean right = check(sr);\n            if (right) set.add(sr);\n            if (left && right) return true;\n        }\n        return false;\n    }\n}","runtime":"N/A","title":"Word Break","url":"/submissions/detail/1076387672/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076387672,"time":"3 months, 1 week","lang":"java","title_slug":"word-break","timestamp":1697432089,"status":14,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111000000000000"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    HashSet<String> set ;\n    public boolean wordBreak(String s, List<String> wordDict) {\n        set= new HashSet<>(wordDict);\n        if (set.contains(s)) return true;\n        \n\n        return check(s);\n        \n    }\n\n    boolean check(String s){\n        if (set.contains(s)) return true;\n        for (int i = 1;i<s.length()-1;i++){\n            String sl = s.substring(0,i);\n            String sr = s.substring(i,s.length());\n            boolean left = check(sl);\n            if (left) set.add(sl);\n            boolean right = check(sr);\n            if (right) set.add(sr);\n            if (left && right) return true;\n        }\n        return false;\n    }\n}","runtime":"N/A","title":"Word Break","url":"/submissions/detail/1076386858/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076386858,"time":"3 months, 1 week","lang":"java","title_slug":"word-break","timestamp":1697432009,"status":11,"is_pending":"Not Pending","compare_result":"1111100101111111111111111111011111000000000000"},{"status_display":"Accepted","memory":"40.3 MB","code":"class Solution {\n    public int rob(int[] nums) {\n        int n = nums.length;\n        if (n==1) return nums[0];\n        if (n==2) return Integer.max(nums[0],nums[1]);;\n        int [] dp = new int [n];\n        dp[0] = nums[0];\n        dp[1] = Integer.max(nums[0],nums[1]);\n        for (int i = 2;i<n;i++){\n            dp[i]= Integer.max(dp[i-2]+nums[i],dp[i-1]);\n        }\n        return dp[n-1];\n    }\n}","runtime":"0 ms","title":"House Robber","url":"/submissions/detail/1076333570/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076333570,"time":"3 months, 1 week","lang":"java","title_slug":"house-robber","timestamp":1697426031,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Runtime Error","memory":"N/A","code":"class Solution {\n    public int rob(int[] nums) {\n        int n = nums.length;\n        int [] dp = new int [n];\n        dp[0] = nums[0];\n        dp[1] = Integer.max(nums[0],nums[1]);\n        for (int i = 2;i<n;i++){\n            dp[i]= Integer.max(dp[i-2]+nums[i],dp[i-1]);\n        }\n        return dp[n-1];\n    }\n}","runtime":"N/A","title":"House Robber","url":"/submissions/detail/1076333037/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076333037,"time":"3 months, 1 week","lang":"java","title_slug":"house-robber","timestamp":1697425966,"status":15,"is_pending":"Not Pending","compare_result":"1100000000000000000000000000000000000000000000000000000000000000000000"},{"status_display":"Accepted","memory":"39.2 MB","code":"class Solution {\n    public int climbStairs(int n) {\n        if (n<=2) return n;\n        int a = 1;\n        int b = 2;\n        int c = 2;\n        int count = 2;\n        while (count<n){\n            count++;\n            c = a + b;\n            a = b;\n            b = c;\n        }\n        return c;\n        \n    }\n}","runtime":"0 ms","title":"Climbing Stairs","url":"/submissions/detail/1076330917/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076330917,"time":"3 months, 1 week","lang":"java","title_slug":"climbing-stairs","timestamp":1697425703,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"43.2 MB","code":"class Solution {\n    int [] dp;\n    public int candy(int[] r) {\n        int n = r.length;\n        int []left = new int[n];\n        int [] right = new int [n];        \n        int sum = 0;\n        left [0] = 1;\n        for (int i=1;i<n;i++){\n            if (r[i]>r[i-1]) left[i] = left[i-1]+1;\n            else left[i] = 1;\n        }\n        right[n-1] = 1;\n        for (int i=n-2;i>=0;i--){\n            if (r[i]>r[i+1]) right[i] = right[i+1]+1;\n            else right[i] = 1;\n        }\n        for (int i = 0; i<n;i++){\n            // System.out.println(left[i] + \" \"+ right[i]);\n            sum = sum + Integer.max(left[i],right[i]);\n        }\n        \n        return sum;\n\n    }\n\n    // public int getCandy(int x, int[] ratings){\n    //     System.out.println(x);\n    //     if (x<=0) return 0;\n    //     if (x>=dp.length-1) return 0;\n    //     if (dp[x]!=0) return dp[x];\n    //     if (ratings[x]<ratings[x-1] && ratings[x]<ratings[x+1]) return 1;\n    //     // int min = Integer.min(getCandy(x-1,ratings),getCandy(x+1,ratings))+1;\n    //     int a = getCandy(x-1,ratings);\n    //     int b = getCandy(x+1,ratings);\n    //     int min = Integer.min(a,b)+1;\n    //     dp[x] = min;\n    //     return min;\n    // }\n}","runtime":"3 ms","title":"Candy","url":"/submissions/detail/1076327826/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1076327826,"time":"3 months, 1 week","lang":"java","title_slug":"candy","timestamp":1697425307,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"61.3 MB","code":"class Solution {\n    public int canCompleteCircuit(int[] gas, int[] cost) {\n\n        \n        int g = 0;\n        int c = 0;\n        for (int i: gas){\n            g= g + i;\n        }\n        for (int i:cost){\n            c = c+i;\n        }\n        if (g<c) return -1;\n        int n = gas.length;\n        int a [] = new int [n];\n        for (int i=0;i<n;i++){\n            a[i] = gas[i] - cost[i];\n        }\n        int start = 0;\n        int runSum = 0;\n        for (int i = 0; i< n ; i++){\n            runSum = runSum+a[i];\n            if (runSum<0){\n                start = i+1;\n                runSum=0;\n            }\n            // System.out.println(start+\" \"+runSum);\n\n        }\n        // for (int i: a){\n        //     System.out.print(i +\" \");\n\n        // }\n        // System.out.println();\n        \n\n        return start;\n        \n    }\n\n    \n}","runtime":"2 ms","title":"Gas Station","url":"/submissions/detail/1075591421/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1075591421,"time":"3 months, 1 week","lang":"java","title_slug":"gas-station","timestamp":1697346572,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int canCompleteCircuit(int[] gas, int[] cost) {\n        int g = 0;\n        int c = 0;\n        for (int i: gas){\n            g= g + i;\n        }\n        for (int i:cost){\n            c = c+i;\n        }\n        if (g<c) return -1;\n        int n = gas.length;\n        int a [] = new int [n];\n        for (int i=0;i<n;i++){\n            a[i] = gas[i] - cost[i];\n        }\n        int start =0;\n        while (a[start]*a[start+1]>=0){\n            start++;\n        }\n        start = start + 1;\n        int count = start;\n        boolean check = false;\n        int runSum = 0;\n        int max = 0;\n        int res = 0;\n        for (int i: a){\n            System.out.print(i +\" \");\n\n        }\n        System.out.println();\n        while (!check){\n            if (a[count]>=0){\n                int temp = count;\n                runSum = 0;\n                while (a[count]>=0){\n                    runSum=runSum+a[count];\n                    count++;\n                    if (count >=n) count =0;\n                    if (count == start) check = true;\n\n                }\n                if (runSum> max) {\n                    max = runSum;\n                    res = temp;\n                }\n\n            }\n            // System.out.println(count+\" \"+runSum);\n            count++;\n            if (count >=n) count =0;\n            if (count == start) check = true;\n\n        }\n        System.out.println(start+\" \"+max);\n\n        return res;\n        \n    }\n\n    \n}","runtime":"N/A","title":"Gas Station","url":"/submissions/detail/1075584351/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1075584351,"time":"3 months, 1 week","lang":"java","title_slug":"gas-station","timestamp":1697345870,"status":11,"is_pending":"Not Pending","compare_result":"1111101111111111100000000000000000000000"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int canCompleteCircuit(int[] gas, int[] cost) {\n        int g = 0;\n        int c = 0;\n        for (int i: gas){\n            g= g + i;\n        }\n        for (int i:cost){\n            c = c+i;\n        }\n        if (g<c) return -1;\n        int n = gas.length;\n        int a [] = new int [n];\n        for (int i=0;i<n;i++){\n            a[i] = gas[i] - cost[i];\n        }\n        int start =0;\n        while (a[start]*a[start+1]>=0){\n            start++;\n        }\n        start = start + 1;\n        int count = start;\n        boolean check = false;\n        int runSum = 0;\n        int max = 0;\n        int res = 0;\n        for (int i: a){\n            System.out.print(i +\" \");\n\n        }\n        System.out.println();\n        while (!check){\n            if (a[count]>=0){\n                int temp = count;\n                while (a[count]>=0){\n                    runSum=runSum+a[count];\n                    count++;\n                    if (count >=n) count =0;\n                    if (count == start) check = true;\n\n                }\n                if (runSum> max) {\n                    max = runSum;\n                    res = temp;\n                }\n\n            }\n            // System.out.println(count+\" \"+runSum);\n            count++;\n            if (count >=n) count =0;\n            if (count == start) check = true;\n\n        }\n        // System.out.println(start);\n\n        return res;\n        \n    }\n\n    \n}","runtime":"N/A","title":"Gas Station","url":"/submissions/detail/1075582880/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1075582880,"time":"3 months, 1 week","lang":"java","title_slug":"gas-station","timestamp":1697345731,"status":11,"is_pending":"Not Pending","compare_result":"1111111111111110100000000000000000000000"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int canCompleteCircuit(int[] gas, int[] cost) {\n        int g = 0;\n        int c = 0;\n        for (int i: gas){\n            g= g + i;\n        }\n        for (int i:cost){\n            c = c+i;\n        }\n        if (g<c) return -1;\n        int n = gas.length;\n        int a [] = new int [n];\n        for (int i=0;i<n;i++){\n            a[i] = gas[i] - cost[i];\n        }\n        int start =0;\n        while (a[start]*a[start+1]>=0){\n            start++;\n        }\n        start = start + 1;\n        int count = start;\n        boolean check = false;\n        int runSum = 0;\n        int max = 0;\n        int res = 0;\n        while (!check){\n            if (a[count]>=0){\n                int temp = count;\n                while (a[count]>=0){\n                    runSum=runSum+a[count];\n                    count++;\n                    if (count >=n) count =0;\n                    if (count == start) check = true;\n\n                }\n                if (runSum> max) {\n                    max = runSum;\n                    res = temp;\n                }\n\n            }\n            // System.out.println(count+\" \"+runSum);\n            count++;\n            if (count >=n) count =0;\n            if (count == start) check = true;\n\n        }\n        // System.out.println(start);\n\n        return res;\n        \n    }\n\n    \n}","runtime":"N/A","title":"Gas Station","url":"/submissions/detail/1075582236/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1075582236,"time":"3 months, 1 week","lang":"java","title_slug":"gas-station","timestamp":1697345664,"status":11,"is_pending":"Not Pending","compare_result":"1111111111111110100000000000000000000000"},{"status_display":"Time Limit Exceeded","memory":"N/A","code":"class Solution {\n    public int canCompleteCircuit(int[] gas, int[] cost) {\n        int g = 0;\n        int c = 0;\n        for (int i: gas){\n            g= g + i;\n        }\n        for (int i:cost){\n            c = c+i;\n        }\n        if (g<c) return -1;\n        int n = gas.length;\n        int a [] = new int [n];\n        for (int i=0;i<n;i++){\n            a[i] = gas[i] - cost[i];\n        }\n        int start =0;\n        while (a[start]*a[start+1]>=0){\n            start++;\n        }\n        start = start + 1;\n        int count = start;\n        boolean check = false;\n        int runSum = 0;\n        int max = 0;\n        int res = 0;\n        while (!check){\n            if (a[count]>=0){\n                int temp = count;\n                while (a[count]>=0){\n                    runSum=runSum+a[count];\n                    count++;\n                    if (count >=n) count =0;\n                }\n                if (runSum> max) {\n                    max = runSum;\n                    res = temp;\n                }\n\n            }\n            // System.out.println(count+\" \"+runSum);\n            count++;\n            if (count >=n) count =0;\n            if (count == start) check = true;\n\n        }\n        // System.out.println(start);\n\n        return res;\n        \n    }\n\n    \n}","runtime":"N/A","title":"Gas Station","url":"/submissions/detail/1075581822/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1075581822,"time":"3 months, 1 week","lang":"java","title_slug":"gas-station","timestamp":1697345620,"status":14,"is_pending":"Not Pending","compare_result":"1110000000000000000000000000000000000000"},{"status_display":"Time Limit Exceeded","memory":"N/A","code":"class Solution {\n    public int canCompleteCircuit(int[] gas, int[] cost) {\n        int g = 0;\n        int c = 0;\n        for (int i: gas){\n            g= g + i;\n        }\n        for (int i:cost){\n            c = c+i;\n        }\n        if (g<c) return -1;\n        int n = gas.length;\n        int a [] = new int [n];\n        for (int i=0;i<n;i++){\n            a[i] = gas[i] - cost[i];\n        }\n        int start =0;\n        while (a[start]*a[start+1]>=0){\n            start++;\n        }\n        start = start + 1;\n        int count = start;\n        boolean check = false;\n        int runSum = 0;\n        int max = 0;\n        int res = 0;\n        while (!check){\n            if (a[count]>=0){\n                int temp = count;\n                while (a[count]>=0){\n                    runSum=runSum+a[count];\n                    count++;\n                    if (count >=n) count =0;\n                }\n                if (runSum> max) {\n                    max = runSum;\n                    res = temp;\n                }\n\n            }\n            // System.out.println(count+\" \"+runSum);\n            count++;\n            if (count >=n) count =0;\n            if (count == start) check = true;\n\n        }\n        // System.out.println(start);\n\n        return res;\n        \n    }\n\n    \n}","runtime":"N/A","title":"Gas Station","url":"/submissions/detail/1075581621/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1075581621,"time":"3 months, 1 week","lang":"java","title_slug":"gas-station","timestamp":1697345599,"status":14,"is_pending":"Not Pending","compare_result":"1110000000000000000000000000000000000000"},{"status_display":"Output Limit Exceeded","memory":"N/A","code":"class Solution {\n    public int canCompleteCircuit(int[] gas, int[] cost) {\n        int g = 0;\n        int c = 0;\n        for (int i: gas){\n            g= g + i;\n        }\n        for (int i:cost){\n            c = c+i;\n        }\n        if (g<c) return -1;\n        int n = gas.length;\n        int a [] = new int [n];\n        for (int i=0;i<n;i++){\n            a[i] = gas[i] - cost[i];\n        }\n        int start =0;\n        while (a[start]*a[start+1]>=0){\n            start++;\n        }\n        start = start + 1;\n        int count = start;\n        boolean check = false;\n        int runSum = 0;\n        int max = 0;\n        int res = 0;\n        while (!check){\n            if (a[count]>=0){\n                int temp = count;\n                while (a[count]>=0){\n                    runSum=runSum+a[count];\n                    count++;\n                    if (count >=n) count =0;\n                }\n                if (runSum> max) {\n                    max = runSum;\n                    res = temp;\n                }\n\n            }\n            System.out.println(count+\" \"+runSum);\n            count++;\n            if (count >=n) count =0;\n            if (count == start) check = true;\n\n        }\n        // System.out.println(start);\n\n        return res;\n        \n    }\n\n    \n}","runtime":"N/A","title":"Gas Station","url":"/submissions/detail/1075581447/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1075581447,"time":"3 months, 1 week","lang":"java","title_slug":"gas-station","timestamp":1697345583,"status":13,"is_pending":"Not Pending","compare_result":"1110000000000000000000000000000000000000"},{"status_display":"Accepted","memory":"43 MB","code":"class Solution {\n    public int coinChange(int[] coins, int amount) {\n        if (amount == 0) return 0;\n        int [] dp = new int[amount+1];\n        HashSet<Integer> set = new HashSet<>();\n        dp[0] = 0;\n        for (int i=1;i<=amount;i++){\n            dp[i] = Integer.MAX_VALUE;\n        }\n        for (int i : coins){\n            if (i<=amount){\n                dp[i] = 1;\n                set.add(i);\n            }\n            \n        }\n\n        for (int i = 1;i<=amount; i++){\n            int min = dp[i];\n            for (int coin: coins){\n                if (i>coin){\n                    if (dp[i-coin]!=Integer.MAX_VALUE)\n                        if (dp[i-coin]+1 < min) min = dp[i-coin] +1;\n                }\n            }\n            if (min!=Integer.MAX_VALUE)\n                dp[i] = min;\n            \n        }\n        // for (int i = 0; i<=amount;i++){\n        //     System.out.println(i+\" \"+dp[i]);\n        // }\n\n        return dp[amount]!=Integer.MAX_VALUE?dp[amount]:-1;\n        \n    }\n}","runtime":"16 ms","title":"Coin Change","url":"/submissions/detail/1075232509/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1075232509,"time":"3 months, 2 weeks","lang":"java","title_slug":"coin-change","timestamp":1697309659,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}],"has_next":true,"last_key":"%7B%22pk%22%3A%20%7B%22N%22%3A%20%221075232509%22%7D%2C%20%22dt%22%3A%20%7B%22S%22%3A%20%222023-10-14T18%3A54%3A19.499222%2B0000%22%7D%2C%20%22sid%22%3A%20%7B%22N%22%3A%20%227573785%22%7D%7D"}
2024-01-26 23:39:29.258 [main] DEBUG submission_dump - {"submissions_dump":[{"status_display":"Accepted","memory":"43.7 MB","code":"class Solution {\n    public int coinChange(int[] coins, int amount) {\n        if (amount == 0) return 0;\n        int [] dp = new int[amount+1];\n        HashSet<Integer> set = new HashSet<>();\n        dp[0] = 0;\n        for (int i=1;i<=amount;i++){\n            dp[i] = Integer.MAX_VALUE;\n        }\n        for (int i : coins){\n            if (i<=amount){\n                dp[i] = 1;\n                set.add(i);\n            }\n            \n        }\n\n        for (int i = 1;i<=amount; i++){\n            int min = dp[i];\n            for (int coin: coins){\n                if (i>coin){\n                    if (dp[i-coin]!=Integer.MAX_VALUE)\n                        if (dp[i-coin]+1 < min) min = dp[i-coin] +1;\n                }\n            }\n            if (min!=Integer.MAX_VALUE)\n                dp[i] = min;\n            \n        }\n        // for (int i = 0; i<=amount;i++){\n        //     System.out.println(i+\" \"+dp[i]);\n        // }\n\n        return dp[amount]>0&&dp[amount]!=Integer.MAX_VALUE?dp[amount]:-1;\n        \n    }\n}","runtime":"15 ms","title":"Coin Change","url":"/submissions/detail/1075226455/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1075226455,"time":"3 months, 2 weeks","lang":"java","title_slug":"coin-change","timestamp":1697309094,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int coinChange(int[] coins, int amount) {\n        if (amount == 0) return 0;\n        int [] dp = new int[amount+1];\n        HashSet<Integer> set = new HashSet<>();\n        dp[0] = 0;\n        for (int i=1;i<=amount;i++){\n            dp[i] = Integer.MAX_VALUE;\n        }\n        for (int i : coins){\n            if (i<=amount){\n                dp[i] = 1;\n                set.add(i);\n            }\n            \n        }\n\n        for (int i = 1;i<=amount; i++){\n            int min = Integer.MAX_VALUE;\n            for (int coin: coins){\n                if (i>coin){\n                    if (dp[i-coin]+1 < min) min = dp[i-coin] +1;\n                }\n            }\n            if (min!=Integer.MAX_VALUE)\n                dp[i] = Integer.min(min,dp[i]);\n            \n        }\n        // for (int i = 0; i<=amount;i++){\n        //     System.out.println(i+\" \"+dp[i]);\n        // }\n\n        return dp[amount]>0&&dp[amount]!=Integer.MAX_VALUE?dp[amount]:-1;\n        \n    }\n}","runtime":"N/A","title":"Coin Change","url":"/submissions/detail/1075223060/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1075223060,"time":"3 months, 2 weeks","lang":"java","title_slug":"coin-change","timestamp":1697308785,"status":11,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111100000000000001000010000010000010001000100000000000000000000010000000000001000000011000000000000000000000000000000000000000000000000000001100000000000000110111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int coinChange(int[] coins, int amount) {\n        if (amount == 0) return 0;\n        int [] dp = new int[amount+1];\n        HashSet<Integer> set = new HashSet<>();\n        dp[0] = 0;\n        for (int i=1;i<=amount;i++){\n            dp[i] = Integer.MAX_VALUE;\n        }\n        for (int i : coins){\n            if (i<=amount){\n                dp[i] = 1;\n                set.add(i);\n            }\n            \n        }\n\n        for (int i = 1;i<=amount; i++){\n            int min = Integer.MAX_VALUE;\n            for (int coin: coins){\n                if (i>coin){\n                    if (dp[i-coin]+1 < min) min = dp[i-coin] +1;\n                }\n            }\n            if (min!=Integer.MAX_VALUE)\n                dp[i] = min;\n            \n        }\n        // for (int i = 0; i<=amount;i++){\n        //     System.out.println(i+\" \"+dp[i]);\n        // }\n\n        return dp[amount]>0&&dp[amount]!=Integer.MAX_VALUE?dp[amount]:-1;\n        \n    }\n}","runtime":"N/A","title":"Coin Change","url":"/submissions/detail/1075222276/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1075222276,"time":"3 months, 2 weeks","lang":"java","title_slug":"coin-change","timestamp":1697308720,"status":11,"is_pending":"Not Pending","compare_result":"111111111110110011101011010110000000000000001000010000010000010001000100000000000000000000010000000000001000000011000000000000000000000000000000000000000000000000000000100000000000000110111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int coinChange(int[] coins, int amount) {\n        if (amount == 0) return 0;\n        int [] dp = new int[amount+1];\n        HashSet<Integer> set = new HashSet<>();\n        dp[0] = 0;\n        for (int i=1;i<=amount;i++){\n            dp[i] = Integer.MAX_VALUE;\n        }\n        for (int i : coins){\n            if (i<=amount){\n                dp[i] = 1;\n                set.add(i);\n            }\n            \n        }\n\n        for (int i = 1;i<=amount; i++){\n            int min = Integer.MAX_VALUE;\n            for (int coin: coins){\n                if (i>coin){\n                    if (dp[i-coin]+1 < min) min = dp[i-coin] +1;\n                }\n            }\n            if (min!=Integer.MAX_VALUE)\n                dp[i] = min;\n            \n        }\n        // for (int i = 0; i<=amount;i++){\n        //     System.out.println(i+\" \"+dp[i]);\n        // }\n\n        return dp[amount]>0?dp[amount]:-1;\n        \n    }\n}","runtime":"N/A","title":"Coin Change","url":"/submissions/detail/1075221760/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1075221760,"time":"3 months, 2 weeks","lang":"java","title_slug":"coin-change","timestamp":1697308674,"status":11,"is_pending":"Not Pending","compare_result":"111110110110110011101011010110000000000000001000010000010000010000000100000000000000000000010000000000001000000011000000000000000000000000000000000000000000000000000000100000000000000110011"},{"status_display":"Accepted","memory":"43.7 MB","code":"class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        HashSet<Character> tracker =  new HashSet<>();\n        char [] ch = s.toCharArray();\n\n        int p_l = 0;\n        int p_r = 0;\n        int count = 0;\n        int max = 0;\n        while (p_l<s.length() && p_r<s.length()){\n            if (tracker.contains(ch[p_r])){\n                while (tracker.contains(ch[p_r])){\n                    tracker.remove(ch[p_l]);\n                    p_l++;\n                    count --;\n                }\n            }\n            \n            count++;\n            if (count > max) max= count;\n            tracker.add(ch[p_r]);\n            \n            p_r++;\n        }\n\n        return max;\n        \n    }\n}","runtime":"7 ms","title":"Longest Substring Without Repeating Characters","url":"/submissions/detail/1074721918/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1074721918,"time":"3 months, 2 weeks","lang":"java","title_slug":"longest-substring-without-repeating-characters","timestamp":1697259456,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        HashSet<Character> tracker =  new HashSet<>();\n        char [] ch = s.toCharArray();\n\n        int p_l = 0;\n        int p_r = 0;\n        int count = 0;\n        int max = 0;\n        while (p_l<s.length() && p_r<s.length()){\n            if (tracker.contains(ch[p_r])){\n                while (tracker.contains(ch[p_r])){\n                    tracker.remove(ch[p_l]);\n                    p_l++;\n                    count --;\n                }\n            }\n            else{\n                count++;\n                if (count > max) max= count;\n                tracker.add(ch[p_r]);\n            }\n            p_r++;\n        }\n\n        return max;\n        \n    }\n}","runtime":"N/A","title":"Longest Substring Without Repeating Characters","url":"/submissions/detail/1074662574/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1074662574,"time":"3 months, 2 weeks","lang":"java","title_slug":"longest-substring-without-repeating-characters","timestamp":1697250360,"status":11,"is_pending":"Not Pending","compare_result":"111111111011111111101111111101111110111110011111000110011111111111011111100110110010011111001110110011000101000110100001001100110000000010010000010010000010110100100011001000011001100100011100000000001001000101000100000100000000110010000000000101000000000010000000010001000001000010000000000001000000000100100000001010000000001000000000100000000001100000000011001100000000000000000000000000010000000010001100010100001000010001000000000000001000010000000000000000000000010000000001010000000100000000000000011000011000010101000000001000000010000000000000010000000001000000000000010000010010010000000000000000000100000010000000000100000000000000000000000000000001000100000000000001001000000000000000000000000000000000110010000000001000001000000001100001000000010000000000000000100000000000000000010100000011010100000010000000110000010000000100000000000000000000000000000000000001000000000000000000000000010000000000000000000000000000000010000000001000000000000000000010000000000000000000011"},{"status_display":"Accepted","memory":"42.6 MB","code":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode l1_p = l1;\n        ListNode l2_p = l2;\n        ListNode re = null;\n        ListNode re_p = re;\n        int left = 0;\n        while (l1_p!=null || l2_p !=null){\n            int val = left;\n            if (l1_p != null) {\n                val = val+l1_p.val;\n                l1_p = l1_p.next;\n            }\n            if (l2_p != null) {\n                val = val+l2_p.val;\n                l2_p = l2_p.next;\n            }\n            if (val > 9 ){\n                val = val- 10;\n                left = 1;\n            }else{\n                left = 0;\n            }\n            if (re_p==null){\n                re = new ListNode(val);\n                re_p = re;\n            }else{\n                re_p.next = new ListNode(val);\n                re_p = re_p.next;\n            }\n            \n        }\n        if (left > 0) re_p.next = new ListNode(left);\n\n        return re;\n        \n    }\n}","runtime":"1 ms","title":"Add Two Numbers","url":"/submissions/detail/1074655235/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1074655235,"time":"3 months, 2 weeks","lang":"java","title_slug":"add-two-numbers","timestamp":1697248954,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"42.9 MB","code":"class Solution {\n    public int numberOfPoints(List<List<Integer>> nums) {\n        List<Data> nums_data = new ArrayList<>();\n        int n = nums.size();\n        for (List<Integer> i : nums){\n            nums_data.add(new Data(i.get(0),i.get(1)));\n        }\n        Collections.sort(nums_data);\n\n        LinkedList<Data> re = new LinkedList<>();\n        re.add(nums_data.get(0));\n        for (int i =1;i<n;i++){\n            Data d = re.getLast();\n            Data i_d = nums_data.get(i);\n            if (d.b>=i_d.a) {\n                d.b = Integer.max(d.b,i_d.b);\n            } else{\n                re.add(i_d);\n            }\n        }\n        int count = 0;\n        for (Data d: re){\n            count = count + d.b-d.a+1;\n        }\n        return count;\n    }\n}\n\nclass Data implements Comparable<Data>{\n    int a;\n    int b;\n    public Data (int x, int y){\n        a= x;\n        b = y;\n    }\n\n    @Override\n    public int compareTo(Data o){\n        if (a==o.a) return Integer.compare(b,o.b);\n        return Integer.compare(a,o.a);\n    }\n}","runtime":"5 ms","title":"Points That Intersect With Cars","url":"/submissions/detail/1074626816/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1074626816,"time":"3 months, 2 weeks","lang":"java","title_slug":"points-that-intersect-with-cars","timestamp":1697243027,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"43.8 MB","code":"class Solution {\n    public int numberOfPoints(List<List<Integer>> nums) {\n        List<Data> nums_data = new ArrayList<>();\n        int n = nums.size();\n        for (List<Integer> i : nums){\n            nums_data.add(new Data(i.get(0),i.get(1)));\n        }\n        Collections.sort(nums_data);\n        for (Data d: nums_data){\n                        System.out.println(d.a+\" \"+d.b);\n\n        }\n        LinkedList<Data> re = new LinkedList<>();\n        re.add(nums_data.get(0));\n        for (int i =1;i<n;i++){\n            Data d = re.getLast();\n            Data i_d = nums_data.get(i);\n            if (d.b>=i_d.a) {\n                d.b = Integer.max(d.b,i_d.b);\n            } else{\n                re.add(i_d);\n            }\n        }\n        int count = 0;\n        for (Data d: re){\n            System.out.println(d.a+\" \"+d.b);\n            count = count + d.b-d.a+1;\n        }\n        return count;\n    }\n}\n\nclass Data implements Comparable<Data>{\n    int a;\n    int b;\n    public Data (int x, int y){\n        a= x;\n        b = y;\n    }\n\n    @Override\n    public int compareTo(Data o){\n        if (a==o.a) return Integer.compare(b,o.b);\n        return Integer.compare(a,o.a);\n    }\n}","runtime":"32 ms","title":"Points That Intersect With Cars","url":"/submissions/detail/1074626752/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1074626752,"time":"3 months, 2 weeks","lang":"java","title_slug":"points-that-intersect-with-cars","timestamp":1697243013,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int numberOfPoints(List<List<Integer>> nums) {\n        List<Data> nums_data = new ArrayList<>();\n        int n = nums.size();\n        for (List<Integer> i : nums){\n            nums_data.add(new Data(i.get(0),i.get(1)));\n        }\n        Collections.sort(nums_data);\n        LinkedList<Data> re = new LinkedList<>();\n        re.add(nums_data.get(0));\n        for (int i =1;i<n;i++){\n            Data d = re.getLast();\n            Data i_d = nums_data.get(i);\n            if (d.b>=i_d.a) {\n                d.b = Integer.max(d.b,i_d.b);\n            } else{\n                re.add(i_d);\n            }\n        }\n        int count = 0;\n        for (Data d: re){\n            System.out.println(d.a+\" \"+d.b);\n            count = count + d.b-d.a+1;\n        }\n        return count;\n    }\n}\n\nclass Data implements Comparable<Data>{\n    int a;\n    int b;\n    public Data (int x, int y){\n        a= x;\n        b = y;\n    }\n\n    @Override\n    public int compareTo(Data o){\n        if (a==o.a) return Integer.compare(b,o.b);\n        return Integer.compare(b,o.b);\n    }\n}","runtime":"N/A","title":"Points That Intersect With Cars","url":"/submissions/detail/1074626422/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1074626422,"time":"3 months, 2 weeks","lang":"java","title_slug":"points-that-intersect-with-cars","timestamp":1697242948,"status":11,"is_pending":"Not Pending","compare_result":"110001011001110101100110001011110001010000100101011110111010100011111101100100011111100000100101110100110011100110100110101101010100101100000110000110001111000000001000100011111010010110110110101100001010110001100100010011110001000010010111010101000110010001101100011110111111001101111101111101001010101000011100101001001000011110110111111111111011110110110011011111011010111100000001011011010110100000111110101010100000011101000101101100100011000011110100101111011001000100010000111100011111111011100100000001000110001001010000000010000100000001100010000000100100000001001000000010001000010001001100100001000000101000000001000000000010000001001000001000000101000001000000000000000000100010000001000100000001000000000010000000011000010010100001000000000000000000000010000000000000001000100000000000001011111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int numberOfPoints(List<List<Integer>> nums) {\n        List<Data> nums_data = new ArrayList<>();\n        int n = nums.size();\n        for (List<Integer> i : nums){\n            nums_data.add(new Data(i.get(0),i.get(1)));\n        }\n        Collections.sort(nums_data);\n        LinkedList<Data> re = new LinkedList<>();\n        re.add(nums_data.get(0));\n        for (int i =1;i<n;i++){\n            Data d = re.getLast();\n            Data i_d = nums_data.get(i);\n            if (d.b>=i_d.a) {\n                d.b = Integer.max(d.b,i_d.b);\n            } else{\n                re.add(i_d);\n            }\n        }\n        int count = 0;\n        for (Data d: re){\n            count = count + d.b-d.a+1;\n        }\n        return count;\n    }\n}\n\nclass Data implements Comparable<Data>{\n    int a;\n    int b;\n    public Data (int x, int y){\n        a= x;\n        b = y;\n    }\n\n    @Override\n    public int compareTo(Data o){\n        if (a==o.a) return Integer.compare(b,o.b);\n        return Integer.compare(b,o.b);\n    }\n}","runtime":"N/A","title":"Points That Intersect With Cars","url":"/submissions/detail/1074625819/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1074625819,"time":"3 months, 2 weeks","lang":"java","title_slug":"points-that-intersect-with-cars","timestamp":1697242825,"status":11,"is_pending":"Not Pending","compare_result":"110001011001110101100110001011110001010000100101011110111010100011111101100100011111100000100101110100110011100110100110101101010100101100000110000110001111000000001000100011111010010110110110101100001010110001100100010011110001000010010111010101000110010001101100011110111111001101111101111101001010101000011100101001001000011110110111111111111011110110110011011111011010111100000001011011010110100000111110101010100000011101000101101100100011000011110100101111011001000100010000111100011111111011100100000001000110001001010000000010000100000001100010000000100100000001001000000010001000010001001100100001000000101000000001000000000010000001001000001000000101000001000000000000000000100010000001000100000001000000000010000000011000010010100001000000000000000000000010000000000000001000100000000000001011111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int numberOfPoints(List<List<Integer>> nums) {\n        List<Data> nums_data = new ArrayList<>();\n        int n = nums.size();\n        for (List<Integer> i : nums){\n            nums_data.add(new Data(i.get(0),i.get(1)));\n        }\n        Collections.sort(nums_data);\n        LinkedList<Data> re = new LinkedList<>();\n        re.add(nums_data.get(0));\n        for (int i =1;i<n;i++){\n            Data d = re.getLast();\n            Data i_d = nums_data.get(i);\n            if (d.b>i_d.a) {\n                d.b = Integer.max(d.b,i_d.b);\n            } else{\n                re.add(i_d);\n            }\n        }\n        int count = 0;\n        for (Data d: re){\n            count = count + d.b-d.a+1;\n        }\n        return count;\n    }\n}\n\nclass Data implements Comparable<Data>{\n    int a;\n    int b;\n    public Data (int x, int y){\n        a= x;\n        b = y;\n    }\n\n    @Override\n    public int compareTo(Data o){\n        if (a==o.a) return Integer.compare(b,o.b);\n        return Integer.compare(b,o.b);\n    }\n}","runtime":"N/A","title":"Points That Intersect With Cars","url":"/submissions/detail/1074625602/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1074625602,"time":"3 months, 2 weeks","lang":"java","title_slug":"points-that-intersect-with-cars","timestamp":1697242782,"status":11,"is_pending":"Not Pending","compare_result":"110001010100000001100100001011110001010000000100001111011010000001110100000000110111101000000100100100001111100110000100111001110100000000000110000100000100000010011000110011101000000111011100110110010010111110100000010001111011101010000111011101000010000000011001001010000011010000001001010101011000100000001100101001001100011110001011011101001011100100001011010111001000110000000000010101001001000000101010001010111000011000000101100101100111000000110100001001011001100000100000111000011011011101101100000000100000100000010000000000000100000001100000000000001000000001011000000010100100001001000000100001000000000000000000000000000000000001000000000010000001000001000000000000000000100001000100000000000001000000000010000001010000010000100000000000000000000000000010000000001000001000100000010000001011011"},{"status_display":"Accepted","memory":"43.6 MB","code":"class Solution {\n    public int countSymmetricIntegers(int low, int high) {\n        int count = 0;\n        for (int i = low;i<=high;i++){\n            if (isSym(i)) count ++;\n        }\n        return count;\n        \n    }\n    public boolean isSym(int num){\n        String s = \"\" + num;\n        if (s.length()%2!=0) return false;\n        int left = 0;\n        int right = 0;\n        int n = s.length();\n        for (int i=0;i<n/2;i++){\n            left = left + s.charAt(i)-'0';\n            right = right + s.charAt(i+n/2)-'0';\n        }\n        return left==right;\n\n    }\n}","runtime":"27 ms","title":"  Count Symmetric Integers","url":"/submissions/detail/1074622122/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1074622122,"time":"3 months, 2 weeks","lang":"java","title_slug":"count-symmetric-integers","timestamp":1697242056,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"42.3 MB","code":"class Solution {\n    public boolean canBeEqual(String s1, String s2) {\n        String s1_1 = \"\"+s1.charAt(2)+s1.charAt(1)+s1.charAt(0)+s1.charAt(3);\n        String s1_2 = \"\"+s1.charAt(2)+s1.charAt(3)+s1.charAt(0)+s1.charAt(1);\n        String s1_3 = \"\"+s1.charAt(0)+s1.charAt(3)+s1.charAt(2)+s1.charAt(1);\n        return s1.equals(s2) || s1_1.equals(s2) || s1_2.equals(s2) || s1_3.equals(s2);\n    }\n}","runtime":"10 ms","title":"Check if Strings Can be Made Equal With Operations I","url":"/submissions/detail/1074620248/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1074620248,"time":"3 months, 2 weeks","lang":"java","title_slug":"check-if-strings-can-be-made-equal-with-operations-i","timestamp":1697241691,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public boolean canBeEqual(String s1, String s2) {\n        String s1_1 = \"\"+s1.charAt(2)+s1.charAt(1)+s1.charAt(0)+s1.charAt(3);\n        String s1_2 = \"\"+s1.charAt(2)+s1.charAt(3)+s1.charAt(0)+s1.charAt(1);\n        String s1_3 = \"\"+s1.charAt(0)+s1.charAt(3)+s1.charAt(2)+s1.charAt(2);\n        return s1.equals(s2) || s1_1.equals(s2) || s1_2.equals(s2) || s1_3.equals(s2);\n    }\n}","runtime":"N/A","title":"Check if Strings Can be Made Equal With Operations I","url":"/submissions/detail/1074619981/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1074619981,"time":"3 months, 2 weeks","lang":"java","title_slug":"check-if-strings-can-be-made-equal-with-operations-i","timestamp":1697241634,"status":11,"is_pending":"Not Pending","compare_result":"1101101111111110111111111111111111011111111111111111011111010011101101101111111111111111111111111111111011011111111100111111111111111111111011111111111111111101111111111111111110111111111111111111111111101111111111110111111111111111111111111111111111110101110111111111111001111011111011111101111111110101111110111010101110011101111111111110111111111111011111111110111111111111111111111110111011111111101111110111101110110111111011111101011111011110011111111111110011111111111111011011100001101110101100101111101101111111111111011111111110111001111011111111111101111111111111110111011111111110010111111110111011110111111111101111111111011111111111111101111111111111100011111011111011111101111111111110101101111111111011111011110111011111111111101111111111101101111111111111111111101111111111011111110011111111111111101111111011111111011101001111110110101011111111111101011111111111111101111011011111111111001101101111111011110111111111111111111111111111011110111011110111111111111010111111111101111111101"},{"status_display":"Accepted","memory":"41.2 MB","code":"class Solution {\n    public int furthestDistanceFromOrigin(String moves) {\n        int countL=0;\n        int countR=0;\n        int count = 0;\n        int n = moves.length();\n        for (int i = 0;i<n;i++){\n            if (moves.charAt(i)=='L') countL++;\n            if (moves.charAt(i)=='R') countR++;\n            if (moves.charAt(i)=='_') count++;\n        }\n        if (countL==countR) return count;\n        if (countL>countR) return countL+count-countR;\n        return countR+count-countL;\n        \n    }\n}","runtime":"1 ms","title":"Furthest Point From Origin","url":"/submissions/detail/1074618190/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1074618190,"time":"3 months, 2 weeks","lang":"java","title_slug":"furthest-point-from-origin","timestamp":1697241279,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"44.2 MB","code":"class Solution {\n    public boolean isAcronym(List<String> words, String s) {\n        StringBuilder sb = new StringBuilder();\n        for (String d:words){\n            sb.append(d.charAt(0));\n        }\n        return sb.toString().equals(s);\n        \n    }\n}","runtime":"1 ms","title":"Check if a String Is an Acronym of Words","url":"/submissions/detail/1074617067/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1074617067,"time":"3 months, 2 weeks","lang":"java","title_slug":"check-if-a-string-is-an-acronym-of-words","timestamp":1697241057,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"41.5 MB","code":"class Solution {\n    public int countPairs(List<Integer> nums, int target) {\n        int count = 0;\n        int n = nums.size();\n        for (int i = 0; i<n-1;i++){\n            for (int j = i+1;j<n;j++){\n                if (nums.get(i)+nums.get(j)<target) count++;\n            }\n        }\n        return count;\n        \n    }\n}","runtime":"2 ms","title":"Count Pairs Whose Sum is Less than Target","url":"/submissions/detail/1074616399/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1074616399,"time":"3 months, 2 weeks","lang":"java","title_slug":"count-pairs-whose-sum-is-less-than-target","timestamp":1697240931,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"40.6 MB","code":"class Solution {\n    public long maximumTripletValue(int[] nums) {\n        long max = 0;\n        int n = nums.length;\n        for (int i = 0; i<n-2;i++){\n            for (int j = i+1;j<n-1;j++){\n                for (int k = j+1;k<n;k++){\n                    long temp = (long)(nums[i]-nums[j])*nums[k];\n                    if (temp>max) max = temp;\n                }\n            }\n        }\n        return max;\n    }\n}","runtime":"3 ms","title":"Maximum Value of an Ordered Triplet I","url":"/submissions/detail/1074615354/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1074615354,"time":"3 months, 2 weeks","lang":"java","title_slug":"maximum-value-of-an-ordered-triplet-i","timestamp":1697240726,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public long maximumTripletValue(int[] nums) {\n        long max = 0;\n        int n = nums.length;\n        for (int i = 0; i<n-2;i++){\n            for (int j = i+1;j<n-1;j++){\n                for (int k = j+1;k<n;k++){\n                    long temp = (nums[i]-nums[j])*nums[k];\n                    if (temp>max) max = temp;\n                }\n            }\n        }\n        return max;\n    }\n}","runtime":"N/A","title":"Maximum Value of an Ordered Triplet I","url":"/submissions/detail/1074614941/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1074614941,"time":"3 months, 2 weeks","lang":"java","title_slug":"maximum-value-of-an-ordered-triplet-i","timestamp":1697240649,"status":11,"is_pending":"Not Pending","compare_result":"111110111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000100000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000100000000001001000000000000000000100010000000000000000000000100000000000000000000001000000000000000000000000000000010000000000000000000001000000000000000000000000000000000000000000000000000000000001"}],"has_next":true,"last_key":"%7B%22pk%22%3A%20%7B%22N%22%3A%20%221074614941%22%7D%2C%20%22dt%22%3A%20%7B%22S%22%3A%20%222023-10-13T23%3A44%3A09.198066%2B0000%22%7D%2C%20%22sid%22%3A%20%7B%22N%22%3A%20%227573785%22%7D%7D"}
2024-01-26 23:39:40.166 [main] DEBUG submission_dump - {"submissions_dump":[{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public long maximumTripletValue(int[] nums) {\n        int max = 0;\n        int n = nums.length;\n        for (int i = 0; i<n-2;i++){\n            for (int j = i+1;j<n-1;j++){\n                for (int k = j+1;k<n;k++){\n                    int temp = (nums[i]-nums[j])*nums[k];\n                    if (temp>max) max = temp;\n                }\n            }\n        }\n        return max;\n    }\n}","runtime":"N/A","title":"Maximum Value of an Ordered Triplet I","url":"/submissions/detail/1074614751/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1074614751,"time":"3 months, 2 weeks","lang":"java","title_slug":"maximum-value-of-an-ordered-triplet-i","timestamp":1697240613,"status":11,"is_pending":"Not Pending","compare_result":"111110111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000100000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000100000000001001000000000000000000100010000000000000000000000100000000000000000000001000000000000000000000000000000010000000000000000000001000000000000000000000000000000000000000000000000000000000001"},{"status_display":"Accepted","memory":"40.8 MB","code":"class Solution {\n    public int minOperations(List<Integer> nums, int k) {\n        HashSet<Integer> check= new HashSet<>();\n        int n = nums.size();\n        Collections.reverse(nums);\n        int count =0;\n        for (int i = 0;i<n;i++){\n            if (nums.get(i)<=k && nums.get(i)>=1 && !check.contains(nums.get(i))){\n                count++;\n                check.add(nums.get(i));\n            }\n            if (count == k ){\n                return i+1;\n            }\n        }\n        return 0;\n\n        \n    }\n}","runtime":"2 ms","title":"Minimum Operations to Collect Elements","url":"/submissions/detail/1074613638/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1074613638,"time":"3 months, 2 weeks","lang":"java","title_slug":"minimum-operations-to-collect-elements","timestamp":1697240394,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"44 MB","code":"class Solution {\n    public String maximumOddBinaryNumber(String s) {\n        char [] c = s.toCharArray();\n        int n = s.length();\n        int count = 0;\n        for (char i: c){\n            if (i=='1'){\n                count ++;\n            }\n        }\n        \n        String re = \"\";\n        count --;\n        for (int i = 0;i<count;i++){\n            re='1'+re;\n        }\n        for (int i=0;i<n-count-1;i++){\n            re=re + \"0\";\n        }\n        return re+\"1\";\n    }\n}","runtime":"3 ms","title":"Maximum Odd Binary Number","url":"/submissions/detail/1074610512/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1074610512,"time":"3 months, 2 weeks","lang":"java","title_slug":"maximum-odd-binary-number","timestamp":1697239804,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"40.1 MB","code":"class Solution {\n    public int differenceOfSums(int n, int m) {\n        int l = (n/m) * m;\n        int sum2 = (m+l)*((l-m)/m+1)/2;\n        int sum = (n+1)*n /2;\n        int sum1 = sum - sum2;\n        // System.out.println(sum1 + \" \" + sum2);\n        return sum1-sum2;\n        \n    }\n}","runtime":"0 ms","title":"Divisible and Non-divisible Sums Difference","url":"/submissions/detail/1074609403/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1074609403,"time":"3 months, 2 weeks","lang":"java","title_slug":"divisible-and-non-divisible-sums-difference","timestamp":1697239586,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"40.6 MB","code":"class Solution {\n    public int hIndex(int[] citations) {\n        Arrays.sort(citations);\n        int count = 0;\n        for (int i = citations.length-1;i>=0;i--){\n            System.out.println(citations[i]);\n            if (citations[i]<=count) break;\n            \n            count++;\n        }\n\n        return count;\n        \n    }\n}","runtime":"8 ms","title":"H-Index","url":"/submissions/detail/1074543534/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1074543534,"time":"3 months, 2 weeks","lang":"java","title_slug":"h-index","timestamp":1697229253,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"41.8 MB","code":"class Solution {\n    public int numberOfEmployeesWhoMetTarget(int[] hours, int target) {\n        int re = 0;\n        for (int i: hours){\n            if (i>= target) re ++;\n        }\n        return re;\n        \n    }\n}","runtime":"0 ms","title":"Number of Employees Who Met the Target","url":"/submissions/detail/1073946748/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1073946748,"time":"3 months, 2 weeks","lang":"java","title_slug":"number-of-employees-who-met-the-target","timestamp":1697166764,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"43.6 MB","code":"class Solution {\n    public boolean isPalindrome(String s) {\n        StringBuilder sb = new StringBuilder();\n        s = s.toLowerCase();\n        for (int i = 0; i< s.length();i++){\n            char t = s.charAt(i);\n            if ((t<='z' && t >='a') || (t>='0' && t<='9')){\n                sb.append(t);\n            }\n        }\n        String st = \"\";\n        st = sb.toString();\n        if (st.length()<2) return true;\n        for (int i = 0;i<st.length()/2;i++){\n            if (st.charAt(i)!=st.charAt(st.length()-i-1)) return false;\n        }\n    return true;\n    }\n}","runtime":"3 ms","title":"Valid Palindrome","url":"/submissions/detail/1073850664/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1073850664,"time":"3 months, 2 weeks","lang":"java","title_slug":"valid-palindrome","timestamp":1697152587,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"44.9 MB","code":"class Solution {\n    public boolean isPalindrome(String s) {\n\n        String st = \"\";\n        s = s.toLowerCase();\n        for (int i = 0; i< s.length();i++){\n            char t = s.charAt(i);\n            if ((t<='z' && t >='a') || (t>='0' && t<='9')){\n                st = st + t;\n            }\n        }\n        if (st.length()<2) return true;\n        for (int i = 0;i<st.length()/2;i++){\n            if (st.charAt(i)!=st.charAt(st.length()-i-1)) return false;\n        }\n    return true;\n    }\n}","runtime":"128 ms","title":"Valid Palindrome","url":"/submissions/detail/1073849705/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1073849705,"time":"3 months, 2 weeks","lang":"java","title_slug":"valid-palindrome","timestamp":1697152429,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"45 MB","code":"class Solution {\n    public boolean isPalindrome(String s) {\n\n        String st = \"\";\n        s = s.toLowerCase();\n        for (int i = 0; i< s.length();i++){\n            char t = s.charAt(i);\n            if ((t<='z' && t >='a') || (t>='0' && t<='9')){\n                st = st + t;\n            }\n        }\n        if (st.length()<2) return true;\n        for (int i = 0;i<st.length()/2;i++){\n            if (st.charAt(i)!=st.charAt(st.length()-i-1)) return false;\n        }\n    return true;\n    }\n}","runtime":"131 ms","title":"Valid Palindrome","url":"/submissions/detail/1073849633/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1073849633,"time":"3 months, 2 weeks","lang":"java","title_slug":"valid-palindrome","timestamp":1697152418,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"45 MB","code":"class Solution {\n    public boolean isPalindrome(String s) {\n\n        String st = \"\";\n        s = s.toLowerCase();\n        for (int i = 0; i< s.length();i++){\n            char t = s.charAt(i);\n            if ((t<='z' && t >='a') || (t>='0' && t<='9')){\n                st = st + t;\n            }\n        }\n        if (st.length()<2) return true;\n        for (int i = 0;i<st.length();i++){\n            if (st.charAt(i)!=st.charAt(st.length()-i-1)) return false;\n        }\n    return true;\n    }\n}","runtime":"126 ms","title":"Valid Palindrome","url":"/submissions/detail/1073849341/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1073849341,"time":"3 months, 2 weeks","lang":"java","title_slug":"valid-palindrome","timestamp":1697152370,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public boolean isPalindrome(String s) {\n\n        String st = \"\";\n        s = s.toLowerCase();\n        for (int i = 0; i< s.length();i++){\n            char t = s.charAt(i);\n            if (t<='z' && t >='a'){\n                st = st + t;\n            }\n        }\n        if (st.length()<2) return true;\n        for (int i = 0;i<st.length();i++){\n            if (st.charAt(i)!=st.charAt(st.length()-i-1)) return false;\n        }\n    return true;\n    }\n}","runtime":"N/A","title":"Valid Palindrome","url":"/submissions/detail/1073848988/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1073848988,"time":"3 months, 2 weeks","lang":"java","title_slug":"valid-palindrome","timestamp":1697152308,"status":11,"is_pending":"Not Pending","compare_result":"11111111111011111110110111111101111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100111111101111101111101110101111110111111111111111011101101111010111111111011101101011111111111110011111111"},{"status_display":"Accepted","memory":"45.6 MB","code":"class Solution {\n\n    public int[][] merge(int[][] inp) {\n        int n = inp.length;\n        ArrayList<Pair> l = new ArrayList<>();\n        LinkedList<Pair> m = new LinkedList<>();\n\n        for (int[] i : inp){\n            l.add(new Pair(i[0],i[1]));\n        }\n        Collections.sort(l);\n        \n        m.add(l.get(0));\n        for (int i = 1;i<n;i++){\n            Pair pointer_m = m.getLast();\n            Pair pointer_l = l.get(i);\n            if (pointer_m.b>=pointer_l.a){\n                pointer_m.b = Integer.max(pointer_m.b, pointer_l.b);\n            } else{\n                m.add(pointer_l);\n            }\n        }\n        // System.out.println(m.size());\n        int [][] re = new int[m.size()][2];\n        int count = 0;\n        for (Pair i : m){\n            re[count][0] = i.a;\n            re[count][1] = i.b;\n            count++;\n        }\n        return re;\n    }\n}\nclass Pair implements Comparable<Pair>{\n    int a;\n    int b;\n    public Pair(int x, int y){\n        a = x;\n        b = y;\n\n    }\n    @Override\n    public int compareTo(Pair o){\n        if (a == o.a) return Integer.compare(b,o.b);\n        return Integer.compare(a,o.a);\n    }\n\n    @Override\n    public String toString(){\n        return a+\" \"+b;\n    }\n}","runtime":"9 ms","title":"Merge Intervals","url":"/submissions/detail/1073841303/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1073841303,"time":"3 months, 2 weeks","lang":"java","title_slug":"merge-intervals","timestamp":1697151078,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n\n    public int[][] merge(int[][] inp) {\n        int n = inp.length;\n        ArrayList<Pair> l = new ArrayList<>();\n        LinkedList<Pair> m = new LinkedList<>();\n\n        for (int[] i : inp){\n            l.add(new Pair(i[0],i[1]));\n        }\n        Collections.sort(l);\n        \n        m.add(l.get(0));\n        for (int i = 1;i<n;i++){\n            Pair pointer_m = m.getLast();\n            Pair pointer_l = l.get(i);\n            if (pointer_m.b>=pointer_l.a){\n                pointer_m.b = pointer_l.b;\n            } else{\n                m.add(pointer_l);\n            }\n        }\n        // System.out.println(m.size());\n        int [][] re = new int[m.size()][2];\n        int count = 0;\n        for (Pair i : m){\n            re[count][0] = i.a;\n            re[count][1] = i.b;\n            count++;\n        }\n        return re;\n    }\n}\nclass Pair implements Comparable<Pair>{\n    int a;\n    int b;\n    public Pair(int x, int y){\n        a = x;\n        b = y;\n\n    }\n    @Override\n    public int compareTo(Pair o){\n        if (a == o.a) return Integer.compare(b,o.b);\n        return Integer.compare(a,o.a);\n    }\n\n    @Override\n    public String toString(){\n        return a+\" \"+b;\n    }\n}","runtime":"N/A","title":"Merge Intervals","url":"/submissions/detail/1073840906/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1073840906,"time":"3 months, 2 weeks","lang":"java","title_slug":"merge-intervals","timestamp":1697151015,"status":11,"is_pending":"Not Pending","compare_result":"11111111110011101110111110111111111111110111111111111111101111111011111111110111101101110111111010101110101111111111110110011101100001001100010110000000000000000000000111"},{"status_display":"Accepted","memory":"43.9 MB","code":"class Solution {\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n        \n        HashSet<String> dict = new HashSet<String>(wordList);\n        if (!dict.contains(endWord)) return new ArrayList<>();\n        dict.add(beginWord);\n        System.out.println(dict.size());\n        List<List<String>> re = new ArrayList<>();\n        HashMap<String,HashSet<String>> map = new HashMap<>();\n\n        for (String s: dict){\n            map.put(s, new HashSet<>());\n        }\n        \n        for (String s1: dict){\n            for (String s2: dict){\n                if (!s1.equals(s2)){\n                    if (comp(s1,s2))\n                        map.get(s1).add(s2);\n                }\n            }\n        }\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        HashMap<String,Integer> shortPath = new HashMap<>();\n        HashMap<String,HashSet<String>> tracer = new HashMap<>();\n\n        for (String s: dict){\n            shortPath.put(s,Integer.MAX_VALUE);\n            tracer.put(s,new HashSet<>());\n        }\n\n        shortPath.put(beginWord,1);\n        \n        bfs.add(beginWord);\n        // int size = 1;\n        while (!bfs.isEmpty()){\n            String cur = bfs.poll();\n\n            if (!visited.contains(cur)){\n                visited.add(cur);\n                if (cur.equals(endWord)) break;\n                    for (String s: map.get(cur)){\n                        if (!visited.contains(s)){\n                            bfs.add(s);\n                            int min = shortPath.get(s);\n                            if (shortPath.get(cur)+1<=min){\n                                min = shortPath.get(cur)+1;\n                                shortPath.put(s,min);\n                                tracer.get(s).add(cur);\n                            }\n                        }\n                    }\n            }\n            \n        }\n\n        List<String> temp = new ArrayList<String>();\n        // System.out.println(shortPath.get(endWord));\n        gen(tracer,re,temp,beginWord,endWord);\n        return re;\n    }\n\n    public boolean comp(String s1, String s2){\n        if (s1.length()!=s2.length()) return false;\n        int n = s1.length(); \n        int count =0;\n        for (int i = 0;i<n;i++){\n            if (s1.charAt(i)!=s2.charAt(i))\n                count++;\n            if (count>1) return false;\n        }\n        return true;\n\n    }\n\n    public void gen(HashMap<String,HashSet<String>> tracer,List<List<String>> re, List<String> temp, String beginWord, String cur){\n        temp.add(cur);\n        // System.out.print(cur+\" \");\n        for (String s: tracer.get(cur)){\n            gen(tracer,re,temp,beginWord,s);\n        }\n        if (cur.equals(beginWord)){\n            List<String> t = new ArrayList<>(temp);\n            Collections.reverse(t);\n            re.add(t);\n            // System.out.println();\n        }\n        temp.remove(cur);\n        \n    }   \n}","runtime":"41 ms","title":"Word Ladder II","url":"/submissions/detail/1073833042/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1073833042,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder-ii","timestamp":1697149783,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"43.8 MB","code":"class Solution {\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n        \n        HashSet<String> dict = new HashSet<String>(wordList);\n        if (!dict.contains(endWord)) return new ArrayList<>();\n        dict.add(beginWord);\n        System.out.println(dict.size());\n        List<List<String>> re = new ArrayList<>();\n        HashMap<String,HashSet<String>> map = new HashMap<>();\n\n        for (String s: dict){\n            map.put(s, new HashSet<>());\n        }\n        \n        for (String s1: dict){\n            for (String s2: dict){\n                if (!s1.equals(s2)){\n                    if (comp(s1,s2))\n                        map.get(s1).add(s2);\n                }\n            }\n        }\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        HashMap<String,Integer> shortPath = new HashMap<>();\n        HashMap<String,HashSet<String>> tracer = new HashMap<>();\n\n        for (String s: dict){\n            shortPath.put(s,Integer.MAX_VALUE);\n            tracer.put(s,new HashSet<>());\n        }\n\n        shortPath.put(beginWord,1);\n        \n        bfs.add(beginWord);\n        // int size = 1;\n        while (!bfs.isEmpty()){\n            String cur = bfs.poll();\n            // System.out.println(cur);\n            // System.out.println(visited.size());\n            if (!visited.contains(cur)){\n                visited.add(cur);\n                if (cur.equals(endWord)) break;\n                    for (String s: map.get(cur)){\n                        if (!visited.contains(s)){\n                            bfs.add(s);\n                            int min = shortPath.get(s);\n                            if (shortPath.get(cur)+1<=min){\n                                min = shortPath.get(cur)+1;\n                                shortPath.put(s,min);\n                                tracer.get(s).add(cur);\n                            }\n                        }\n                    }\n            }\n            \n        }\n\n        List<String> temp = new ArrayList<String>();\n        // System.out.println(shortPath.get(endWord));\n        gen(tracer,re,temp,beginWord,endWord);\n        return re;\n    }\n\n    public boolean comp(String s1, String s2){\n        if (s1.length()!=s2.length()) return false;\n        int n = s1.length(); \n        int count =0;\n        for (int i = 0;i<n;i++){\n            if (s1.charAt(i)!=s2.charAt(i))\n                count++;\n            if (count>1) return false;\n        }\n        return true;\n\n    }\n\n    public void gen(HashMap<String,HashSet<String>> tracer,List<List<String>> re, List<String> temp, String beginWord, String cur){\n        temp.add(cur);\n        // System.out.print(cur+\" \");\n        for (String s: tracer.get(cur)){\n            gen(tracer,re,temp,beginWord,s);\n        }\n        if (cur.equals(beginWord)){\n            List<String> t = new ArrayList<>(temp);\n            Collections.reverse(t);\n            re.add(t);\n            // System.out.println();\n        }\n        temp.remove(cur);\n        \n    }   \n}","runtime":"39 ms","title":"Word Ladder II","url":"/submissions/detail/1073832870/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1073832870,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder-ii","timestamp":1697149757,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111"},{"status_display":"Time Limit Exceeded","memory":"N/A","code":"class Solution {\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n        \n        HashSet<String> dict = new HashSet<String>(wordList);\n        if (!dict.contains(endWord)) return new ArrayList<>();\n        dict.add(beginWord);\n\n        List<List<String>> re = new ArrayList<>();\n        HashMap<String,HashSet<String>> map = new HashMap<>();\n\n        for (String s: dict){\n            map.put(s, new HashSet<>());\n        }\n        \n        for (String s1: dict){\n            for (String s2: dict){\n                if (!s1.equals(s2)){\n                    if (comp(s1,s2))\n                        map.get(s1).add(s2);\n                }\n            }\n        }\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        HashMap<String,Integer> shortPath = new HashMap<>();\n        HashMap<String,HashSet<String>> tracer = new HashMap<>();\n\n        for (String s: dict){\n            shortPath.put(s,Integer.MAX_VALUE);\n            tracer.put(s,new HashSet<>());\n        }\n\n        shortPath.put(beginWord,1);\n        \n        bfs.add(beginWord);\n        // int size = 1;\n        while (!bfs.isEmpty()){\n            String cur = bfs.poll();\n            // System.out.println(cur);\n            visited.add(cur);\n            if (cur.equals(endWord)) break;\n                for (String s: map.get(cur)){\n                    if (!visited.contains(s)){\n                        bfs.add(s);\n                        int min = shortPath.get(s);\n                        if (shortPath.get(cur)+1<=min){\n                            min = shortPath.get(cur)+1;\n                            shortPath.put(s,min);\n                            tracer.get(s).add(cur);\n                        }\n                    }\n                }\n        }\n\n        List<String> temp = new ArrayList<String>();\n        System.out.println(shortPath.get(endWord));\n        gen(tracer,re,temp,beginWord,endWord);\n        return re;\n    }\n\n    public boolean comp(String s1, String s2){\n        if (s1.length()!=s2.length()) return false;\n        int n = s1.length(); \n        int count =0;\n        for (int i = 0;i<n;i++){\n            if (s1.charAt(i)!=s2.charAt(i))\n                count++;\n            if (count>1) return false;\n        }\n        return true;\n\n    }\n\n    public void gen(HashMap<String,HashSet<String>> tracer,List<List<String>> re, List<String> temp, String beginWord, String cur){\n        temp.add(cur);\n        // System.out.print(cur+\" \");\n        for (String s: tracer.get(cur)){\n            gen(tracer,re,temp,beginWord,s);\n        }\n        if (cur.equals(beginWord)){\n            List<String> t = new ArrayList<>(temp);\n            Collections.reverse(t);\n            re.add(t);\n            // System.out.println();\n        }\n        temp.remove(cur);\n        \n    }   \n}","runtime":"N/A","title":"Word Ladder II","url":"/submissions/detail/1073807323/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1073807323,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder-ii","timestamp":1697146236,"status":14,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111110000"},{"status_display":"Time Limit Exceeded","memory":"N/A","code":"class Solution {\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n        \n        HashSet<String> dict = new HashSet<String>(wordList);\n        if (!dict.contains(endWord)) return new ArrayList<>();\n        dict.add(beginWord);\n\n        List<List<String>> re = new ArrayList<>();\n        HashMap<String,HashSet<String>> map = new HashMap<>();\n\n        for (String s: dict){\n            map.put(s, new HashSet<>());\n        }\n        \n        for (String s1: dict){\n            for (String s2: dict){\n                if (!s1.equals(s2)){\n                    if (comp(s1,s2))\n                        map.get(s1).add(s2);\n                }\n            }\n        }\n\n        // for (String s: dict){\n        //     System.out.print(s+\": \");\n        //         for (String si: map.get(s)){\n        //             System.out.print(si+\" \");\n        //         }\n        //     System.out.println();\n        // }\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        HashMap<String,Integer> shortPath = new HashMap<>();\n        HashMap<String,HashSet<String>> tracer = new HashMap<>();\n\n        for (String s: dict){\n            shortPath.put(s,Integer.MAX_VALUE);\n            tracer.put(s,new HashSet<>());\n        }\n\n        shortPath.put(beginWord,1);\n        \n        bfs.add(beginWord);\n        // int size = 1;\n        while (!bfs.isEmpty()){\n            String cur = bfs.poll();\n            // System.out.println(cur);\n            visited.add(cur);\n            if (cur.equals(endWord)) break;\n                for (String s: map.get(cur)){\n                    if (!visited.contains(s)){\n                        bfs.add(s);\n                        int min = shortPath.get(s);\n                        if (shortPath.get(cur)+1<=min){\n                            min = shortPath.get(cur)+1;\n                            shortPath.put(s,min);\n                            tracer.get(s).add(cur);\n                        }\n                    }\n                }\n        }\n        // System.out.println(shortPath.get(endWord));\n        // for (String s: dict){\n        //     System.out.print(s+\": \" + shortPath.get(s)+\": \");\n        //         for (String si: tracer.get(s)){\n        //             System.out.print(si+\" \");\n        //         }\n        //     System.out.println();\n        // }\n        List<String> temp = new ArrayList<String>();\n        System.out.println(shortPath.get(endWord));\n        gen(tracer,re,temp,beginWord,endWord);\n        return re;\n    }\n\n    public boolean comp(String s1, String s2){\n        if (s1.length()!=s2.length()) return false;\n        int n = s1.length(); \n        int count =0;\n        for (int i = 0;i<n;i++){\n            if (s1.charAt(i)!=s2.charAt(i))\n                count++;\n            if (count>1) return false;\n        }\n        return true;\n\n    }\n\n    public void gen(HashMap<String,HashSet<String>> tracer,List<List<String>> re, List<String> temp, String beginWord, String cur){\n        temp.add(cur);\n        // System.out.print(cur+\" \");\n        for (String s: tracer.get(cur)){\n            gen(tracer,re,temp,beginWord,s);\n        }\n        if (cur.equals(beginWord)){\n            List<String> t = new ArrayList<>(temp);\n            Collections.reverse(t);\n            re.add(t);\n            // System.out.println();\n        }\n        temp.remove(cur);\n        \n    }   \n}","runtime":"N/A","title":"Word Ladder II","url":"/submissions/detail/1073806540/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1073806540,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder-ii","timestamp":1697146139,"status":14,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111110000"},{"status_display":"Time Limit Exceeded","memory":"N/A","code":"class Solution {\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n        \n        HashSet<String> dict = new HashSet<String>(wordList);\n        if (!dict.contains(endWord)) return new ArrayList<>();\n        dict.add(beginWord);\n\n        List<List<String>> re = new ArrayList<>();\n        HashMap<String,HashSet<String>> map = new HashMap<>();\n\n        for (String s: dict){\n            map.put(s, new HashSet<>());\n        }\n        \n        for (String s1: dict){\n            for (String s2: dict){\n                if (!s1.equals(s2)){\n                    if (comp(s1,s2))\n                        map.get(s1).add(s2);\n                }\n            }\n        }\n\n        // for (String s: dict){\n        //     System.out.print(s+\": \");\n        //         for (String si: map.get(s)){\n        //             System.out.print(si+\" \");\n        //         }\n        //     System.out.println();\n        // }\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        HashMap<String,Integer> shortPath = new HashMap<>();\n        HashMap<String,HashSet<String>> tracer = new HashMap<>();\n\n        for (String s: dict){\n            shortPath.put(s,Integer.MAX_VALUE);\n            tracer.put(s,new HashSet<>());\n        }\n\n        shortPath.put(beginWord,1);\n        \n        bfs.add(beginWord);\n        // int size = 1;\n        while (!bfs.isEmpty()){\n            String cur = bfs.poll();\n            // System.out.println(cur);\n            visited.add(cur);\n            if (cur.equals(endWord)) break;\n                for (String s: map.get(cur)){\n                    if (!visited.contains(s)){\n                        bfs.add(s);\n                        int min = shortPath.get(s);\n                        if (shortPath.get(cur)+1<=min){\n                            min = shortPath.get(cur)+1;\n                            shortPath.put(s,min);\n                            tracer.get(s).add(cur);\n                        }\n                    }\n                }\n        }\n        // System.out.println(shortPath.get(endWord));\n        // for (String s: dict){\n        //     System.out.print(s+\": \" + shortPath.get(s)+\": \");\n        //         for (String si: tracer.get(s)){\n        //             System.out.print(si+\" \");\n        //         }\n        //     System.out.println();\n        // }\n        List<String> temp = new ArrayList<String>();\n        gen(tracer,re,temp,beginWord,endWord);\n        return re;\n    }\n\n    public boolean comp(String s1, String s2){\n        if (s1.length()!=s2.length()) return false;\n        int n = s1.length(); \n        int count =0;\n        for (int i = 0;i<n;i++){\n            if (s1.charAt(i)!=s2.charAt(i))\n                count++;\n            if (count>1) return false;\n        }\n        return true;\n\n    }\n\n    public void gen(HashMap<String,HashSet<String>> tracer,List<List<String>> re, List<String> temp, String beginWord, String cur){\n        temp.add(cur);\n        // System.out.print(cur+\" \");\n        for (String s: tracer.get(cur)){\n            gen(tracer,re,temp,beginWord,s);\n        }\n        if (cur.equals(beginWord)){\n            List<String> t = new ArrayList<>(temp);\n            Collections.reverse(t);\n            re.add(t);\n            // System.out.println();\n        }\n        temp.remove(cur);\n        \n    }   \n}","runtime":"N/A","title":"Word Ladder II","url":"/submissions/detail/1073803125/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1073803125,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder-ii","timestamp":1697145719,"status":14,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111110000"},{"status_display":"Accepted","memory":"44.5 MB","code":"class Solution {\n    public int jump(int[] nums) {\n        int n = nums.length;\n        if (n==1) return 0;\n        int max = 0 + nums[0];\n        int cap = nums[0];\n        int re = 1;\n        for (int i = 1;i<n-1;i++){\n            if (i+ nums[i]>max) {\n                max = i+ nums[i];\n            }\n            if (i == cap){\n                cap = max;\n                re++;\n            }\n        }\n        return re;\n        \n    }\n}","runtime":"1 ms","title":"Jump Game II","url":"/submissions/detail/1073199266/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1073199266,"time":"3 months, 2 weeks","lang":"java","title_slug":"jump-game-ii","timestamp":1697088490,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"44.7 MB","code":"class Solution {\n    public int jump(int[] nums) {\n        int n = nums.length;\n        if (n==1) return 0;\n        int max = 0 + nums[0];\n        int cap = nums[0];\n        int re = 1;\n        for (int i = 1;i<n-1;i++){\n            if (i+ nums[i]>max) {\n                max = i+ nums[i];\n            }\n            if (i == cap){\n                cap = max;\n                re++;\n            }\n        }\n        return re;\n        \n    }\n}","runtime":"1 ms","title":"Jump Game II","url":"/submissions/detail/1073199147/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1073199147,"time":"3 months, 2 weeks","lang":"java","title_slug":"jump-game-ii","timestamp":1697088478,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}],"has_next":true,"last_key":"%7B%22pk%22%3A%20%7B%22N%22%3A%20%221073199147%22%7D%2C%20%22dt%22%3A%20%7B%22S%22%3A%20%222023-10-12T05%3A27%3A58.451936%2B0000%22%7D%2C%20%22sid%22%3A%20%7B%22N%22%3A%20%227573785%22%7D%7D"}
2024-01-26 23:39:50.625 [main] DEBUG submission_dump - {"submissions_dump":[{"status_display":"Accepted","memory":"43.9 MB","code":"class Solution {\n    public int jump(int[] nums) {\n        int n = nums.length;\n        if (n==1) return 0;\n        int [] maxPos = new int [n];\n        for(int i = 0;i<n;i++){\n            maxPos[i] = i + nums[i];\n        }\n        int max = maxPos[0];\n        int cap = nums[0];\n        int re = 1;\n        for (int i = 1;i<n-1;i++){\n            if (maxPos[i]>max) {\n                max = maxPos[i];\n            }\n            if (i == cap){\n                cap = max;\n                re++;\n            }\n        }\n        return re;\n        \n    }\n}","runtime":"1 ms","title":"Jump Game II","url":"/submissions/detail/1073198455/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1073198455,"time":"3 months, 2 weeks","lang":"java","title_slug":"jump-game-ii","timestamp":1697088410,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"44.4 MB","code":"class Solution {\n    public int jump(int[] nums) {\n        int n = nums.length;\n        if (n==1) return 0;\n        int [] maxPos = new int [n];\n        for(int i = 0;i<n;i++){\n            maxPos[i] = i + nums[i];\n        }\n        int max = maxPos[0];\n        int cap = nums[0];\n        int re = 1;\n        int count = 0;\n        int temp = 0;\n        for (int i = 1;i<n-1;i++){\n            if (maxPos[i]>max) {\n                max = maxPos[i];\n                temp = nums[i];\n            }\n            // count++;\n            if (i == cap){\n                cap = max;\n                // count = 0;\n                re++;\n            }\n        }\n        return re;\n        \n    }\n}","runtime":"2 ms","title":"Jump Game II","url":"/submissions/detail/1073198211/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1073198211,"time":"3 months, 2 weeks","lang":"java","title_slug":"jump-game-ii","timestamp":1697088385,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int jump(int[] nums) {\n        int n = nums.length;\n        if (n==1) return 0;\n        int [] maxPos = new int [n];\n        for(int i = 0;i<n;i++){\n            maxPos[i] = i + nums[i];\n        }\n        int max = maxPos[0];\n        int cap = nums[0];\n        int re = 0;\n        int count = 0;\n        int temp = 0;\n        for (int i = 1;i<n;i++){\n            if (maxPos[i]>max) {\n                max = maxPos[i];\n                temp = nums[i];\n            }\n            count++;\n            if (count == 1) re ++;\n            if (count == cap){\n                cap = temp;\n                count = 0;\n            }\n        }\n        return re;\n        \n    }\n}","runtime":"N/A","title":"Jump Game II","url":"/submissions/detail/1073191094/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1073191094,"time":"3 months, 2 weeks","lang":"java","title_slug":"jump-game-ii","timestamp":1697087684,"status":11,"is_pending":"Not Pending","compare_result":"1111111111111111111111111101111101011111111111111111111111111111111010100111001101000000100000111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int jump(int[] nums) {\n        int n = nums.length;\n        if (n==1) return 0;\n        int [] maxPos = new int [n];\n        for(int i = 0;i<n;i++){\n            maxPos[i] = i + nums[i];\n        }\n        int max = maxPos[0];\n        int cap = nums[0];\n        int re = 0;\n        int count = 0;\n        for (int i = 1;i<n;i++){\n            if (maxPos[i]>max) max = maxPos[i];\n            count++;\n            if (count == 1) re ++;\n            if (count == cap){\n                cap = max;\n                count = 0;\n            }\n        }\n        return re;\n        \n    }\n}","runtime":"N/A","title":"Jump Game II","url":"/submissions/detail/1073189748/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1073189748,"time":"3 months, 2 weeks","lang":"java","title_slug":"jump-game-ii","timestamp":1697087554,"status":11,"is_pending":"Not Pending","compare_result":"1111111111011100100111110101111101011100001111111111010110111010000010000000000000000000000000010000001100111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int jump(int[] nums) {\n        int n = nums.length;\n        if (n==1) return 0;\n        int [] maxPos = new int [n];\n        for(int i = 0;i<n;i++){\n            maxPos[i] = i + nums[i];\n        }\n        int max = maxPos[0];\n        int cap = nums[0];\n        int re = 1;\n        int count = 0;\n        for (int i = 1;i<n;i++){\n            if (maxPos[i]>max) max = maxPos[i];\n            count++;\n            if (count == cap){\n                cap = max;\n                re ++;\n                count = 0;\n            }\n        }\n        return re;\n        \n    }\n}","runtime":"N/A","title":"Jump Game II","url":"/submissions/detail/1073187160/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1073187160,"time":"3 months, 2 weeks","lang":"java","title_slug":"jump-game-ii","timestamp":1697087300,"status":11,"is_pending":"Not Pending","compare_result":"1111011110111100110111111100111101011111101011110111010110111110000010000000000000000000000000010000000100100"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int jump(int[] nums) {\n        if (nums[0] == 0) return 0;\n        int n = nums.length;\n        int [] maxPos = new int [n];\n        for(int i = 0;i<n;i++){\n            maxPos[i] = i + nums[i];\n        }\n        int max = maxPos[0];\n        int cap = nums[0];\n        int re = 1;\n        int count = 0;\n        for (int i = 1;i<n;i++){\n            if (maxPos[i]>max) max = maxPos[i];\n            count++;\n            if (count == cap){\n                cap = max;\n                re ++;\n                count = 0;\n            }\n        }\n        return re;\n        \n    }\n}","runtime":"N/A","title":"Jump Game II","url":"/submissions/detail/1073186903/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1073186903,"time":"3 months, 2 weeks","lang":"java","title_slug":"jump-game-ii","timestamp":1697087274,"status":11,"is_pending":"Not Pending","compare_result":"1110011110111100110111111100111101011111101011110111010110111110000010000000000000000000000000010000000100100"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int jump(int[] nums) {\n        int n = nums.length;\n        int [] maxPos = new int [n];\n        for(int i = 0;i<n;i++){\n            maxPos[i] = i + nums[i];\n        }\n        int max = maxPos[0];\n        int cap = nums[0];\n        int re = 1;\n        int count = 0;\n        for (int i = 1;i<n;i++){\n            if (maxPos[i]>max) max = maxPos[i];\n            count++;\n            if (count == cap){\n                cap = max;\n                re ++;\n                count = 0;\n            }\n        }\n        return re;\n        \n    }\n}","runtime":"N/A","title":"Jump Game II","url":"/submissions/detail/1073186404/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1073186404,"time":"3 months, 2 weeks","lang":"java","title_slug":"jump-game-ii","timestamp":1697087229,"status":11,"is_pending":"Not Pending","compare_result":"1100011110111100110111111100111101011111101011110111010110111110000010000000000000000000000000010000000100100"},{"status_display":"Accepted","memory":"43.6 MB","code":"class Solution {\n    public int swimInWater(int[][] grid) {\n        int n = grid.length;\n        PriorityQueue<Data> q = new PriorityQueue<>();\n\n        int cur_x = n-1;\n        int cur_y = n-1;\n        q.add(new Data(grid[cur_x][cur_y],cur_x,cur_y));\n        int max = grid[cur_x][cur_y];\n        boolean [][] marker = new boolean[n][n];\n        // marker[n-1][n-1]= true;\n\n        while (cur_x!=0 || cur_y!=0){\n            Data temp = q.poll();\n            cur_x = temp.x;\n            cur_y = temp.y;\n            marker[cur_x][cur_y] = true;\n            // System.out.println(cur_x+\" \"+cur_y + \" \"+temp.val);\n            if (temp.val > max) max = temp.val;\n            if (cur_x>0 && !marker[cur_x-1][cur_y])\n            {\n                int x = cur_x -1;\n                int y = cur_y;\n                q.add(new Data(grid[x][y],x,y));\n            }\n            if (cur_y>0 && !marker[cur_x][cur_y-1]){\n                int x = cur_x;\n                int y= cur_y - 1;\n                q.add(new Data(grid[x][y],x,y));\n            }\n            if (cur_x+1<n && !marker[cur_x+1][cur_y]){\n                int x = cur_x + 1;\n                int y = cur_y;\n                q.add(new Data(grid[x][y],x,y));\n            }\n            if (cur_y+1<n && !marker[cur_x][cur_y+1]){\n                int x = cur_x;\n                int y = cur_y + 1;\n                q.add(new Data(grid[x][y],x,y));\n            }\n            // for (Data d: q){\n            //     System.out.println(d);\n            // }\n            // System.out.println(\"******\");\n                \n        }\n\n        return max;     \n    }\n}\n\nclass Data implements Comparable<Data>{\n    int val;\n    int x;\n    int y;\n    public Data(int val, int x, int y){\n        this.val = val;\n        this.x = x;\n        this.y = y;\n    }\n        @Override\n    \tpublic int compareTo(Data o) {\n\t\t// TODO Auto-generated method stub\n\t\treturn Integer.compare(val,o.val);\n        }\n\n        @Override\n        public String toString(){\n            return x+\" \"+y+\": \"+val;\n        }\n\t\n}","runtime":"17 ms","title":"Swim in Rising Water","url":"/submissions/detail/1073026486/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1073026486,"time":"3 months, 2 weeks","lang":"java","title_slug":"swim-in-rising-water","timestamp":1697067092,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"44.3 MB","code":"class Solution {\n    public List<String> findItinerary(List<List<String>> tickets) {\n\t        HashMap<String,List<String>> map = new HashMap<>();\n\t        HashMap<String,Integer> in = new HashMap<>();\n\t        HashMap<String,Integer> out = new HashMap<>();\n\t        List<String> path = new LinkedList<>();\n\t        for (List<String> i : tickets){\n\t            if (map.keySet().contains(i.get(0))){\n\t                map.get(i.get(0)).add(i.get(1));\n\t            } else{\n\t                map.put(i.get(0),new ArrayList<>());\n\t                map.get(i.get(0)).add(i.get(1));\n\t            }\n\t            if (!map.keySet().contains(i.get(1))){\n\t                map.put(i.get(1),new ArrayList<>());\n\t            }\n\t        }\n\t        for (String s : map.keySet()){\n\t            in.put(s,0);\n\t            out.put(s,0);\n\t        }\n\n\t        for (List<String> i:tickets){\n\t            String fr = i.get(0);\n\t            String to = i.get(1);\n\t            out.put(fr,out.get(fr)+1);\n\t            in.put(to,in.get(to)+1);\n\t        }\n            for (String i: map.keySet()){\n                Collections.sort(map.get(i),Collections.reverseOrder());\n            }\n\n\t        //since the problem assume there is a path starting from JFK, im not writing code to check for ecluid path (there is 1 start and 1 end or all equal)\n\t        for (String i : map.keySet()){\n\t            System.out.print(i+\":\");\n\t            for (String j: map.get(i)){\n\t                System.out.print(j+\", \");\n\t            }\n\t            System.out.println(in.get(i)+\" \"+out.get(i));\n\t        }\n\t        dfs(\"JFK\",map,out,path);\n\t        \n\n\t        return path;\n\t        \n\t    }\n\n\t    public void dfs(String cur, HashMap<String,List<String>> map, HashMap<String,Integer> out, List<String> path){\n\t        System.out.println(cur +\" \"+ out.get(cur));\n\t        while(out.get(cur)!=0){\n\t            out.put(cur,out.get(cur)-1);\n\t            dfs(map.get(cur).get(out.get(cur)),map,out,path);\n\n\t            // for (String s:map.get(cur)){\n\t            // }\n\t        }\n\t        path.add(0,cur);\n\t    }\n}","runtime":"49 ms","title":"Reconstruct Itinerary","url":"/submissions/detail/1072990876/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072990876,"time":"3 months, 2 weeks","lang":"java","title_slug":"reconstruct-itinerary","timestamp":1697061691,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"44.5 MB","code":"class Solution {\n    public List<String> findItinerary(List<List<String>> tickets) {\n\t        HashMap<String,List<String>> map = new HashMap<>();\n\t        HashMap<String,Integer> in = new HashMap<>();\n\t        HashMap<String,Integer> out = new HashMap<>();\n\t        List<String> path = new LinkedList<>();\n\t        for (List<String> i : tickets){\n\t            if (map.keySet().contains(i.get(0))){\n\t                map.get(i.get(0)).add(i.get(1));\n\t            } else{\n\t                map.put(i.get(0),new ArrayList<>());\n\t                map.get(i.get(0)).add(i.get(1));\n\t            }\n\t            if (!map.keySet().contains(i.get(1))){\n\t                map.put(i.get(1),new ArrayList<>());\n\t            }\n\t        }\n\t        for (String s : map.keySet()){\n\t            in.put(s,0);\n\t            out.put(s,0);\n\t        }\n\n\t        for (List<String> i:tickets){\n\t            String fr = i.get(0);\n\t            String to = i.get(1);\n\t            out.put(fr,out.get(fr)+1);\n\t            in.put(to,in.get(to)+1);\n\t        }\n            for (String i: map.keySet()){\n                Collections.sort(map.get(i),Collections.reverseOrder());\n            }\n\n\t        //since the problem assume there is a path starting from JFK, im not writing code to check for ecluid path (there is 1 start and 1 end or all equal)\n\t        for (String i : map.keySet()){\n\t            System.out.print(i+\":\");\n\t            for (String j: map.get(i)){\n\t                System.out.print(j+\", \");\n\t            }\n\t            System.out.println(in.get(i)+\" \"+out.get(i));\n\t        }\n\t        dfs(\"JFK\",map,out,path);\n\t        \n\n\t        return path;\n\t        \n\t    }\n\n\t    public void dfs(String cur, HashMap<String,List<String>> map, HashMap<String,Integer> out, List<String> path){\n\t        System.out.println(cur +\" \"+ out.get(cur));\n\t        while(out.get(cur)!=0){\n\t            out.put(cur,out.get(cur)-1);\n\t            dfs(map.get(cur).get(out.get(cur)),map,out,path);\n\n\t            // for (String s:map.get(cur)){\n\t            // }\n\t        }\n\t        path.add(0,cur);\n\t    }\n}","runtime":"50 ms","title":"Reconstruct Itinerary","url":"/submissions/detail/1072987982/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072987982,"time":"3 months, 2 weeks","lang":"java","title_slug":"reconstruct-itinerary","timestamp":1697061293,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"47.4 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashSet<String> list = new HashSet<String>();\n        for (String s:wordList){\n            list.add(s);\n        }\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        for (String s:list){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        bfs.add(beginWord);\n        shortPath.put(beginWord,1);\n\n        while(!bfs.isEmpty()){\n            String cur = bfs.poll();\n            if (cur.equals(endWord)){\n                break;\n            }\n            int n = cur.length();\n            for (int i=0;i<n;i++){\n                char [] cList = cur.toCharArray();\n                for (char c = 'a';c<='z';c++){\n                    cList[i] = c;\n                    String temp = new String(cList);\n                    // System.out.println(temp);\n                    if (list.contains(temp) && !visited.contains(temp)){\n                        bfs.add(temp);\n                        shortPath.put(temp,Integer.min(shortPath.get(temp),shortPath.get(cur)+1));\n                        visited.add(temp);\n\n                    }\n                }\n            }\n            // break;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n\n}","runtime":"78 ms","title":"Word Ladder","url":"/submissions/detail/1072911648/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072911648,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1697052526,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"46.8 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        Set<String> set = new HashSet<>(wordList);\n        if (!set.contains(endWord)) return 0;\n\n        Queue<String> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n\n        queue.add(beginWord);\n\n        visited.add(beginWord);\n        int changes = 1;\n        while(!queue.isEmpty()){\n            int size = queue.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = queue.poll();\n                // visited.add(cur);\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] arr = cur.toCharArray();\n                    for (int k = 'a';k<='z';k++){\n                        arr[i] = (char)k;\n                        String temp = new String(arr);\n                        if (set.contains(temp) && !visited.contains(temp)){\n                            queue.add(temp);\n                            visited.add(temp);\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}","runtime":"72 ms","title":"Word Ladder","url":"/submissions/detail/1072229299/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072229299,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696983655,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"46.5 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        Set<String> set = new HashSet<>(wordList);\n        if (!set.contains(endWord)) return 0;\n\n        Queue<String> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n\n        queue.add(beginWord);\n\n        visited.add(beginWord);\n        int changes = 1;\n        while(!queue.isEmpty()){\n            int size = queue.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = queue.poll();\n                visited.add(cur);\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] arr = cur.toCharArray();\n                    for (int k = 'a';k<='z';k++){\n                        arr[i] = (char)k;\n                        String temp = new String(arr);\n                        if (set.contains(temp) && !visited.contains(temp)){\n                            queue.add(temp);\n                            visited.add(temp);\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}","runtime":"74 ms","title":"Word Ladder","url":"/submissions/detail/1072229199/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072229199,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696983641,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"54 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        Set<String> set = new HashSet<>(wordList);\n        if (!set.contains(endWord)) return 0;\n\n        Queue<String> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n\n        queue.add(beginWord);\n\n        visited.add(beginWord);\n        int changes = 1;\n        while(!queue.isEmpty()){\n            int size = queue.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = queue.poll();\n                visited.add(cur);\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] arr = cur.toCharArray();\n                    for (int k = 'a';k<='z';k++){\n                        arr[i] = (char)k;\n                        String temp = new String(arr);\n                        if (set.contains(temp) && !visited.contains(temp)){\n                            queue.add(temp);\n                            visited.add(cur);\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}","runtime":"1363 ms","title":"Word Ladder","url":"/submissions/detail/1072229095/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072229095,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696983626,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"55.1 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        Set<String> set = new HashSet<>(wordList);\n        if (!set.contains(endWord)) return 0;\n\n        Queue<String> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n\n        queue.add(beginWord);\n\n        visited.add(beginWord);\n        int changes = 1;\n        while(!queue.isEmpty()){\n            int size = queue.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = queue.poll();\n                visited.add(cur);\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] arr = cur.toCharArray();\n                    for (int c = 'a';c<='z';c++){\n                        arr[i] = (char)c;\n                        String temp = new String(arr);\n                        if (set.contains(temp) && !visited.contains(temp)){\n                            queue.add(temp);\n                            visited.add(cur);\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}","runtime":"1383 ms","title":"Word Ladder","url":"/submissions/detail/1072228950/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072228950,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696983606,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"54.6 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        Set<String> set = new HashSet<>(wordList);\n        if (!set.contains(endWord)) return 0;\n\n        Queue<String> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n\n        queue.add(beginWord);\n\n        visited.add(beginWord);\n        int changes = 1;\n        while(!queue.isEmpty()){\n            int size = queue.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = queue.poll();\n                visited.add(cur);\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] cList = cur.toCharArray();\n                    for (char c = 'a';c<='z';c++){\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        if (set.contains(temp) && !visited.contains(temp)){\n                            queue.add(temp);\n                            visited.add(cur);\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}","runtime":"1347 ms","title":"Word Ladder","url":"/submissions/detail/1072228537/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072228537,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696983538,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Compile Error","memory":"N/A","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, set<String> wordList) {\n        Set<String> set = new HashSet<>(wordList);\n        if (!set.contains(endWord)) return 0;\n\n        Queue<String> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n\n        queue.add(beginWord);\n\n        visited.add(beginWord);\n        int changes = 1;\n        while(!queue.isEmpty()){\n            int size = queue.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = queue.poll();\n                visited.add(cur);\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] cList = cur.toCharArray();\n                    for (char c = 'a';c<='z';c++){\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        if (set.contains(temp) && !visited.contains(temp)){\n                            queue.add(temp);\n                            visited.add(cur);\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}","runtime":"N/A","title":"Word Ladder","url":"/submissions/detail/1072228421/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072228421,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696983519,"status":20,"is_pending":"Not Pending","compare_result":null},{"status_display":"Accepted","memory":"54.2 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        Set<String> list = new HashSet<>(wordList);\n        if (!list.contains(endWord)) return 0;\n\n        Queue<String> bfs = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n\n        bfs.add(beginWord);\n\n        visited.add(beginWord);\n        int changes = 1;\n        while(!bfs.isEmpty()){\n            int size = bfs.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = bfs.poll();\n                visited.add(cur);\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] cList = cur.toCharArray();\n                    for (char c = 'a';c<='z';c++){\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        if (list.contains(temp) && !visited.contains(temp)){\n                            bfs.add(temp);\n                            visited.add(cur);\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}","runtime":"1387 ms","title":"Word Ladder","url":"/submissions/detail/1072228002/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072228002,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696983455,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"54.5 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        Set<String> list = new HashSet<String>(wordList);\n        if (!list.contains(endWord)) return 0;\n\n        Queue<String> bfs = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n\n        bfs.add(beginWord);\n\n        visited.add(beginWord);\n        int changes = 1;\n        while(!bfs.isEmpty()){\n            int size = bfs.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = bfs.poll();\n                visited.add(cur);\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] cList = cur.toCharArray();\n                    for (char c = 'a';c<='z';c++){\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        if (list.contains(temp) && !visited.contains(temp)){\n                            bfs.add(temp);\n                            visited.add(cur);\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}","runtime":"1363 ms","title":"Word Ladder","url":"/submissions/detail/1072227878/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072227878,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696983437,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"54.2 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        HashSet<String> list = new HashSet<String>(wordList);\n        if (!list.contains(endWord)) return 0;\n\n        Queue<String> bfs = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n\n        bfs.add(beginWord);\n\n        visited.add(beginWord);\n        int changes = 1;\n        while(!bfs.isEmpty()){\n            int size = bfs.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = bfs.poll();\n                visited.add(cur);\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] cList = cur.toCharArray();\n                    for (char c = 'a';c<='z';c++){\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        if (list.contains(temp) && !visited.contains(temp)){\n                            bfs.add(temp);\n                            visited.add(cur);\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}","runtime":"1366 ms","title":"Word Ladder","url":"/submissions/detail/1072226524/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072226524,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696983222,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"}],"has_next":true,"last_key":"%7B%22pk%22%3A%20%7B%22N%22%3A%20%221072226524%22%7D%2C%20%22dt%22%3A%20%7B%22S%22%3A%20%222023-10-11T00%3A13%3A42.327027%2B0000%22%7D%2C%20%22sid%22%3A%20%7B%22N%22%3A%20%227573785%22%7D%7D"}
2024-01-26 23:40:01.073 [main] DEBUG submission_dump - {"submissions_dump":[{"status_display":"Accepted","memory":"54.5 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        HashSet<String> list = new HashSet<String>(wordList);\n        if (!list.contains(endWord)) return 0;\n\n        Queue<String> bfs = new LinkedList<>();\n        HashSet<String> visited = new HashSet<>();\n\n        bfs.add(beginWord);\n\n        visited.add(beginWord);\n        int changes = 1;\n        while(!bfs.isEmpty()){\n            int size = bfs.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = bfs.poll();\n                visited.add(cur);\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] cList = cur.toCharArray();\n                    for (char c = 'a';c<='z';c++){\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        if (list.contains(temp) && !visited.contains(temp)){\n                            bfs.add(temp);\n                            visited.add(cur);\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}","runtime":"1360 ms","title":"Word Ladder","url":"/submissions/detail/1072226008/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072226008,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696983139,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Time Limit Exceeded","memory":"N/A","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        HashSet<String> list = new HashSet<String>(wordList);\n        if (!list.contains(endWord)) return 0;\n\n        Queue<String> bfs = new LinkedList<>();\n        HashSet<String> visited = new HashSet<>();\n\n        bfs.add(beginWord);\n\n        visited.add(beginWord);\n        int changes = 1;\n        while(!bfs.isEmpty()){\n            int size = bfs.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = bfs.poll();\n                // visited.add(cur);\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    for (char c = 'a';c<='z';c++){\n                        char [] cList = cur.toCharArray();\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        if (list.contains(temp) && !visited.contains(temp)){\n                            bfs.add(temp);\n                            visited.add(cur);\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}","runtime":"N/A","title":"Word Ladder","url":"/submissions/detail/1072225838/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072225838,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696983114,"status":14,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"54.5 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        HashSet<String> list = new HashSet<String>(wordList);\n        if (!list.contains(endWord)) return 0;\n\n        Queue<String> bfs = new LinkedList<>();\n        HashSet<String> visited = new HashSet<>();\n\n        bfs.add(beginWord);\n\n        visited.add(beginWord);\n        int changes = 1;\n        while(!bfs.isEmpty()){\n            int size = bfs.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = bfs.poll();\n                visited.add(cur);\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    for (char c = 'a';c<='z';c++){\n                        char [] cList = cur.toCharArray();\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        if (list.contains(temp) && !visited.contains(temp)){\n                            bfs.add(temp);\n                            visited.add(cur);\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}","runtime":"1754 ms","title":"Word Ladder","url":"/submissions/detail/1072225796/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072225796,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696983106,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"54.4 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        HashSet<String> list = new HashSet<String>(wordList);\n        if (!list.contains(endWord)) return 0;\n\n        Queue<String> bfs = new LinkedList<>();\n        HashSet<String> visited = new HashSet<>();\n\n        bfs.add(beginWord);\n        bfs.add(beginWord);\n\n        visited.add(beginWord);\n        int changes = 1;\n        while(!bfs.isEmpty()){\n            int size = bfs.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = bfs.poll();\n                visited.add(cur);\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] cList = cur.toCharArray();\n                    for (char c = 'a';c<='z';c++){\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        if (list.contains(temp) && !visited.contains(temp)){\n                            bfs.add(temp);\n                            visited.add(cur);\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}","runtime":"1665 ms","title":"Word Ladder","url":"/submissions/detail/1072225419/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072225419,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696983048,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"54.7 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        HashSet<String> list = new HashSet<String>(wordList);\n        if (!list.contains(endWord)) return 0;\n\n        Queue<String> bfs = new LinkedList<>();\n        HashSet<String> visited = new HashSet<>();\n\n        bfs.add(beginWord);\n        visited.add(beginWord);\n        int changes = 1;\n        while(!bfs.isEmpty()){\n            int size = bfs.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = bfs.poll();\n                visited.add(cur);\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] cList = cur.toCharArray();\n                    for (char c = 'a';c<='z';c++){\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        if (list.contains(temp) && !visited.contains(temp)){\n                            bfs.add(temp);\n                            visited.add(cur);\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}","runtime":"1383 ms","title":"Word Ladder","url":"/submissions/detail/1072225117/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072225117,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696983003,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"54.2 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        HashSet<String> list = new HashSet<String>(wordList);\n        if (!list.contains(endWord)) return 0;\n\n        Queue<String> bfs = new LinkedList<>();\n        HashSet<String> visited = new HashSet<>();\n\n        bfs.add(beginWord);\n        visited.add(beginWord);\n        int changes = 1;\n        while(!bfs.isEmpty()){\n            int size = bfs.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = bfs.poll();\n                visited.add(cur);\n\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] cList = cur.toCharArray();\n                    for (char c = 'a';c<='z';c++){\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        if (list.contains(temp) && !visited.contains(temp)){\n                            bfs.add(temp);\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}","runtime":"1336 ms","title":"Word Ladder","url":"/submissions/detail/1072224750/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072224750,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696982939,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"54.3 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        HashSet<String> list = new HashSet<String>(wordList);\n        if (!list.contains(endWord)) return 0;\n\n        Queue<String> bfs = new LinkedList<>();\n        HashSet<String> visited = new HashSet<>();\n        // HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        // for (String s:list){\n        //     shortPath.put(s,Integer.MAX_VALUE);\n        // }\n        bfs.add(beginWord);\n        // shortPath.put(beginWord,1);\n        visited.add(beginWord);\n        int changes = 1;\n        while(!bfs.isEmpty()){\n            int size = bfs.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = bfs.poll();\n                visited.add(cur);\n\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] cList = cur.toCharArray();\n                    for (char c = 'a';c<='z';c++){\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        // System.out.println(temp);\n                        if (list.contains(temp) && !visited.contains(temp)){\n                            bfs.add(temp);\n                            // shortPath.put(temp,Integer.min(shortPath.get(temp),shortPath.get(cur)+1));\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}","runtime":"1347 ms","title":"Word Ladder","url":"/submissions/detail/1072224436/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072224436,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696982886,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"54.8 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        HashSet<String> list = new HashSet<String>(wordList);\n        if (!list.contains(endWord)) return 0;\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        // HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        // for (String s:list){\n        //     shortPath.put(s,Integer.MAX_VALUE);\n        // }\n        bfs.add(beginWord);\n        // shortPath.put(beginWord,1);\n        visited.add(beginWord);\n        int changes = 1;\n        while(!bfs.isEmpty()){\n            int size = bfs.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = bfs.poll();\n                visited.add(cur);\n\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] cList = cur.toCharArray();\n                    for (char c = 'a';c<='z';c++){\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        // System.out.println(temp);\n                        if (list.contains(temp) && !visited.contains(temp)){\n                            bfs.add(temp);\n                            // shortPath.put(temp,Integer.min(shortPath.get(temp),shortPath.get(cur)+1));\n\n                        }\n                    }\n                }\n            }\n            ++changes;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}","runtime":"1360 ms","title":"Word Ladder","url":"/submissions/detail/1072222162/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072222162,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696982507,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"54.4 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashSet<String> list = new HashSet<String>(wordList);\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        // HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        // for (String s:list){\n        //     shortPath.put(s,Integer.MAX_VALUE);\n        // }\n        bfs.add(beginWord);\n        // shortPath.put(beginWord,1);\n        visited.add(beginWord);\n        int changes = 1;\n        while(!bfs.isEmpty()){\n            int size = bfs.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = bfs.poll();\n                visited.add(cur);\n\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] cList = cur.toCharArray();\n                    for (char c = 'a';c<='z';c++){\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        // System.out.println(temp);\n                        if (list.contains(temp) && !visited.contains(temp)){\n                            bfs.add(temp);\n                            // shortPath.put(temp,Integer.min(shortPath.get(temp),shortPath.get(cur)+1));\n\n                        }\n                    }\n                }\n            }\n            ++changes;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}","runtime":"1371 ms","title":"Word Ladder","url":"/submissions/detail/1072218687/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072218687,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696981956,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"54.8 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashSet<String> list = new HashSet<String>(wordList);\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        // HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        // for (String s:list){\n        //     shortPath.put(s,Integer.MAX_VALUE);\n        // }\n        bfs.add(beginWord);\n        // shortPath.put(beginWord,1);\n        visited.add(beginWord);\n        int changes = 1;\n        while(!bfs.isEmpty()){\n            int size = bfs.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = bfs.poll();\n                visited.add(cur);\n\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] cList = cur.toCharArray();\n                    for (char c = 'a';c<='z';c++){\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        // System.out.println(temp);\n                        if (list.contains(temp) && !visited.contains(temp)){\n                            bfs.add(temp);\n                            // shortPath.put(temp,Integer.min(shortPath.get(temp),shortPath.get(cur)+1));\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}","runtime":"1377 ms","title":"Word Ladder","url":"/submissions/detail/1072218213/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072218213,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696981879,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"54.6 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashSet<String> list = new HashSet<String>(wordList);\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        // HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        // for (String s:list){\n        //     shortPath.put(s,Integer.MAX_VALUE);\n        // }\n        bfs.add(beginWord);\n        // shortPath.put(beginWord,1);\n        visited.add(beginWord);\n        int changes = 1;\n        while(!bfs.isEmpty()){\n            int size = bfs.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = bfs.poll();\n                visited.add(cur);\n\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    for (char c = 'a';c<='z';c++){\n                        char [] cList = cur.toCharArray();\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        // System.out.println(temp);\n                        if (list.contains(temp) && !visited.contains(temp)){\n                            bfs.add(temp);\n                            // shortPath.put(temp,Integer.min(shortPath.get(temp),shortPath.get(cur)+1));\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}","runtime":"1748 ms","title":"Word Ladder","url":"/submissions/detail/1072218044/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072218044,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696981854,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"54.6 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashSet<String> list = new HashSet<String>(wordList);\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        // HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        // for (String s:list){\n        //     shortPath.put(s,Integer.MAX_VALUE);\n        // }\n        bfs.add(beginWord);\n        // shortPath.put(beginWord,1);\n        visited.add(beginWord);\n        int changes = 1;\n        while(!bfs.isEmpty()){\n            int size = bfs.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = bfs.poll();\n                visited.add(cur);\n\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] cList = cur.toCharArray();\n                    for (char c = 'a';c<='z';c++){\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        // System.out.println(temp);\n                        if (list.contains(temp) && !visited.contains(temp)){\n                            bfs.add(temp);\n                            // shortPath.put(temp,Integer.min(shortPath.get(temp),shortPath.get(cur)+1));\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}","runtime":"1353 ms","title":"Word Ladder","url":"/submissions/detail/1072217462/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072217462,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696981764,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"46.5 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        Set<String> set = new HashSet<>(wordList);\n        if(!set.contains(endWord)) return 0;\n        \n        Queue<String> queue = new LinkedList<>();\n        queue.add(beginWord);\n        \n        Set<String> visited = new HashSet<>();\n        queue.add(beginWord);\n        \n        int changes = 1;\n        \n        while(!queue.isEmpty()){\n            int size = queue.size();\n            for(int i = 0; i < size; i++){\n                String word = queue.poll();\n                if(word.equals(endWord)) return changes;\n                \n                for(int j = 0; j < word.length(); j++){\n                    for(int k = 'a'; k <= 'z'; k++){\n                        char arr[] = word.toCharArray();\n                        arr[j] = (char) k;\n                        \n                        String str = new String(arr);\n                        if(set.contains(str) && !visited.contains(str)){\n                            queue.add(str);\n                            visited.add(str);\n                        }\n                    }\n                }\n            }\n            ++changes;\n        }\n        return 0;\n    }\n\n\n\n}","runtime":"93 ms","title":"Word Ladder","url":"/submissions/detail/1072216668/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072216668,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696981643,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Compile Error","memory":"N/A","code":"class Solution {\n\n    ppublic int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        Set<String> set = new HashSet<>(wordList);\n        if(!set.contains(endWord)) return 0;\n        \n        Queue<String> queue = new LinkedList<>();\n        queue.add(beginWord);\n        \n        Set<String> visited = new HashSet<>();\n        queue.add(beginWord);\n        \n        int changes = 1;\n        \n        while(!queue.isEmpty()){\n            int size = queue.size();\n            for(int i = 0; i < size; i++){\n                String word = queue.poll();\n                if(word.equals(endWord)) return changes;\n                \n                for(int j = 0; j < word.length(); j++){\n                    for(int k = 'a'; k <= 'z'; k++){\n                        char arr[] = word.toCharArray();\n                        arr[j] = (char) k;\n                        \n                        String str = new String(arr);\n                        if(set.contains(str) && !visited.contains(str)){\n                            queue.add(str);\n                            visited.add(str);\n                        }\n                    }\n                }\n            }\n            ++changes;\n        }\n        return 0;\n    }\n\n\n\n}","runtime":"N/A","title":"Word Ladder","url":"/submissions/detail/1072216615/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072216615,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696981634,"status":20,"is_pending":"Not Pending","compare_result":null},{"status_display":"Accepted","memory":"55 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashSet<String> list = new HashSet<String>(wordList);\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        // for (String s:list){\n        //     shortPath.put(s,Integer.MAX_VALUE);\n        // }\n        bfs.add(beginWord);\n        shortPath.put(beginWord,1);\n        visited.add(beginWord);\n        int changes = 1;\n        while(!bfs.isEmpty()){\n            int size = bfs.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = bfs.poll();\n                visited.add(cur);\n\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] cList = cur.toCharArray();\n                    for (char c = 'a';c<='z';c++){\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        // System.out.println(temp);\n                        if (list.contains(temp) && !visited.contains(temp)){\n                            bfs.add(temp);\n                            // shortPath.put(temp,Integer.min(shortPath.get(temp),shortPath.get(cur)+1));\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}","runtime":"1360 ms","title":"Word Ladder","url":"/submissions/detail/1072216455/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072216455,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696981607,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"54.7 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashSet<String> list = new HashSet<String>(wordList);\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        // for (String s:list){\n        //     shortPath.put(s,Integer.MAX_VALUE);\n        // }\n        bfs.add(beginWord);\n        shortPath.put(beginWord,1);\n        visited.add(beginWord);\n        int changes = 1;\n        while(!bfs.isEmpty()){\n            int size = bfs.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = bfs.poll();\n                // visited.add(cur);\n\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] cList = cur.toCharArray();\n                    for (char c = 'a';c<='z';c++){\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        // System.out.println(temp);\n                        if (list.contains(temp) && !visited.contains(temp)){\n                            bfs.add(temp);\n                            // shortPath.put(temp,Integer.min(shortPath.get(temp),shortPath.get(cur)+1));\n                            visited.add(cur);\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}","runtime":"2354 ms","title":"Word Ladder","url":"/submissions/detail/1072216312/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072216312,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696981588,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"54.4 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashSet<String> list = new HashSet<String>(wordList);\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        // for (String s:list){\n        //     shortPath.put(s,Integer.MAX_VALUE);\n        // }\n        bfs.add(beginWord);\n        shortPath.put(beginWord,1);\n        visited.add(beginWord);\n        int changes = 1;\n        while(!bfs.isEmpty()){\n            int size = bfs.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = bfs.poll();\n                visited.add(cur);\n\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] cList = cur.toCharArray();\n                    for (char c = 'a';c<='z';c++){\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        // System.out.println(temp);\n                        if (list.contains(temp) && !visited.contains(temp)){\n                            bfs.add(temp);\n                            // shortPath.put(temp,Integer.min(shortPath.get(temp),shortPath.get(cur)+1));\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}","runtime":"1329 ms","title":"Word Ladder","url":"/submissions/detail/1072215742/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072215742,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696981495,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"54.5 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashSet<String> list = new HashSet<String>(wordList);\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        // for (String s:list){\n        //     shortPath.put(s,Integer.MAX_VALUE);\n        // }\n        bfs.add(beginWord);\n        shortPath.put(beginWord,1);\n        visited.add(beginWord);\n        int changes = 1;\n        while(!bfs.isEmpty()){\n            int size = bfs.size();\n            for (int x = 0 ;x<size;x++)\n            {\n                String cur = bfs.poll();\n                visited.add(cur);\n\n                if (cur.equals(endWord)){\n                    return changes;\n                }\n                int n = cur.length();\n                for (int i=0;i<n;i++){\n                    char [] cList = cur.toCharArray();\n                    for (char c = 'a';c<='z';c++){\n                        cList[i] = c;\n                        String temp = new String(cList);\n                        // System.out.println(temp);\n                        if (list.contains(temp) && !visited.contains(temp)){\n                            bfs.add(temp);\n                            // shortPath.put(temp,Integer.min(shortPath.get(temp),shortPath.get(cur)+1));\n\n                        }\n                    }\n                }\n            }\n            changes++;\n            \n            // break;\n        }\n\n        return 0;\n    }\n\n\n}","runtime":"1354 ms","title":"Word Ladder","url":"/submissions/detail/1072215681/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072215681,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696981485,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"54.3 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashSet<String> list = new HashSet<String>(wordList);\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        for (String s:list){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        bfs.add(beginWord);\n        shortPath.put(beginWord,1);\n        visited.add(beginWord);\n\n        while(!bfs.isEmpty()){\n            String cur = bfs.poll();\n            visited.add(cur);\n\n            if (cur.equals(endWord)){\n                return shortPath.get(endWord);\n            }\n            int n = cur.length();\n            for (int i=0;i<n;i++){\n                char [] cList = cur.toCharArray();\n                for (char c = 'a';c<='z';c++){\n                    cList[i] = c;\n                    String temp = new String(cList);\n                    // System.out.println(temp);\n                    if (list.contains(temp) && !visited.contains(temp)){\n                        bfs.add(temp);\n                        shortPath.put(temp,Integer.min(shortPath.get(temp),shortPath.get(cur)+1));\n\n                    }\n                }\n            }\n            // break;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n\n}","runtime":"1366 ms","title":"Word Ladder","url":"/submissions/detail/1072213925/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072213925,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696981200,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"55 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashSet<String> list = new HashSet<String>(wordList);\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        for (String s:list){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        bfs.add(beginWord);\n        shortPath.put(beginWord,1);\n        visited.add(beginWord);\n\n        while(!bfs.isEmpty()){\n            String cur = bfs.poll();\n            if (cur.equals(endWord)){\n                return shortPath.get(endWord);\n            }\n            int n = cur.length();\n            for (int i=0;i<n;i++){\n                char [] cList = cur.toCharArray();\n                for (char c = 'a';c<='z';c++){\n                    cList[i] = c;\n                    String temp = new String(cList);\n                    // System.out.println(temp);\n                    if (list.contains(temp) && !visited.contains(temp)){\n                        bfs.add(temp);\n                        shortPath.put(temp,Integer.min(shortPath.get(temp),shortPath.get(cur)+1));\n                        visited.add(cur);\n\n                    }\n                }\n            }\n            // break;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n\n}","runtime":"2338 ms","title":"Word Ladder","url":"/submissions/detail/1072213596/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072213596,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696981144,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"}],"has_next":true,"last_key":"%7B%22pk%22%3A%20%7B%22N%22%3A%20%221072213596%22%7D%2C%20%22dt%22%3A%20%7B%22S%22%3A%20%222023-10-10T23%3A39%3A04.953174%2B0000%22%7D%2C%20%22sid%22%3A%20%7B%22N%22%3A%20%227573785%22%7D%7D"}
2024-01-26 23:40:11.617 [main] DEBUG submission_dump - {"submissions_dump":[{"status_display":"Accepted","memory":"54.4 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashSet<String> list = new HashSet<String>(wordList);\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        for (String s:list){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        bfs.add(beginWord);\n        shortPath.put(beginWord,1);\n\n        while(!bfs.isEmpty()){\n            String cur = bfs.poll();\n            if (cur.equals(endWord)){\n                return shortPath.get(endWord);\n            }\n            int n = cur.length();\n            for (int i=0;i<n;i++){\n                char [] cList = cur.toCharArray();\n                for (char c = 'a';c<='z';c++){\n                    cList[i] = c;\n                    String temp = new String(cList);\n                    // System.out.println(temp);\n                    if (list.contains(temp) && !visited.contains(temp)){\n                        bfs.add(temp);\n                        shortPath.put(temp,Integer.min(shortPath.get(temp),shortPath.get(cur)+1));\n                        visited.add(cur);\n\n                    }\n                }\n            }\n            // break;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n\n}","runtime":"2443 ms","title":"Word Ladder","url":"/submissions/detail/1072213444/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072213444,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696981120,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"54.6 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashSet<String> list = new HashSet<String>(wordList);\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        for (String s:list){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        bfs.add(beginWord);\n        shortPath.put(beginWord,1);\n\n        while(!bfs.isEmpty()){\n            String cur = bfs.poll();\n            if (cur.equals(endWord)){\n                return shortPath.get(endWord);\n            }\n            int n = cur.length();\n            for (int i=0;i<n;i++){\n                char [] cList = cur.toCharArray();\n                for (char c = 'a';c<='z';c++){\n                    cList[i] = c;\n                    String temp = new String(cList);\n                    // System.out.println(temp);\n                    if (list.contains(temp) && !visited.contains(temp)){\n                        bfs.add(temp);\n                        shortPath.put(temp,Integer.min(shortPath.get(temp),shortPath.get(cur)+1));\n                        visited.add(cur);\n\n                    }\n                }\n            }\n            // break;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n\n}","runtime":"2416 ms","title":"Word Ladder","url":"/submissions/detail/1072213356/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072213356,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696981106,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"54.6 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashSet<String> list = new HashSet<String>(wordList);\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        for (String s:list){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        bfs.add(beginWord);\n        shortPath.put(beginWord,1);\n\n        while(!bfs.isEmpty()){\n            String cur = bfs.poll();\n            if (cur.equals(endWord)){\n                return shortPath.get(endWord);\n            }\n            visited.add(cur);\n            int n = cur.length();\n            for (int i=0;i<n;i++){\n                char [] cList = cur.toCharArray();\n                for (char c = 'a';c<='z';c++){\n                    cList[i] = c;\n                    String temp = new String(cList);\n                    // System.out.println(temp);\n                    if (list.contains(temp) && !visited.contains(temp)){\n                        bfs.add(temp);\n                        shortPath.put(temp,Integer.min(shortPath.get(temp),shortPath.get(cur)+1));\n                    }\n                }\n            }\n            // break;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n\n}","runtime":"1356 ms","title":"Word Ladder","url":"/submissions/detail/1072212427/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072212427,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696980956,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"54.8 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashSet<String> list = new HashSet<String>(wordList);\n\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        for (String s:list){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        bfs.add(beginWord);\n        shortPath.put(beginWord,1);\n\n        while(!bfs.isEmpty()){\n            String cur = bfs.poll();\n            if (cur.equals(endWord)){\n                break;\n            }\n            visited.add(cur);\n            int n = cur.length();\n            for (int i=0;i<n;i++){\n                char [] cList = cur.toCharArray();\n                for (char c = 'a';c<='z';c++){\n                    cList[i] = c;\n                    String temp = new String(cList);\n                    // System.out.println(temp);\n                    if (list.contains(temp) && !visited.contains(temp)){\n                        bfs.add(temp);\n                        shortPath.put(temp,Integer.min(shortPath.get(temp),shortPath.get(cur)+1));\n                    }\n                }\n            }\n            // break;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n\n}","runtime":"1378 ms","title":"Word Ladder","url":"/submissions/detail/1072211942/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072211942,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696980877,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"54.5 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashSet<String> list = new HashSet<String>();\n        for (String s:wordList){\n            list.add(s);\n        }\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        for (String s:list){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        bfs.add(beginWord);\n        shortPath.put(beginWord,1);\n\n        while(!bfs.isEmpty()){\n            String cur = bfs.poll();\n            if (cur.equals(endWord)){\n                break;\n            }\n            visited.add(cur);\n            int n = cur.length();\n            for (int i=0;i<n;i++){\n                char [] cList = cur.toCharArray();\n                for (char c = 'a';c<='z';c++){\n                    cList[i] = c;\n                    String temp = new String(cList);\n                    // System.out.println(temp);\n                    if (list.contains(temp) && !visited.contains(temp)){\n                        bfs.add(temp);\n                        shortPath.put(temp,Integer.min(shortPath.get(temp),shortPath.get(cur)+1));\n                    }\n                }\n            }\n            // break;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n\n}","runtime":"1434 ms","title":"Word Ladder","url":"/submissions/detail/1072211632/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072211632,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696980831,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Compile Error","memory":"N/A","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashSet<String> list = new HashSet<String>();\n        for (String s:wordList){\n            list.add(s);\n        }\n        Queue<String> bfs = new LinkedList<String>();\n        HashSet<String> visited = new HashSet<String>();\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        for (String s:list){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        bfs.add(beginWord);\n        shortPath.put(beginWord,1);\n\n        while(!bfs.isEmpty()){\n            String cur = bfs.poll();\n            if (cur.equals(endWord)){\n                break;\n            }\n            visited.add(cur);\n            int n = cur.length();\n            for (int i=0;i<n;i++){\n                char [] cList = cur.toCharArray();\n                for (char c = 'a';c<='z';c++){\n                    cList[i] = c;\n                    // String temp = new String(cList);\n                    System.out.println(temp);\n                    if (list.contains(temp) && !visited.contains(temp)){\n                        bfs.add(temp);\n                        shortPath.put(temp,Integer.min(shortPath.get(temp),shortPath.get(cur)+1));\n                    }\n                }\n            }\n            // break;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n\n}","runtime":"N/A","title":"Word Ladder","url":"/submissions/detail/1072211551/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072211551,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696980817,"status":20,"is_pending":"Not Pending","compare_result":null},{"status_display":"Accepted","memory":"46.6 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        Set<String> set = new HashSet<>(wordList);\n        if(!set.contains(endWord)) return 0;\n        \n        Queue<String> queue = new LinkedList<>();\n        queue.add(beginWord);\n        \n        Set<String> visited = new HashSet<>();\n        queue.add(beginWord);\n        \n        int changes = 1;\n        \n        while(!queue.isEmpty()){\n            int size = queue.size();\n            for(int i = 0; i < size; i++){\n                String word = queue.poll();\n                if(word.equals(endWord)) return changes;\n                \n                for(int j = 0; j < word.length(); j++){\n                    for(int k = 'a'; k <= 'z'; k++){\n                        char arr[] = word.toCharArray();\n                        arr[j] = (char) k;\n                        \n                        String str = new String(arr);\n                        if(set.contains(str) && !visited.contains(str)){\n                            queue.add(str);\n                            visited.add(str);\n                        }\n                    }\n                }\n            }\n            ++changes;\n        }\n        return 0;\n    }\n\n\n}","runtime":"94 ms","title":"Word Ladder","url":"/submissions/detail/1072178071/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072178071,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696975815,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"49.5 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        // for (String s: map.keySet()){\n        //     if (s.equals(\"ito\")){\n        //         System.out.print(s + \": \");\n        //         for (String is:map.get(s)){\n        //             System.out.print(is+\", \");\n        //         }\n        //         System.out.println();\n        //     }\n        // }\n\n        HashSet<String> visited = new HashSet<String>();\n        Queue<String> bfs = new LinkedList<String>();\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        for (String s:map.keySet()){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        bfs.add(beginWord);\n        shortPath.put(beginWord,1);\n        String cur = \"\";\n        int count =0;\n        // boolean check = false;\n\n        while (!bfs.isEmpty())\n        {\n            cur = bfs.poll();\n            visited.add(cur);\n            if (cur.equals(endWord)){\n                break;\n            }\n            for (String s:map.get(cur)){\n                if (!visited.contains(s))\n                {\n                    bfs.add(s);\n                    shortPath.put(s,Integer.min(shortPath.get(s),shortPath.get(cur)+1));\n                    // if (s.equals(endWord)){\n                    //     check = true;\n                    //     break;\n                    // } ;\n                }\n            }\n            // if (check) break;\n        }\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n        // HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        // HashSet<String> visited = new HashSet<String>();\n        // // visisted.add(beginWord);\n        // String cur = beginWord;\n        // for (String s:map.keySet()){\n        //     shortPath.put(s,Integer.MAX_VALUE);\n        // }\n        // HashSet<String> tempSet = new HashSet<String>();\n        // shortPath.put(beginWord,1);\n        // while (!visited.contains(endWord)){\n        //     // System.out.println(\"dasdsa: \"+cur);\n        //     if (cur.equals(\"\")) break;\n        //     // System.out.println(shortPath.get(cur));\n        //     for (String s: map.get(cur)){\n        //         // System.out.println(s + \" \"+shortPath.get(s));\n\n        //         if (shortPath.get(s)>shortPath.get(cur)+1){\n        //             shortPath.put(s,shortPath.get(cur)+1);\n        //             // System.out.println(\"x\");\n        //             tempSet.add(s);\n\n        //         }\n        //     }\n        //     String temp = \"\";\n        //     int min = Integer.MAX_VALUE;\n        //     for (String s:tempSet){\n        //         if (!visited.contains(s)){\n        //             if (shortPath.get(s)<min){\n        //                 min = shortPath.get(s);\n        //                 temp = s;\n        //             }\n        //         }\n        //     }\n        //     tempSet.remove(temp);\n        //     visited.add(cur);\n        //     cur = temp;\n        // }\n\n        // return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n            if (count >1) return false;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}","runtime":"1074 ms","title":"Word Ladder","url":"/submissions/detail/1072149282/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072149282,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696972126,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"49.4 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        // for (String s: map.keySet()){\n        //     if (s.equals(\"ito\")){\n        //         System.out.print(s + \": \");\n        //         for (String is:map.get(s)){\n        //             System.out.print(is+\", \");\n        //         }\n        //         System.out.println();\n        //     }\n        // }\n\n        HashSet<String> visited = new HashSet<String>();\n        Queue<String> bfs = new LinkedList<String>();\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        for (String s:map.keySet()){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        bfs.add(beginWord);\n        shortPath.put(beginWord,1);\n        String cur = \"\";\n        int count =0;\n        // boolean check = false;\n\n        while (!bfs.isEmpty())\n        {\n            cur = bfs.poll();\n            visited.add(cur);\n            if (cur.equals(endWord)){\n                break;\n            }\n            for (String s:map.get(cur)){\n                if (!visited.contains(s))\n                {\n                    bfs.add(s);\n                    shortPath.put(s,Integer.min(shortPath.get(s),shortPath.get(cur)+1));\n                    // if (s.equals(endWord)){\n                    //     check = true;\n                    //     break;\n                    // } ;\n                }\n            }\n            // if (check) break;\n        }\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n        // HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        // HashSet<String> visited = new HashSet<String>();\n        // // visisted.add(beginWord);\n        // String cur = beginWord;\n        // for (String s:map.keySet()){\n        //     shortPath.put(s,Integer.MAX_VALUE);\n        // }\n        // HashSet<String> tempSet = new HashSet<String>();\n        // shortPath.put(beginWord,1);\n        // while (!visited.contains(endWord)){\n        //     // System.out.println(\"dasdsa: \"+cur);\n        //     if (cur.equals(\"\")) break;\n        //     // System.out.println(shortPath.get(cur));\n        //     for (String s: map.get(cur)){\n        //         // System.out.println(s + \" \"+shortPath.get(s));\n\n        //         if (shortPath.get(s)>shortPath.get(cur)+1){\n        //             shortPath.put(s,shortPath.get(cur)+1);\n        //             // System.out.println(\"x\");\n        //             tempSet.add(s);\n\n        //         }\n        //     }\n        //     String temp = \"\";\n        //     int min = Integer.MAX_VALUE;\n        //     for (String s:tempSet){\n        //         if (!visited.contains(s)){\n        //             if (shortPath.get(s)<min){\n        //                 min = shortPath.get(s);\n        //                 temp = s;\n        //             }\n        //         }\n        //     }\n        //     tempSet.remove(temp);\n        //     visited.add(cur);\n        //     cur = temp;\n        // }\n\n        // return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n            if (count >1) return false;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}","runtime":"1074 ms","title":"Word Ladder","url":"/submissions/detail/1072149191/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072149191,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696972115,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Time Limit Exceeded","memory":"N/A","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        // for (String s: map.keySet()){\n        //     if (s.equals(\"ito\")){\n        //         System.out.print(s + \": \");\n        //         for (String is:map.get(s)){\n        //             System.out.print(is+\", \");\n        //         }\n        //         System.out.println();\n        //     }\n        // }\n\n        HashSet<String> visited = new HashSet<String>();\n        Queue<String> bfs = new LinkedList<String>();\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        for (String s:map.keySet()){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        bfs.add(beginWord);\n        shortPath.put(beginWord,1);\n        String cur = \"\";\n        int count =0;\n        // boolean check = false;\n\n        while (!bfs.isEmpty())\n        {\n            cur = bfs.poll();\n            if (cur.equals(endWord)){\n                break;\n            }\n            for (String s:map.get(cur)){\n                if (!visited.contains(s))\n                {\n                    bfs.add(s);\n                    shortPath.put(s,Integer.min(shortPath.get(s),shortPath.get(cur)+1));\n                    // if (s.equals(endWord)){\n                    //     check = true;\n                    //     break;\n                    // } ;\n                }\n            }\n            // if (check) break;\n        }\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n        // HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        // HashSet<String> visited = new HashSet<String>();\n        // // visisted.add(beginWord);\n        // String cur = beginWord;\n        // for (String s:map.keySet()){\n        //     shortPath.put(s,Integer.MAX_VALUE);\n        // }\n        // HashSet<String> tempSet = new HashSet<String>();\n        // shortPath.put(beginWord,1);\n        // while (!visited.contains(endWord)){\n        //     // System.out.println(\"dasdsa: \"+cur);\n        //     if (cur.equals(\"\")) break;\n        //     // System.out.println(shortPath.get(cur));\n        //     for (String s: map.get(cur)){\n        //         // System.out.println(s + \" \"+shortPath.get(s));\n\n        //         if (shortPath.get(s)>shortPath.get(cur)+1){\n        //             shortPath.put(s,shortPath.get(cur)+1);\n        //             // System.out.println(\"x\");\n        //             tempSet.add(s);\n\n        //         }\n        //     }\n        //     String temp = \"\";\n        //     int min = Integer.MAX_VALUE;\n        //     for (String s:tempSet){\n        //         if (!visited.contains(s)){\n        //             if (shortPath.get(s)<min){\n        //                 min = shortPath.get(s);\n        //                 temp = s;\n        //             }\n        //         }\n        //     }\n        //     tempSet.remove(temp);\n        //     visited.add(cur);\n        //     cur = temp;\n        // }\n\n        // return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n            if (count >1) return false;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}","runtime":"N/A","title":"Word Ladder","url":"/submissions/detail/1072148772/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072148772,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696972067,"status":14,"is_pending":"Not Pending","compare_result":"111111111111111110000000000000000000000000000000000"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        // for (String s: map.keySet()){\n        //     if (s.equals(\"ito\")){\n        //         System.out.print(s + \": \");\n        //         for (String is:map.get(s)){\n        //             System.out.print(is+\", \");\n        //         }\n        //         System.out.println();\n        //     }\n        // }\n\n        HashSet<String> visited = new HashSet<String>();\n        Queue<String> bfs = new LinkedList<String>();\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        for (String s:map.keySet()){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        bfs.add(beginWord);\n        shortPath.put(beginWord,1);\n        String cur = \"\";\n        int count =0;\n        // boolean check = false;\n\n        while (!bfs.isEmpty())\n        {\n            cur = bfs.poll();\n            if (cur.equals(endWord)){\n                break;\n            }\n            for (String s:map.get(cur)){\n                if (!visited.contains(s))\n                {\n                    bfs.add(s);\n                    shortPath.put(s,Integer.min(shortPath.get(s),shortPath.get(cur)+1));\n                    // if (s.equals(endWord)){\n                    //     check = true;\n                    //     break;\n                    // } ;\n                }\n            }\n            // if (check) break;\n        }\n        return shortPath.get(endWord);\n        // HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        // HashSet<String> visited = new HashSet<String>();\n        // // visisted.add(beginWord);\n        // String cur = beginWord;\n        // for (String s:map.keySet()){\n        //     shortPath.put(s,Integer.MAX_VALUE);\n        // }\n        // HashSet<String> tempSet = new HashSet<String>();\n        // shortPath.put(beginWord,1);\n        // while (!visited.contains(endWord)){\n        //     // System.out.println(\"dasdsa: \"+cur);\n        //     if (cur.equals(\"\")) break;\n        //     // System.out.println(shortPath.get(cur));\n        //     for (String s: map.get(cur)){\n        //         // System.out.println(s + \" \"+shortPath.get(s));\n\n        //         if (shortPath.get(s)>shortPath.get(cur)+1){\n        //             shortPath.put(s,shortPath.get(cur)+1);\n        //             // System.out.println(\"x\");\n        //             tempSet.add(s);\n\n        //         }\n        //     }\n        //     String temp = \"\";\n        //     int min = Integer.MAX_VALUE;\n        //     for (String s:tempSet){\n        //         if (!visited.contains(s)){\n        //             if (shortPath.get(s)<min){\n        //                 min = shortPath.get(s);\n        //                 temp = s;\n        //             }\n        //         }\n        //     }\n        //     tempSet.remove(temp);\n        //     visited.add(cur);\n        //     cur = temp;\n        // }\n\n        // return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n            if (count >1) return false;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}","runtime":"N/A","title":"Word Ladder","url":"/submissions/detail/1072148434/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072148434,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696972031,"status":11,"is_pending":"Not Pending","compare_result":"111011111111111010000000000000000000000000000000000"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        // for (String s: map.keySet()){\n        //     if (s.equals(\"ito\")){\n        //         System.out.print(s + \": \");\n        //         for (String is:map.get(s)){\n        //             System.out.print(is+\", \");\n        //         }\n        //         System.out.println();\n        //     }\n        // }\n\n        HashSet<String> visited = new HashSet<String>();\n        Queue<String> bfs = new LinkedList<String>();\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        for (String s:map.keySet()){\n            shortPath.put(s,0);\n        }\n        bfs.add(beginWord);\n        shortPath.put(beginWord,1);\n        String cur = \"\";\n        int count =0;\n        boolean check = false;\n\n        while (!bfs.isEmpty())\n        {\n            cur = bfs.poll();\n            if (cur.equals(endWord)){\n                break;\n            }\n            for (String s:map.get(cur)){\n                if (!visited.contains(s))\n                {\n                    bfs.add(s);\n                    shortPath.put(s,shortPath.get(cur)+1);\n                    if (s.equals(endWord)){\n                        check = true;\n                        break;\n                    } ;\n                }\n            }\n            if (check) break;\n        }\n        return cur.equals(endWord)|check?shortPath.get(endWord):0;\n        // HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        // HashSet<String> visited = new HashSet<String>();\n        // // visisted.add(beginWord);\n        // String cur = beginWord;\n        // for (String s:map.keySet()){\n        //     shortPath.put(s,Integer.MAX_VALUE);\n        // }\n        // HashSet<String> tempSet = new HashSet<String>();\n        // shortPath.put(beginWord,1);\n        // while (!visited.contains(endWord)){\n        //     // System.out.println(\"dasdsa: \"+cur);\n        //     if (cur.equals(\"\")) break;\n        //     // System.out.println(shortPath.get(cur));\n        //     for (String s: map.get(cur)){\n        //         // System.out.println(s + \" \"+shortPath.get(s));\n\n        //         if (shortPath.get(s)>shortPath.get(cur)+1){\n        //             shortPath.put(s,shortPath.get(cur)+1);\n        //             // System.out.println(\"x\");\n        //             tempSet.add(s);\n\n        //         }\n        //     }\n        //     String temp = \"\";\n        //     int min = Integer.MAX_VALUE;\n        //     for (String s:tempSet){\n        //         if (!visited.contains(s)){\n        //             if (shortPath.get(s)<min){\n        //                 min = shortPath.get(s);\n        //                 temp = s;\n        //             }\n        //         }\n        //     }\n        //     tempSet.remove(temp);\n        //     visited.add(cur);\n        //     cur = temp;\n        // }\n\n        // return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n            if (count >1) return false;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}","runtime":"N/A","title":"Word Ladder","url":"/submissions/detail/1072146506/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072146506,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696971800,"status":11,"is_pending":"Not Pending","compare_result":"111111101111111110000000000000000000000000000000000"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        // for (String s: map.keySet()){\n        //     if (s.equals(\"ito\")){\n        //         System.out.print(s + \": \");\n        //         for (String is:map.get(s)){\n        //             System.out.print(is+\", \");\n        //         }\n        //         System.out.println();\n        //     }\n        // }\n\n        HashSet<String> visited = new HashSet<String>();\n        Queue<String> bfs = new LinkedList<String>();\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        for (String s:map.keySet()){\n            shortPath.put(s,0);\n        }\n        bfs.add(beginWord);\n        shortPath.put(beginWord,0);\n        String cur = \"\";\n        int count =0;\n        while (!bfs.isEmpty())\n        {\n            cur = bfs.poll();\n            if (cur.equals(endWord)){\n                break;\n            }\n            for (String s:map.get(cur)){\n                if (!visited.contains(s))\n                    bfs.add(s);\n                    shortPath.put(s,shortPath.get(cur)+1);\n            }\n        }\n        return cur.equals(endWord)?shortPath.get(endWord):0;\n        // HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        // HashSet<String> visited = new HashSet<String>();\n        // // visisted.add(beginWord);\n        // String cur = beginWord;\n        // for (String s:map.keySet()){\n        //     shortPath.put(s,Integer.MAX_VALUE);\n        // }\n        // HashSet<String> tempSet = new HashSet<String>();\n        // shortPath.put(beginWord,1);\n        // while (!visited.contains(endWord)){\n        //     // System.out.println(\"dasdsa: \"+cur);\n        //     if (cur.equals(\"\")) break;\n        //     // System.out.println(shortPath.get(cur));\n        //     for (String s: map.get(cur)){\n        //         // System.out.println(s + \" \"+shortPath.get(s));\n\n        //         if (shortPath.get(s)>shortPath.get(cur)+1){\n        //             shortPath.put(s,shortPath.get(cur)+1);\n        //             // System.out.println(\"x\");\n        //             tempSet.add(s);\n\n        //         }\n        //     }\n        //     String temp = \"\";\n        //     int min = Integer.MAX_VALUE;\n        //     for (String s:tempSet){\n        //         if (!visited.contains(s)){\n        //             if (shortPath.get(s)<min){\n        //                 min = shortPath.get(s);\n        //                 temp = s;\n        //             }\n        //         }\n        //     }\n        //     tempSet.remove(temp);\n        //     visited.add(cur);\n        //     cur = temp;\n        // }\n\n        // return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n            if (count >1) return false;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}","runtime":"N/A","title":"Word Ladder","url":"/submissions/detail/1072144424/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072144424,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696971558,"status":11,"is_pending":"Not Pending","compare_result":"111100111100100110000000000000000000000000000000000"},{"status_display":"Accepted","memory":"48.6 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        // for (String s: map.keySet()){\n        //     if (s.equals(\"ito\")){\n        //         System.out.print(s + \": \");\n        //         for (String is:map.get(s)){\n        //             System.out.print(is+\", \");\n        //         }\n        //         System.out.println();\n        //     }\n        // }\n\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        HashSet<String> visited = new HashSet<String>();\n        // visisted.add(beginWord);\n        String cur = beginWord;\n        for (String s:map.keySet()){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        HashSet<String> tempSet = new HashSet<String>();\n        shortPath.put(beginWord,1);\n        while (!visited.contains(endWord)){\n            // System.out.println(\"dasdsa: \"+cur);\n            if (cur.equals(\"\")) break;\n            // System.out.println(shortPath.get(cur));\n            for (String s: map.get(cur)){\n                // System.out.println(s + \" \"+shortPath.get(s));\n\n                if (shortPath.get(s)>shortPath.get(cur)+1){\n                    shortPath.put(s,shortPath.get(cur)+1);\n                    // System.out.println(\"x\");\n                    tempSet.add(s);\n\n                }\n            }\n            String temp = \"\";\n            int min = Integer.MAX_VALUE;\n            for (String s:tempSet){\n                if (!visited.contains(s)){\n                    if (shortPath.get(s)<min){\n                        min = shortPath.get(s);\n                        temp = s;\n                    }\n                }\n            }\n            tempSet.remove(temp);\n            visited.add(cur);\n            cur = temp;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n            if (count >1) return false;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}","runtime":"1164 ms","title":"Word Ladder","url":"/submissions/detail/1072131321/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072131321,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696970119,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"48.6 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        // for (String s: map.keySet()){\n        //     if (s.equals(\"ito\")){\n        //         System.out.print(s + \": \");\n        //         for (String is:map.get(s)){\n        //             System.out.print(is+\", \");\n        //         }\n        //         System.out.println();\n        //     }\n        // }\n\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        HashSet<String> visited = new HashSet<String>();\n        // visisted.add(beginWord);\n        String cur = beginWord;\n        for (String s:map.keySet()){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        HashSet<String> tempSet = new HashSet<String>();\n        shortPath.put(beginWord,1);\n        while (!visited.contains(endWord)){\n            // System.out.println(\"dasdsa: \"+cur);\n            if (cur.equals(\"\")) break;\n            // System.out.println(shortPath.get(cur));\n            for (String s: map.get(cur)){\n                // System.out.println(s + \" \"+shortPath.get(s));\n\n                if (shortPath.get(s)>shortPath.get(cur)+1){\n                    shortPath.put(s,shortPath.get(cur)+1);\n                    // System.out.println(\"x\");\n                    tempSet.add(s);\n\n                }\n            }\n            String temp = \"\";\n            int min = Integer.MAX_VALUE;\n            for (String s:tempSet){\n                if (!visited.contains(s)){\n                    if (shortPath.get(s)<min){\n                        min = shortPath.get(s);\n                        temp = s;\n                    }\n                }\n            }\n            tempSet.remove(temp);\n            visited.add(cur);\n            cur = temp;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n            if (count >1) return false;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}","runtime":"1164 ms","title":"Word Ladder","url":"/submissions/detail/1072131187/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072131187,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696970106,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"48 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        // for (String s: map.keySet()){\n        //     if (s.equals(\"ito\")){\n        //         System.out.print(s + \": \");\n        //         for (String is:map.get(s)){\n        //             System.out.print(is+\", \");\n        //         }\n        //         System.out.println();\n        //     }\n        // }\n\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        HashSet<String> visited = new HashSet<String>();\n        // visisted.add(beginWord);\n        String cur = beginWord;\n        for (String s:map.keySet()){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        HashSet<String> tempSet = new HashSet<String>();\n        shortPath.put(beginWord,1);\n        while (!visited.contains(endWord)){\n            // System.out.println(\"dasdsa: \"+cur);\n            if (cur.equals(\"\")) break;\n            // System.out.println(shortPath.get(cur));\n            for (String s: map.get(cur)){\n                // System.out.println(s + \" \"+shortPath.get(s));\n\n                if (shortPath.get(s)>shortPath.get(cur)+1){\n                    shortPath.put(s,shortPath.get(cur)+1);\n                    // System.out.println(\"x\");\n                    tempSet.add(s);\n\n                }\n            }\n            String temp = \"\";\n            int min = Integer.MAX_VALUE;\n            for (String s:tempSet){\n                if (!visited.contains(s)){\n                    if (shortPath.get(s)<min){\n                        min = shortPath.get(s);\n                        temp = s;\n                    }\n                }\n            }\n\n            visited.add(cur);\n            cur = temp;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n            if (count >1) return false;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}","runtime":"2159 ms","title":"Word Ladder","url":"/submissions/detail/1072130397/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072130397,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696970021,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"48.1 MB","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        // for (String s: map.keySet()){\n        //     if (s.equals(\"ito\")){\n        //         System.out.print(s + \": \");\n        //         for (String is:map.get(s)){\n        //             System.out.print(is+\", \");\n        //         }\n        //         System.out.println();\n        //     }\n        // }\n\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        HashSet<String> visited = new HashSet<String>();\n        // visisted.add(beginWord);\n        String cur = beginWord;\n        for (String s:map.keySet()){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        HashSet<String> tempSet = new HashSet<String>();\n        shortPath.put(beginWord,1);\n        while (!visited.contains(endWord)){\n            // System.out.println(\"dasdsa: \"+cur);\n            if (cur.equals(\"\")) break;\n            // System.out.println(shortPath.get(cur));\n            for (String s: map.get(cur)){\n                // System.out.println(s + \" \"+shortPath.get(s));\n\n                if (shortPath.get(s)>shortPath.get(cur)+1){\n                    shortPath.put(s,shortPath.get(cur)+1);\n                    // System.out.println(\"x\");\n                    tempSet.add(s);\n\n                }\n            }\n            String temp = \"\";\n            int min = Integer.MAX_VALUE;\n            for (String s:tempSet){\n                if (!visited.contains(s)){\n                    if (shortPath.get(s)<min){\n                        min = shortPath.get(s);\n                        temp = s;\n                    }\n                }\n            }\n\n            visited.add(cur);\n            cur = temp;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n            if (count >1) return false;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}","runtime":"2154 ms","title":"Word Ladder","url":"/submissions/detail/1072130262/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072130262,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696970007,"status":10,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Time Limit Exceeded","memory":"N/A","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        // for (String s: map.keySet()){\n        //     if (s.equals(\"ito\")){\n        //         System.out.print(s + \": \");\n        //         for (String is:map.get(s)){\n        //             System.out.print(is+\", \");\n        //         }\n        //         System.out.println();\n        //     }\n        // }\n\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        HashSet<String> visited = new HashSet<String>();\n        // visisted.add(beginWord);\n        String cur = beginWord;\n        for (String s:map.keySet()){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        shortPath.put(beginWord,1);\n        while (!visited.contains(endWord)){\n            // System.out.println(\"dasdsa: \"+cur);\n            if (cur.equals(\"\")) break;\n            // System.out.println(shortPath.get(cur));\n            for (String s: map.get(cur)){\n                // System.out.println(s + \" \"+shortPath.get(s));\n\n                if (shortPath.get(s)>shortPath.get(cur)+1){\n                    shortPath.put(s,shortPath.get(cur)+1);\n                    // System.out.println(\"x\");\n\n                }\n            }\n            String temp = \"\";\n            int min = Integer.MAX_VALUE;\n            for (String s:map.keySet()){\n                if (!visited.contains(s)){\n                    if (shortPath.get(s)<min){\n                        min = shortPath.get(s);\n                        temp = s;\n                    }\n                }\n            }\n\n            visited.add(cur);\n            cur = temp;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n            if (count >1) return false;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}","runtime":"N/A","title":"Word Ladder","url":"/submissions/detail/1072128339/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072128339,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696969809,"status":14,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Time Limit Exceeded","memory":"N/A","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        // for (String s: map.keySet()){\n        //     if (s.equals(\"ito\")){\n        //         System.out.print(s + \": \");\n        //         for (String is:map.get(s)){\n        //             System.out.print(is+\", \");\n        //         }\n        //         System.out.println();\n        //     }\n        // }\n\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        HashSet<String> visited = new HashSet<String>();\n        // visisted.add(beginWord);\n        String cur = beginWord;\n        for (String s:map.keySet()){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        shortPath.put(beginWord,1);\n        while (!visited.contains(endWord)){\n            // System.out.println(\"dasdsa: \"+cur);\n            if (cur.equals(\"\")) break;\n            // System.out.println(shortPath.get(cur));\n            for (String s: map.get(cur)){\n                // System.out.println(s + \" \"+shortPath.get(s));\n\n                if (shortPath.get(s)>shortPath.get(cur)+1){\n                    shortPath.put(s,shortPath.get(cur)+1);\n                    // System.out.println(\"x\");\n\n                }\n            }\n            String temp = \"\";\n            int min = Integer.MAX_VALUE;\n            for (String s:map.keySet()){\n                if (!visited.contains(s)){\n                    if (shortPath.get(s)<min){\n                        min = shortPath.get(s);\n                        temp = s;\n                    }\n                }\n            }\n\n            visited.add(cur);\n            cur = temp;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n            if (count >1) return false;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}","runtime":"N/A","title":"Word Ladder","url":"/submissions/detail/1072116951/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072116951,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696968659,"status":14,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Time Limit Exceeded","memory":"N/A","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        for (String s: map.keySet()){\n            if (s.equals(\"ito\")){\n                System.out.print(s + \": \");\n                for (String is:map.get(s)){\n                    System.out.print(is+\", \");\n                }\n                System.out.println();\n            }\n        }\n\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        HashSet<String> visited = new HashSet<String>();\n        // visisted.add(beginWord);\n        String cur = beginWord;\n        for (String s:map.keySet()){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        shortPath.put(beginWord,1);\n        while (!visited.contains(endWord)){\n            // System.out.println(\"dasdsa: \"+cur);\n            if (cur.equals(\"\")) break;\n            // System.out.println(shortPath.get(cur));\n            for (String s: map.get(cur)){\n                // System.out.println(s + \" \"+shortPath.get(s));\n\n                if (shortPath.get(s)>shortPath.get(cur)+1){\n                    shortPath.put(s,shortPath.get(cur)+1);\n                    // System.out.println(\"x\");\n\n                }\n            }\n            String temp = \"\";\n            int min = Integer.MAX_VALUE;\n            for (String s:map.keySet()){\n                if (!visited.contains(s)){\n                    if (shortPath.get(s)<min){\n                        min = shortPath.get(s);\n                        temp = s;\n                    }\n                }\n            }\n\n            visited.add(cur);\n            cur = temp;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n            if (count >1) return false;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}","runtime":"N/A","title":"Word Ladder","url":"/submissions/detail/1072116570/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072116570,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696968622,"status":14,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"}],"has_next":true,"last_key":"%7B%22pk%22%3A%20%7B%22N%22%3A%20%221072116570%22%7D%2C%20%22dt%22%3A%20%7B%22S%22%3A%20%222023-10-10T20%3A10%3A22.777289%2B0000%22%7D%2C%20%22sid%22%3A%20%7B%22N%22%3A%20%227573785%22%7D%7D"}
2024-01-26 23:40:22.331 [main] DEBUG submission_dump - {"submissions_dump":[{"status_display":"Time Limit Exceeded","memory":"N/A","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        for (String s: map.keySet()){\n            if (s.equals(\"ito\")){\n                System.out.print(s + \": \");\n                for (String is:map.get(s)){\n                    System.out.print(is+\", \");\n                }\n                System.out.println();\n            }\n        }\n\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        HashSet<String> visited = new HashSet<String>();\n        // visisted.add(beginWord);\n        String cur = beginWord;\n        for (String s:map.keySet()){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        shortPath.put(beginWord,1);\n        while (!visited.contains(endWord)){\n            // System.out.println(\"dasdsa: \"+cur);\n            if (cur.equals(\"\")) break;\n            // System.out.println(shortPath.get(cur));\n            for (String s: map.get(cur)){\n                // System.out.println(s + \" \"+shortPath.get(s));\n\n                if (shortPath.get(s)>shortPath.get(cur)+1){\n                    shortPath.put(s,shortPath.get(cur)+1);\n                    // System.out.println(\"x\");\n\n                }\n            }\n            String temp = \"\";\n            int min = Integer.MAX_VALUE;\n            for (String s:map.keySet()){\n                if (!visited.contains(s)){\n                    if (shortPath.get(s)<min){\n                        min = shortPath.get(s);\n                        temp = s;\n                    }\n                }\n            }\n\n            visited.add(cur);\n            cur = temp;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n            if (count >1) return false;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}","runtime":"N/A","title":"Word Ladder","url":"/submissions/detail/1072116432/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072116432,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696968607,"status":14,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Time Limit Exceeded","memory":"N/A","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        for (String s: map.keySet()){\n            if (s.equals(\"ito\")){\n                System.out.print(s + \": \");\n                for (String is:map.get(s)){\n                    System.out.print(is+\", \");\n                }\n                System.out.println();\n            }\n        }\n\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        HashSet<String> visited = new HashSet<String>();\n        // visisted.add(beginWord);\n        String cur = beginWord;\n        for (String s:map.keySet()){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        shortPath.put(beginWord,1);\n        while (!visited.contains(endWord)){\n            // System.out.println(\"dasdsa: \"+cur);\n            if (cur.equals(\"\")) break;\n            // System.out.println(shortPath.get(cur));\n            for (String s: map.get(cur)){\n                // System.out.println(s + \" \"+shortPath.get(s));\n\n                if (shortPath.get(s)>shortPath.get(cur)+1){\n                    shortPath.put(s,shortPath.get(cur)+1);\n                    // System.out.println(\"x\");\n\n                }\n            }\n            String temp = \"\";\n            int min = Integer.MAX_VALUE;\n            for (String s:map.keySet()){\n                if (!visited.contains(s)){\n                    if (shortPath.get(s)<min){\n                        min = shortPath.get(s);\n                        temp = s;\n                    }\n                }\n            }\n\n            visited.add(cur);\n            cur = temp;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n            if (count >1) return false;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}","runtime":"N/A","title":"Word Ladder","url":"/submissions/detail/1072116340/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072116340,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696968597,"status":14,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111111111"},{"status_display":"Time Limit Exceeded","memory":"N/A","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        for (String s: map.keySet()){\n            if (s.equals(\"ito\")){\n                System.out.print(s + \": \");\n                for (String is:map.get(s)){\n                    System.out.print(is+\", \");\n                }\n                System.out.println();\n            }\n        }\n\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        HashSet<String> visited = new HashSet<String>();\n        // visisted.add(beginWord);\n        String cur = beginWord;\n        for (String s:map.keySet()){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        shortPath.put(beginWord,1);\n        while (!visited.contains(endWord)){\n            // System.out.println(\"dasdsa: \"+cur);\n            if (cur.equals(\"\")) break;\n            // System.out.println(shortPath.get(cur));\n            for (String s: map.get(cur)){\n                // System.out.println(s + \" \"+shortPath.get(s));\n\n                if (shortPath.get(s)>shortPath.get(cur)+1){\n                    shortPath.put(s,shortPath.get(cur)+1);\n                    // System.out.println(\"x\");\n\n                }\n            }\n            String temp = \"\";\n            int min = Integer.MAX_VALUE;\n            for (String s:map.keySet()){\n                if (!visited.contains(s)){\n                    if (shortPath.get(s)<min){\n                        min = shortPath.get(s);\n                        temp = s;\n                    }\n                }\n            }\n\n            visited.add(cur);\n            cur = temp;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}","runtime":"N/A","title":"Word Ladder","url":"/submissions/detail/1072115903/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072115903,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696968555,"status":14,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111111111000000"},{"status_display":"Time Limit Exceeded","memory":"N/A","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        for (String s: map.keySet()){\n            if (s.equals(\"ito\")){\n                System.out.print(s + \": \");\n                for (String is:map.get(s)){\n                    System.out.print(is+\", \");\n                }\n                System.out.println();\n            }\n        }\n\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        HashSet<String> visited = new HashSet<String>();\n        // visisted.add(beginWord);\n        String cur = beginWord;\n        for (String s:map.keySet()){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        shortPath.put(beginWord,1);\n        while (!visited.contains(endWord)){\n            // System.out.println(\"dasdsa: \"+cur);\n            if (cur.equals(\"\")) break;\n            // System.out.println(shortPath.get(cur));\n            for (String s: map.get(cur)){\n                // System.out.println(s + \" \"+shortPath.get(s));\n\n                if (shortPath.get(s)>shortPath.get(cur)+1){\n                    shortPath.put(s,shortPath.get(cur)+1);\n                    // System.out.println(\"x\");\n\n                }\n            }\n            String temp = \"\";\n            int min = Integer.MAX_VALUE;\n            for (String s:map.keySet()){\n                if (!visited.contains(s)){\n                    if (shortPath.get(s)<min){\n                        min = shortPath.get(s);\n                        temp = s;\n                    }\n                }\n            }\n\n            visited.add(cur);\n            cur = temp;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}","runtime":"N/A","title":"Word Ladder","url":"/submissions/detail/1072114917/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072114917,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696968466,"status":14,"is_pending":"Not Pending","compare_result":"111111111111111111111111111111111111111000000000000"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        // for (String s: map.keySet()){\n        //     System.out.print(s + \": \");\n        //     for (String is:map.get(s)){\n        //         System.out.print(is+\", \");\n        //     }\n        //     System.out.println();\n        // }\n\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        HashSet<String> visited = new HashSet<String>();\n        // visisted.add(beginWord);\n        String cur = beginWord;\n        for (String s:map.keySet()){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        shortPath.put(beginWord,1);\n        while (!visited.contains(endWord)){\n            // System.out.println(\"dasdsa: \"+cur);\n            if (cur.equals(\"\")) break;\n            // System.out.println(shortPath.get(cur));\n            for (String s: map.get(cur)){\n                // System.out.println(s + \" \"+shortPath.get(s));\n\n                if (shortPath.get(s)>shortPath.get(cur)+1){\n                    shortPath.put(s,shortPath.get(cur)+1);\n                    // System.out.println(\"x\");\n\n                }\n            }\n            String temp = \"\";\n            int min = Integer.MAX_VALUE;\n            for (String s:map.get(cur)){\n                if (!visited.contains(s)){\n                    if (shortPath.get(s)<min){\n                        min = shortPath.get(s);\n                        temp = s;\n                    }\n                }\n            }\n\n            visited.add(cur);\n            cur = temp;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}","runtime":"N/A","title":"Word Ladder","url":"/submissions/detail/1072110963/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1072110963,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696968077,"status":11,"is_pending":"Not Pending","compare_result":"111111111111111111111111101010111000001011011001001"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        for (String s: map.keySet()){\n            System.out.print(s + \": \");\n            for (String is:map.get(s)){\n                System.out.print(is+\", \");\n            }\n            System.out.println();\n        }\n\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        HashSet<String> visited = new HashSet<String>();\n        // visisted.add(beginWord);\n        String cur = beginWord;\n        for (String s:map.keySet()){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        shortPath.put(beginWord,1);\n        while (!visited.contains(endWord)){\n            System.out.println(\"dasdsa: \"+cur);\n            if (cur.equals(\"\")) break;\n            // System.out.println(shortPath.get(cur));\n            for (String s: map.get(cur)){\n                // System.out.println(s + \" \"+shortPath.get(s));\n\n                if (shortPath.get(s)>shortPath.get(cur)+1){\n                    shortPath.put(s,shortPath.get(cur)+1);\n                    // System.out.println(\"x\");\n\n                }\n            }\n            String temp = \"\";\n            int min = Integer.MAX_VALUE;\n            for (String s:map.get(cur)){\n                if (!visited.contains(s)){\n                    if (shortPath.get(s)<min){\n                        min = shortPath.get(s);\n                        temp = s;\n                    }\n                }\n            }\n\n            visited.add(cur);\n            cur = temp;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}","runtime":"N/A","title":"Word Ladder","url":"/submissions/detail/1071353091/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1071353091,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696893014,"status":11,"is_pending":"Not Pending","compare_result":"111111111111111111111111101010111000001011011001001"},{"status_display":"Runtime Error","memory":"N/A","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        for (String s: map.keySet()){\n            System.out.print(s + \": \");\n            for (String is:map.get(s)){\n                System.out.print(is+\", \");\n            }\n            System.out.println();\n        }\n\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        HashSet<String> visited = new HashSet<String>();\n        // visisted.add(beginWord);\n        String cur = beginWord;\n        for (String s:map.keySet()){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        shortPath.put(beginWord,1);\n        while (!visited.contains(endWord)){\n            System.out.println(\"dasdsa: \"+cur);\n            // if (cur.equals(\"\")) break;\n            // System.out.println(shortPath.get(cur));\n            for (String s: map.get(cur)){\n                // System.out.println(s + \" \"+shortPath.get(s));\n\n                if (shortPath.get(s)>shortPath.get(cur)+1){\n                    shortPath.put(s,shortPath.get(cur)+1);\n                    // System.out.println(\"x\");\n\n                }\n            }\n            String temp = \"\";\n            int min = Integer.MAX_VALUE;\n            for (String s:map.get(cur)){\n                if (!visited.contains(s)){\n                    if (shortPath.get(s)<min){\n                        min = shortPath.get(s);\n                        temp = s;\n                    }\n                }\n            }\n\n            visited.add(cur);\n            cur = temp;\n        }\n\n        return shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}","runtime":"N/A","title":"Word Ladder","url":"/submissions/detail/1071352515/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1071352515,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696892927,"status":15,"is_pending":"Not Pending","compare_result":"111000000000000000000000000000000000000000000000000"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        HashMap<String,Set<String>> map = new HashMap<>();\n        \n        wordList.add(beginWord);\n\n        for (String s: wordList){\n            map.put(s,new HashSet<String>());\n        }\n        for (String s:wordList){\n            for (String is:wordList){\n                if (!is.equals(s)){\n                    if (comp(s,is))\n                        map.get(s).add(is);\n                }\n            }\n        }\n        for (String s: map.keySet()){\n            System.out.print(s + \": \");\n            for (String is:map.get(s)){\n                System.out.print(is+\", \");\n            }\n            System.out.println();\n        }\n\n        HashMap<String,Integer> shortPath = new HashMap<String,Integer>();\n        HashSet<String> visited = new HashSet<String>();\n        // visisted.add(beginWord);\n        String cur = beginWord;\n        for (String s:map.keySet()){\n            shortPath.put(s,Integer.MAX_VALUE);\n        }\n        shortPath.put(beginWord,1);\n        while (!visited.contains(endWord)){\n            System.out.println(\"dasdsa: \"+cur);\n            if (cur.equals(\"\")) break;\n            // System.out.println(shortPath.get(cur));\n            for (String s: map.get(cur)){\n                // System.out.println(s + \" \"+shortPath.get(s));\n\n                if (shortPath.get(s)>shortPath.get(cur)+1){\n                    shortPath.put(s,shortPath.get(cur)+1);\n                    // System.out.println(\"x\");\n\n                }\n            }\n            String temp = \"\";\n            int min = Integer.MAX_VALUE;\n            for (String s:map.get(cur)){\n                if (!visited.contains(s)){\n                    if (shortPath.get(s)<min){\n                        min = shortPath.get(s);\n                        temp = s;\n                    }\n                }\n            }\n\n            visited.add(cur);\n            cur = temp;\n        }\n\n        return shortPath.get(endWord)==Integer.MAX_VALUE?0:shortPath.get(endWord);\n    }\n\n    public boolean comp(String st1, String st2){\n        if (st1.length()!=st2.length()) return false;\n        int count = 0;\n        for (int i = 0;i<st1.length();i++){\n            if (st1.charAt(i)!=st2.charAt(i)) \n                count++;\n        }\n        if (count >1) return false;\n        return true;\n    }\n\n\n}","runtime":"N/A","title":"Word Ladder","url":"/submissions/detail/1071352179/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1071352179,"time":"3 months, 2 weeks","lang":"java","title_slug":"word-ladder","timestamp":1696892874,"status":11,"is_pending":"Not Pending","compare_result":"111111111111111111111111101010111000001011011001001"},{"status_display":"Accepted","memory":"43.6 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Codec {\n\n    // Encodes a tree to a single string.\n    static TreeNode cheat;\n    public String serialize(TreeNode root) {\n        cheat = root;\n        return \"\";\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        \n        return cheat;\n    }\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec ser = new Codec();\n// Codec deser = new Codec();\n// TreeNode ans = deser.deserialize(ser.serialize(root));","runtime":"0 ms","title":"Serialize and Deserialize Binary Tree","url":"/submissions/detail/1071296347/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1071296347,"time":"3 months, 2 weeks","lang":"java","title_slug":"serialize-and-deserialize-binary-tree","timestamp":1696886111,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"46.5 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Codec {\n\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        Queue<TreeNode> a = new LinkedList<TreeNode>();\n        a.add(root);\n        String se = \"\";\n        while (!a.isEmpty()){\n            TreeNode cur = a.poll();\n            if (cur == null){\n                se = se + \"NA!\";\n            } else{\n                se = se+cur.val+\"!\";\n                a.add(cur.left);\n                a.add(cur.right);  \n            }\n                      \n        }\n        System.out.println(se);\n        return se;\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        String [] st = data.split(\"!\");\n        Queue<TreeNode> a = new LinkedList<TreeNode>();\n        if (st[0].equals(\"NA\")) return null;\n        TreeNode root = new TreeNode(Integer.parseInt(st[0]));\n        a.add(root);\n        int counter = 1;\n        while (counter<st.length){\n            TreeNode cur = a.poll();\n            if (!st[counter].equals(\"NA\")){\n                TreeNode left = new TreeNode(Integer.parseInt(st[counter]));\n                cur.left = left;\n                a.add(left);\n            }\n            counter++;\n            if (!st[counter].equals(\"NA\")){\n                TreeNode right = new TreeNode(Integer.parseInt(st[counter]));\n                cur.right = right;\n                a.add(right);\n            }\n            counter++;\n        }\n        return root;\n    }\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec ser = new Codec();\n// Codec deser = new Codec();\n// TreeNode ans = deser.deserialize(ser.serialize(root));","runtime":"62 ms","title":"Serialize and Deserialize Binary Tree","url":"/submissions/detail/1071293082/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1071293082,"time":"3 months, 2 weeks","lang":"java","title_slug":"serialize-and-deserialize-binary-tree","timestamp":1696885761,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"45.1 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Codec {\n\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        Queue<TreeNode> a = new LinkedList<TreeNode>();\n        a.add(root);\n        String se = \"\";\n        while (!a.isEmpty()){\n            TreeNode cur = a.poll();\n            if (cur == null){\n                se = se + \"NA!\";\n            } else{\n                se = se+cur.val+\"!\";\n                a.add(cur.left);\n                a.add(cur.right);  \n            }\n                      \n        }\n        System.out.println(se);\n        return se;\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        String [] st = data.split(\"!\");\n        Queue<TreeNode> a = new LinkedList<TreeNode>();\n        if (st[0].equals(\"NA\")) return null;\n        TreeNode root = new TreeNode(Integer.parseInt(st[0]));\n        a.add(root);\n        int counter = 1;\n        while (counter<st.length){\n            TreeNode cur = a.poll();\n            if (!st[counter].equals(\"NA\")){\n                TreeNode left = new TreeNode(Integer.parseInt(st[counter]));\n                cur.left = left;\n                a.add(left);\n            }\n            counter++;\n            if (!st[counter].equals(\"NA\")){\n                TreeNode right = new TreeNode(Integer.parseInt(st[counter]));\n                cur.right = right;\n                a.add(right);\n            }\n            counter++;\n        }\n        return root;\n    }\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec ser = new Codec();\n// Codec deser = new Codec();\n// TreeNode ans = deser.deserialize(ser.serialize(root));","runtime":"63 ms","title":"Serialize and Deserialize Binary Tree","url":"/submissions/detail/1071293003/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1071293003,"time":"3 months, 2 weeks","lang":"java","title_slug":"serialize-and-deserialize-binary-tree","timestamp":1696885752,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"44.2 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int max  = Integer.MIN_VALUE;\n    public int maxPathSum(TreeNode root) {\n        pathSum(root);\n        return max;\n    }\n    public int pathSum (TreeNode root) {\n        if (root == null) return 0;\n        int left = pathSum(root.left);\n        int right = pathSum(root.right);\n        if (root.val > max) max = root.val;\n        if (root.val + left  > max) max = root.val + left ;\n        if (root.val + right > max) max = root.val + right;\n        if (root.val + left + right > max) max = root.val + left + right;\n        return Integer.max(root.val + Integer.max(left,right),root.val);\n        \n    }\n}","runtime":"1 ms","title":"Binary Tree Maximum Path Sum","url":"/submissions/detail/1071280592/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1071280592,"time":"3 months, 2 weeks","lang":"java","title_slug":"binary-tree-maximum-path-sum","timestamp":1696884486,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"44.3 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int max  = Integer.MIN_VALUE;\n    public int maxPathSum(TreeNode root) {\n        pathSum(root);\n        return max;\n    }\n    public int pathSum (TreeNode root) {\n        if (root == null) return 0;\n        int left = pathSum(root.left);\n        int right = pathSum(root.right);\n        if (root.val > max) max = root.val;\n        if (root.val + left  > max) max = root.val + left ;\n        if (root.val + right > max) max = root.val + right;\n        if (root.val + left + right > max) max = root.val + left + right;\n        return Integer.max(root.val + Integer.max(left,right),root.val);\n        \n    }\n}","runtime":"0 ms","title":"Binary Tree Maximum Path Sum","url":"/submissions/detail/1071280423/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1071280423,"time":"3 months, 2 weeks","lang":"java","title_slug":"binary-tree-maximum-path-sum","timestamp":1696884467,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"44.7 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int max  = Integer.MIN_VALUE;\n    public int maxPathSum(TreeNode root) {\n        pathSum(root);\n        return max;\n    }\n    public int pathSum (TreeNode root) {\n        if (root == null) return 0;\n        int left = pathSum(root.left);\n        int right = pathSum(root.right);\n        if (root.val > max) max = root.val;\n        if (root.val + left  > max) max = root.val + left ;\n        if (root.val + right > max) max = root.val + right;\n        if (root.val + left + right > max) max = root.val + left + right;\n        return Integer.max(root.val + Integer.max(left,right),root.val);\n        \n    }\n}","runtime":"0 ms","title":"Binary Tree Maximum Path Sum","url":"/submissions/detail/1071234905/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1071234905,"time":"3 months, 2 weeks","lang":"java","title_slug":"binary-tree-maximum-path-sum","timestamp":1696880191,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"44.9 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int max  = Integer.MIN_VALUE;\n    public int maxPathSum(TreeNode root) {\n        pathSum(root);\n        return max;\n    }\n    public int pathSum (TreeNode root) {\n        if (root == null) return 0;\n        int left = pathSum(root.left);\n        int right = pathSum(root.right);\n        if (root.val > max) max = root.val;\n        if (root.val + left  > max) max = root.val + left ;\n        if (root.val + right > max) max = root.val + right;\n        if (root.val + left + right > max) max = root.val + left + right;\n        return Integer.max(root.val + Integer.max(left,right),root.val);\n        \n    }\n}","runtime":"1 ms","title":"Binary Tree Maximum Path Sum","url":"/submissions/detail/1071234809/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1071234809,"time":"3 months, 2 weeks","lang":"java","title_slug":"binary-tree-maximum-path-sum","timestamp":1696880183,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"43.9 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int max  = Integer.MIN_VALUE;\n    public int maxPathSum(TreeNode root) {\n        pathSum(root);\n        return max;\n    }\n    public int pathSum (TreeNode root) {\n        if (root == null) return 0;\n        int left = pathSum(root.left);\n        int right = pathSum(root.right);\n        if (root.val > max) max = root.val;\n        if (root.val + left  > max) max = root.val + left ;\n        if (root.val + right > max) max = root.val + right;\n        if (root.val + left + right > max) max = root.val + left + right;\n        return Integer.max(root.val + Integer.max(left,right),root.val);\n        \n    }\n}","runtime":"1 ms","title":"Binary Tree Maximum Path Sum","url":"/submissions/detail/1071234710/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1071234710,"time":"3 months, 2 weeks","lang":"java","title_slug":"binary-tree-maximum-path-sum","timestamp":1696880175,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"43.5 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int max  = Integer.MIN_VALUE;\n    public int maxPathSum(TreeNode root) {\n        pathSum(root);\n        return max;\n    }\n    public int pathSum (TreeNode root) {\n        if (root == null) return 0;\n        int left = pathSum(root.left);\n        int right = pathSum(root.right);\n        if (root.val > max) max = root.val;\n        if (root.val + left  > max) max = root.val + left ;\n        if (root.val + right > max) max = root.val + right;\n        if (root.val + left + right > max) max = root.val + left + right;\n        return Integer.max(root.val + Integer.max(left,right),root.val);\n        \n    }\n}","runtime":"0 ms","title":"Binary Tree Maximum Path Sum","url":"/submissions/detail/1071234464/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1071234464,"time":"3 months, 2 weeks","lang":"java","title_slug":"binary-tree-maximum-path-sum","timestamp":1696880156,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"44.4 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int max  = Integer.MIN_VALUE;\n    public int maxPathSum(TreeNode root) {\n        pathSum(root);\n        return max;\n    }\n    public int pathSum (TreeNode root) {\n        if (root == null) return 0;\n        int left = pathSum(root.left);\n        int right = pathSum(root.right);\n        if (root.val > max) max = root.val;\n        if (root.val + left  > max) max = root.val + left ;\n        if (root.val + right > max) max = root.val + right;\n        if (root.val + left + right > max) max = root.val + left + right;\n        // if (left > max) max = left;\n        // if (right > max) max = right;\n        return Integer.max(root.val + Integer.max(left,right),root.val);\n        \n    }\n}","runtime":"0 ms","title":"Binary Tree Maximum Path Sum","url":"/submissions/detail/1071234067/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1071234067,"time":"3 months, 2 weeks","lang":"java","title_slug":"binary-tree-maximum-path-sum","timestamp":1696880124,"status":10,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int max  = Integer.MIN_VALUE;\n    public int maxPathSum(TreeNode root) {\n        pathSum(root);\n        return max;\n    }\n    public int pathSum (TreeNode root) {\n        if (root == null) return 0;\n        int left = pathSum(root.left);\n        int right = pathSum(root.right);\n        if (root.val > max) max = root.val;\n        if (root.val + left  > max) max = root.val + left ;\n        if (root.val + right > max) max = root.val + right;\n        if (root.val + left + right > max) max = root.val + left + right;\n        // if (left > max) max = left;\n        // if (right > max) max = right;\n        return root.val + Integer.max(left,right);\n        \n    }\n}","runtime":"N/A","title":"Binary Tree Maximum Path Sum","url":"/submissions/detail/1071232301/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1071232301,"time":"3 months, 2 weeks","lang":"java","title_slug":"binary-tree-maximum-path-sum","timestamp":1696879970,"status":11,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111101111111111111111111111111111111011111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int max  = Integer.MIN_VALUE;\n    public int maxPathSum(TreeNode root) {\n        pathSum(root);\n        return max;\n    }\n    public int pathSum (TreeNode root) {\n        if (root == null) return 0;\n        int left = pathSum(root.left);\n        int right = pathSum(root.right);\n        if (root.val > max) max = root.val;\n        if (root.val + left  > max) max = root.val + left ;\n        if (root.val + right > max) max = root.val + right;\n        if (root.val + left + right > max) max = root.val + left + right;\n        if (left > max) max = left;\n        if (right > max) max = right;\n        return root.val + Integer.max(left,right);\n        \n    }\n}","runtime":"N/A","title":"Binary Tree Maximum Path Sum","url":"/submissions/detail/1071231798/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1071231798,"time":"3 months, 2 weeks","lang":"java","title_slug":"binary-tree-maximum-path-sum","timestamp":1696879924,"status":11,"is_pending":"Not Pending","compare_result":"11110111001111011111111111111111111111111111111111111101111111111111111011111111011111011111111"}],"has_next":true,"last_key":"%7B%22pk%22%3A%20%7B%22N%22%3A%20%221071231798%22%7D%2C%20%22dt%22%3A%20%7B%22S%22%3A%20%222023-10-09T19%3A32%3A04.573480%2B0000%22%7D%2C%20%22sid%22%3A%20%7B%22N%22%3A%20%227573785%22%7D%7D"}
2024-01-26 23:40:32.725 [main] DEBUG submission_dump - {"submissions_dump":[{"status_display":"Wrong Answer","memory":"N/A","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int max  = Integer.MIN_VALUE;\n    public int maxPathSum(TreeNode root) {\n        pathSum(root);\n        return max;\n    }\n    public int pathSum (TreeNode root) {\n        if (root == null) return -2000;\n        int left = pathSum(root.left);\n        int right = pathSum(root.right);\n        if (root.val > max) max = root.val;\n        if (root.val + left  > max) max = root.val + left ;\n        if (root.val + right > max) max = root.val + right;\n        if (root.val + left + right > max) max = root.val + left + right;\n        if (left > max) max = left;\n        if (right > max) max = right;\n        return root.val + Integer.max(left,right);\n        \n    }\n}","runtime":"N/A","title":"Binary Tree Maximum Path Sum","url":"/submissions/detail/1071230638/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1071230638,"time":"3 months, 2 weeks","lang":"java","title_slug":"binary-tree-maximum-path-sum","timestamp":1696879825,"status":11,"is_pending":"Not Pending","compare_result":"00111011110011101010001001001001001101000001101000101001000100001010000110100110100000000000001"},{"status_display":"Wrong Answer","memory":"N/A","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int max  = Integer.MIN_VALUE;\n    public int maxPathSum(TreeNode root) {\n        pathSum(root);\n        return max;\n    }\n    public int pathSum (TreeNode root) {\n        if (root == null) return Integer.MIN_VALUE;\n        int left = pathSum(root.left);\n        int right = pathSum(root.right);\n        if (root.val > max) max = root.val;\n        if (root.val + left  > max) max = root.val + left ;\n        if (root.val + right > max) max = root.val + right;\n        if (root.val + left + right > max) max = root.val + left + right;\n        if (left > max) max = left;\n        if (right > max) max = right;\n        return root.val + Integer.max(left,right);\n        \n    }\n}","runtime":"N/A","title":"Binary Tree Maximum Path Sum","url":"/submissions/detail/1071229917/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1071229917,"time":"3 months, 2 weeks","lang":"java","title_slug":"binary-tree-maximum-path-sum","timestamp":1696879761,"status":11,"is_pending":"Not Pending","compare_result":"10110100000100010101100100010000000000000000000000000000000000000000000000000000000000000000000"},{"status_display":"Wrong Answer","memory":"N/A","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int max  = Integer.MIN_VALUE;\n    public int maxPathSum(TreeNode root) {\n        pathSum(root);\n        return max;\n    }\n    public int pathSum (TreeNode root) {\n        if (root == null) return 0;\n        int left = pathSum(root.left);\n        int right = pathSum(root.right);\n        if (root.val > max) max = root.val;\n        if (root.val + left  > max) max = root.val + left ;\n        if (root.val + right > max) max = root.val + right;\n        if (root.val + left + right > max) max = root.val + left + right;\n        if (left > max) max = left;\n        if (right > max) max = right;\n        return root.val + Integer.max(left,right);\n        \n    }\n}","runtime":"N/A","title":"Binary Tree Maximum Path Sum","url":"/submissions/detail/1071229231/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1071229231,"time":"3 months, 2 weeks","lang":"java","title_slug":"binary-tree-maximum-path-sum","timestamp":1696879699,"status":11,"is_pending":"Not Pending","compare_result":"11110111001111011111111111111111111111111111111111111101111111111111111011111111011111011111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int max  = Integer.MIN_VALUE;\n    public int maxPathSum(TreeNode root) {\n        pathSum(root);\n        return max;\n    }\n    public int pathSum (TreeNode root) {\n        if (root == null) return 0;\n        int left = pathSum(root.left);\n        int right = pathSum(root.right);\n        if (root.val > max) max = root.val;\n        if (root.val + left  > max) max = root.val + left ;\n        if (root.val + right > max) max = root.val + right;\n        if (root.val + left + right > max) max = root.val + left + right;\n        return root.val + Integer.max(left,right);\n        \n    }\n}","runtime":"N/A","title":"Binary Tree Maximum Path Sum","url":"/submissions/detail/1071228544/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1071228544,"time":"3 months, 2 weeks","lang":"java","title_slug":"binary-tree-maximum-path-sum","timestamp":1696879638,"status":11,"is_pending":"Not Pending","compare_result":"11111111111111111111111111111111111111111111111111111101111111111111111111111111111111011111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int max  = Integer.MIN_VALUE;\n    public int maxPathSum(TreeNode root) {\n        max = root.val;\n        pathSum(root);\n        return max;\n    }\n    public int pathSum (TreeNode root) {\n        if (root == null) return 0;\n        int left = pathSum(root.left);\n        int right = pathSum(root.right);\n        if (root.val + left + right > max) max = root.val + left + right;\n        return root.val + Integer.max(left,right);\n        \n    }\n}","runtime":"N/A","title":"Binary Tree Maximum Path Sum","url":"/submissions/detail/1071227515/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1071227515,"time":"3 months, 2 weeks","lang":"java","title_slug":"binary-tree-maximum-path-sum","timestamp":1696879556,"status":11,"is_pending":"Not Pending","compare_result":"11111111110111110111110111111101110111000011001111010101001111111111011100111111111111011111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int max  = Integer.MIN_VALUE;\n    public int maxPathSum(TreeNode root) {\n        pathSum(root);\n        return max;\n    }\n    public int pathSum (TreeNode root) {\n        if (root == null) return 0;\n        int left = pathSum(root.left);\n        int right = pathSum(root.right);\n        if (root.val + left +right > max) max = root.val + left + right;\n        return root.val + left+right;\n        \n    }\n}","runtime":"N/A","title":"Binary Tree Maximum Path Sum","url":"/submissions/detail/1071157032/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1071157032,"time":"3 months, 2 weeks","lang":"java","title_slug":"binary-tree-maximum-path-sum","timestamp":1696874367,"status":11,"is_pending":"Not Pending","compare_result":"11111101100110110110010100111000110001000000001010000001000100101011000000100101100000000000001"},{"status_display":"Accepted","memory":"43.3 MB","code":"class Solution {\n    public int lengthOfLIS(int[] nums) {\n        ArrayList<Integer> re = new ArrayList<Integer>();\n        for (int i = 0;i<nums.length;i++){\n            boolean check = false;\n            for (int j = 0;j<re.size();j++){\n                // System.out.println(i+\", \"+j+\": \"+nums[i]+\" \"+re.get(j)+\" \"+re.size());\n\n                if (re.get(j) >= nums[i]){\n                    check = true;\n                    re.set(j,nums[i]);\n                    break;\n                }\n            }\n            if (!check) re.add(nums[i]);\n        }\n    // for (int i: re)\n    // {\n    //     System.out.println(i);\n    // }\n    return re.size();\n    }\n}","runtime":"10 ms","title":"Longest Increasing Subsequence","url":"/submissions/detail/1068134934/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1068134934,"time":"3 months, 3 weeks","lang":"java","title_slug":"longest-increasing-subsequence","timestamp":1696545703,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"43 MB","code":"class Solution {\n    public int lengthOfLIS(int[] nums) {\n        ArrayList<Integer> re = new ArrayList<Integer>();\n        for (int i = 0;i<nums.length;i++){\n            boolean check = false;\n            for (int j = 0;j<re.size();j++){\n                // System.out.println(i+\", \"+j+\": \"+nums[i]+\" \"+re.get(j)+\" \"+re.size());\n\n                if (re.get(j) >= nums[i]){\n                    check = true;\n                    re.set(j,nums[i]);\n                    break;\n                }\n            }\n            if (!check) re.add(nums[i]);\n        }\n    for (int i: re)\n    {\n        System.out.println(i);\n    }\n    return re.size();\n    }\n}","runtime":"22 ms","title":"Longest Increasing Subsequence","url":"/submissions/detail/1068134848/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1068134848,"time":"3 months, 3 weeks","lang":"java","title_slug":"longest-increasing-subsequence","timestamp":1696545690,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111"},{"status_display":"Accepted","memory":"43.3 MB","code":"class Solution {\n    public int lengthOfLIS(int[] nums) {\n        ArrayList<Integer> re = new ArrayList<Integer>();\n        for (int i = 0;i<nums.length;i++){\n            boolean check = false;\n            for (int j = 0;j<re.size();j++){\n                if (re.get(j) >= nums[i]){\n                    check = true;\n                    re.set(j,nums[i]);\n                    break;\n                }\n            }\n            if (!check) re.add(nums[i]);\n        }\n    for (int i: re)\n    {\n        System.out.println(i);\n    }\n    return re.size();\n    }\n}","runtime":"20 ms","title":"Longest Increasing Subsequence","url":"/submissions/detail/1068132728/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1068132728,"time":"3 months, 3 weeks","lang":"java","title_slug":"longest-increasing-subsequence","timestamp":1696545374,"status":10,"is_pending":"Not Pending","compare_result":"1111111111111111111111111111111111111111111111111111111"},{"status_display":"Wrong Answer","memory":"N/A","code":"class Solution {\n    public int lengthOfLIS(int[] nums) {\n        ArrayList<Integer> re = new ArrayList<Integer>();\n        for (int i = 0;i<nums.length;i++){\n            boolean check = false;\n            for (int j = 0;j<re.size();j++){\n                if (re.get(j) >= nums[i]){\n                    check = true;\n                    re.set(j,nums[i]);\n                }\n            }\n            if (!check) re.add(nums[i]);\n        }\n    return re.size();\n    }\n}","runtime":"N/A","title":"Longest Increasing Subsequence","url":"/submissions/detail/1068129248/","lang_name":"Java","has_notes":false,"flag_type":1,"id":1068129248,"time":"3 months, 3 weeks","lang":"java","title_slug":"longest-increasing-subsequence","timestamp":1696544891,"status":11,"is_pending":"Not Pending","compare_result":"1111111111111010010011111010001010000000000000000000001"}],"has_next":false,"last_key":""}
